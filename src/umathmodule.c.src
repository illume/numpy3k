/* -*- c -*- */

#include "Python.h"
#include "scipy/arrayobject.h"
#define _UMATHMODULE
#include "scipy/ufuncobject.h"
#include "abstract.h"
#include <math.h>


/* A whole slew of basic math functions are provided originally by Konrad Hinsen. */

#if !defined(__STDC__) && !defined(_MSC_VER)
extern double fmod (double, double);
extern double frexp (double, int *);
extern double ldexp (double, int);
extern double modf (double, double *);
#endif
#ifndef M_PI
#define M_PI 3.14159265358979323846264338328
#endif

#ifndef HAVE_INVERSE_HYPERBOLIC
static double acosh(double x)
{
	return log(x + sqrt((x-1.0)*(x+1.0)));
}

static double asinh(double xx)
{
	double x;
	int sign;
	if (xx < 0.0) {
		sign = -1;
		x = -xx;
	}
	else {
		sign = 1;
		x = xx;
	}
	return sign*log(x + sqrt(x*x+1.0));
}

static double atanh(double x)
{
	return 0.5*log((1.0+x)/(1.0-x));
}
#endif


#ifdef HAVE_HYPOT
#if !defined(NeXT) && !defined(_MSC_VER)
extern double hypot(double, double);
#endif
#else
double hypot(double x, double y)
{
	double yx;

	x = fabs(x);
	y = fabs(y);
	if (x < y) {
		double temp = x;
		x = y;
		y = temp;
	}
	if (x == 0.)
		return 0.;
	else {
		yx = y/x;
		return x*sqrt(1.+yx*yx);
	}
}
#endif



/* Define isnan, isinf, isfinite, signbit if needed */
/* Use fpclassify if possible */
/* isnan, isinf --
       these will use macros and then fpclassify if available before
       defaulting to a dumb convert-to-double version...

   isfinite -- define a macro if not already available
   signbit -- if macro available use it, otherwise define a function
               and a dumb convert-to-double version for other types.
*/

#if defined(fpclassify)

#if !defined(isnan)
#define isnan(x) (fpclassify(x) == FP_NAN)
#endif
#if !defined(isinf)
#define isinf(x) (fpclassify(x) == FP_INFINITE)
#endif

#else  /* check to see if already have a function like this */

#if !defined(HAVE_ISNAN)

#if !defined(isnan)
#include "_isnan.c"
#endif

#if !defined(isinf)
#define isinf(x) (!isnan((x)) && isnan((x)-(x)))
#endif

#endif /* HAVE_ISNAN */
#endif /* !defined(isnan) */


/* Define signbit if needed */
#if !defined(signbit)
#include "_signbit.c"
#endif


/* Now defined the extended type macros */

/* We assume that isnan and isinf are defined in the same 
   way:  as functions, with extended functions, or macros
*/

#if !defined(isnan)

#if !defined(HAVE_LONGDOUBLE_FUNCS) || !defined(HAVE_ISNAN)
#define isnanl(x) isnan((double)(x)))
#define isinfl(x) (!isnanl((x)) && isnanl((x)-(x)))
#endif

#if !defined(HAVE_FLOAT_FUNCS) || !defined(HAVE_ISNAN)
#define isnanf(x) isnan((double)(x)))
#define isinff(x) (!isnanlf((x)) && isnanf((x)-(x))
#endif

#else /* !defined(isnan) */

#define isnanl(x) isnan(x)
#define isnanf(x) isnan(x)
#define isinfl(x) isinf(x)
#define isinff(x) isinf(x)

#endif /* !defined(isnan) */



#if !defined(signbit)
#define signbitl(x) ((longdouble) signbit((double)(x)))
#define signbitf(x) ((float) signbit((double) (x)))
#else
#define signbitl(x) signbit(x)
#define signbitf(x) signbit(x)
#endif

#if !defined(isfinite)
#define isfinite(x) (!(isinf(x) || isnan(x)))
#endif
#define isfinitef(x) (!(isinff(x) || isnanf(x)))
#define isfinitel(x) (!(isinfl(x) || isnanl(x)))


/* First, the C functions that do the real work */

/* if C99 extensions not availble

then define dummy functions that use the double versions for

sin, cos, tan
sinh, cosh, tanh, 
fabs, floor, ceil, fmod, sqrt, log10, log, exp, fabs
asin, acos, atan, 
asinh, acosh, atanh

hypot, atan2, pow

*/

/**begin repeat

#kind=(sin,cos,tan,sinh,cosh,tanh,fabs,floor,ceil,sqrt,log10,log,exp,asin,acos,atan,asinh,acosh,atanh)*2#
#typ=longdouble*19, float*19#
#c=l*19,f*19#
#TYPE=LONGDOUBLE*19, FLOAT*19#
*/
#ifndef HAVE_@TYPE@_FUNCS
@typ@ @kind@@c@(@typ@ x) {
	return (@typ@) @kind@((double)x);
}
#endif
/**end repeat**/

/**begin repeat

#kind=(atan2,hypot,pow,fmod)*2#
#typ=longdouble*4, float*4#
#c=l*4,f*4#
#TYPE=LONGDOUBLE*4,FLOAT*4#
*/
#ifndef HAVE_@TYPE@_FUNCS
@typ@ @kind@@c@(@typ@ x, @typ@ y) {
	return (@typ@) @kind@((double)x, (double) y);
}
#endif
/**end repeat**/

/**begin repeat
#kind=modf*2#
#typ=longdouble, float#
#c=l,f#
#TYPE=LONGDOUBLE, FLOAT#
*/
#ifndef HAVE_@TYPE@_FUNCS
@typ@ modf@c@(@typ@ x, @typ@ *iptr) {
        double nx, niptr, y;
        nx = (double) x;
        y = modf(nx, &niptr);
        *iptr = (@typ@) niptr;
        return (@typ@) y;
}
#endif
/**end repeat**/



/* Don't pass structures between functions (only pointers) because how
   structures are passed is compiler dependent and could cause
   segfaults if ufuncobject.c is compiled with a different compiler
   than an extension that makes use of the UFUNC API
*/

/**begin repeat

#typ=float, double, longdouble#
#c=f,,l#
*/

/* constants */
static c@typ@ nc_1@c@ = {1., 0.};
static c@typ@ nc_half@c@ = {0.5, 0.};
static c@typ@ nc_i@c@ = {0., 1.};
static c@typ@ nc_i2@c@ = {0., 0.5};
/*
static c@typ@ nc_mi@c@ = {0., -1.};
static c@typ@ nc_pi2@c@ = {M_PI/2., 0.};
*/

static void
nc_sum@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{
	r->real = a->real + b->real;
	r->imag = a->imag + b->imag;
	return;
}

static void
nc_diff@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{
	r->real = a->real - b->real;
	r->imag = a->imag - b->imag;
	return;
}

static void
nc_neg@c@(c@typ@ *a, c@typ@ *r)
{
	r->real = -a->real;
	r->imag = -a->imag;
	return;
}

static void
nc_prod@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{
	@typ@ ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
	r->real = ar*br - ai*bi;
	r->imag = ar*bi + ai*br;
	return;
}

static void
nc_quot@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{

	@typ@ ar=a->real, br=b->real, ai=a->imag, bi=b->imag;    
	@typ@ d = br*br + bi*bi;
	r->real = (ar*br + ai*bi)/d;
	r->imag = (ai*br - ar*bi)/d;
	return;
}

static void
nc_floor_quot@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{
	@typ@ ar=a->real, br=b->real, ai=a->imag, bi=b->imag;    
	@typ@ d = br*br + bi*bi;
	r->real = floor@c@((ar*br + ai*bi)/d);
	r->imag = 0;
	return;
}

static void 
nc_sqrt@c@(c@typ@ *x, c@typ@ *r)
{
	@typ@ s,d;
	if (x->real == 0. && x->imag == 0.)
		*r = *x;
	else {
		s = sqrt@c@(0.5*(fabs@c@(x->real) + hypot@c@(x->real,x->imag)));
		d = 0.5*x->imag/s;
		if (x->real > 0.) {
			r->real = s;
			r->imag = d;
		}
		else if (x->imag >= 0.) {
			r->real = d;
			r->imag = s;
		}
		else {
			r->real = -d;
			r->imag = -s;
		}
	}
	return;
}

static void 
nc_log@c@(c@typ@ *x, c@typ@ *r)
{
	@typ@ l = hypot@c@(x->real,x->imag);
	r->imag = atan2@c@(x->imag, x->real);
	r->real = log@c@(l);
	return;
}

static void 
nc_exp@c@(c@typ@ *x, c@typ@ *r)
{
	@typ@ a = exp@c@(x->real);
	r->real = a*cos@c@(x->imag);
	r->imag = a*sin@c@(x->imag);
	return;
}

static void
nc_pow@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{
	@typ@ ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
	
	if (br == 0. && bi == 0.) {
		r->real = 1.;
		r->imag = 0.;
	}
	else if (ar == 0. && ai == 0.) {
		r->real = 0.;
		r->imag = 0.;
	}
	else {
		nc_log@c@(a, r);
		nc_prod@c@(r, b, r);
		nc_exp@c@(r, r);
	}
	return;
}


static void 
nc_prodi@c@(c@typ@ *x, c@typ@ *r)
{
	r->real = -x->imag;
	r->imag = x->real;
	return;
}


static void 
nc_acos@c@(c@typ@ *x, c@typ@ *r)
{
	nc_prod@c@(x,x,r);
	nc_diff@c@(&nc_1@c@, r, r);
	nc_sqrt@c@(r, r);
	nc_prodi@c@(r, r);
	nc_sum@c@(x, r, r);
	nc_log@c@(r, r);
	nc_prodi@c@(r, r);
	nc_neg@c@(r, r);
	return;    
	/* return nc_neg(nc_prodi(nc_log(nc_sum(x,nc_prod(nc_i,
	   nc_sqrt(nc_diff(nc_1,nc_prod(x,x))))))));
	*/
}

static void 
nc_acosh@c@(c@typ@ *x, c@typ@ *r)
{
	nc_prod@c@(x, x, r);
	nc_diff@c@(&nc_1@c@, r, r);
	nc_sqrt@c@(r, r);
	nc_prodi@c@(r, r);
	nc_sum@c@(x, r, r);
	nc_log@c@(r, r);
	return;
	/*
	  return nc_log(nc_sum(x,nc_prod(nc_i,
	  nc_sqrt(nc_diff(nc_1,nc_prod(x,x))))));
	*/
}

static void 
nc_asin@c@(c@typ@ *x, c@typ@ *r)
{
	c@typ@ a, *pa=&a;
	nc_prod@c@(x, x, r);
	nc_diff@c@(&nc_1@c@, r, r);
	nc_sqrt@c@(r, r);
	nc_prodi@c@(x, pa);
	nc_sum@c@(pa, r, r);
	nc_log@c@(r, r);
	nc_prodi@c@(r, r);
	nc_neg@c@(r, r);
	return;
	/*    
	      return nc_neg(nc_prodi(nc_log(nc_sum(nc_prod(nc_i,x),
	      nc_sqrt(nc_diff(nc_1,nc_prod(x,x)))))));
	*/
}


static void 
nc_asinh@c@(c@typ@ *x, c@typ@ *r)
{
	nc_prod@c@(x, x, r);
	nc_sum@c@(&nc_1@c@, r, r);
	nc_sqrt@c@(r, r);
	nc_diff@c@(r, x, r);
	nc_log@c@(r, r);
	nc_neg@c@(r, r);
	return;
	/*
	  return nc_neg(nc_log(nc_diff(nc_sqrt(nc_sum(nc_1,nc_prod(x,x))),x)));
	*/
}

static void 
nc_atan@c@(c@typ@ *x, c@typ@ *r)
{
	c@typ@ a, *pa=&a;
	nc_diff@c@(&nc_i@c@, x, pa);
	nc_sum@c@(&nc_i@c@, x, r);
	nc_quot@c@(r, pa, r);
	nc_log@c@(r,r);
	nc_prod@c@(&nc_i2@c@, r, r);
	return;
	/*
	  return nc_prod(nc_i2,nc_log(nc_quot(nc_sum(nc_i,x),nc_diff(nc_i,x))));
	*/
}

static void 
nc_atanh@c@(c@typ@ *x, c@typ@ *r)
{
	c@typ@ a, *pa=&a;
	nc_diff@c@(&nc_1@c@, x, r);
	nc_sum@c@(&nc_1@c@, x, pa);
	nc_quot@c@(pa, r, r);
	nc_log@c@(r, r);
	nc_prod@c@(&nc_half@c@, r, r);
	return;
	/*
	  return nc_prod(nc_half,nc_log(nc_quot(nc_sum(nc_1,x),nc_diff(nc_1,x))));
	*/
}

static void
nc_cos@c@(c@typ@ *x, c@typ@ *r)
{
	@typ@ xr=x->real, xi=x->imag;
	r->real = cos@c@(xr)*cosh@c@(xi);
	r->imag = -sin@c@(xr)*sinh@c@(xi);
	return;
}

static void 
nc_cosh@c@(c@typ@ *x, c@typ@ *r)
{
	@typ@ xr=x->real, xi=x->imag;
	r->real = cos(xi)*cosh(xr);
	r->imag = sin(xi)*sinh(xr);
	return;
}


#define M_LOG10_E 0.434294481903251827651128918916605082294397

static void 
nc_log10@c@(c@typ@ *x, c@typ@ *r)
{
	nc_log@c@(x, r);
	r->real *= M_LOG10_E;
	r->imag *= M_LOG10_E;
	return;
}

static void 
nc_sin@c@(c@typ@ *x, c@typ@ *r)
{
	@typ@ xr=x->real, xi=x->imag;
	r->real = sin@c@(xr)*cosh@c@(xi);
	r->imag = cos@c@(xr)*sinh@c@(xi);
	return;
}

static void
nc_sinh@c@(c@typ@ *x, c@typ@ *r)
{
	@typ@ xr=x->real, xi=x->imag;    
	r->real = cos@c@(xi)*sinh@c@(xr);
	r->imag = sin@c@(xi)*cosh@c@(xr);
	return;
}

static void 
nc_tan@c@(c@typ@ *x, c@typ@ *r)
{
	@typ@ sr,cr,shi,chi;
	@typ@ rs,is,rc,ic;
	@typ@ d;
	@typ@ xr=x->real, xi=x->imag;
	sr = sin@c@(xr);
	cr = cos@c@(xr);
	shi = sinh(xi);
	chi = cosh(xi);
	rs = sr*chi;
	is = cr*shi;
	rc = cr*chi;
	ic = -sr*shi;
	d = rc*rc + ic*ic;
	r->real = (rs*rc+is*ic)/d;
	r->imag = (is*rc-rs*ic)/d;
	return;
}

static void 
nc_tanh@c@(c@typ@ *x, c@typ@ *r)
{
	@typ@ si,ci,shr,chr;
	@typ@ rs,is,rc,ic;
	@typ@ d;
	@typ@ xr=x->real, xi=x->imag;
	si = sin@c@(xi);
	ci = cos@c@(xi);
	shr = sinh@c@(xr);
	chr = cosh@c@(xr);
	rs = ci*shr;
	is = si*chr;
	rc = ci*chr;
	ic = si*shr;
	d = rc*rc + ic*ic;
	r->real = (rs*rc+is*ic)/d;
	r->imag = (is*rc-rs*ic)/d;
	return;
}

/**end repeat**/


/**begin repeat

#TYPE=(BOOL, BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE)*2#
#OP=||, +*13, ^, -*13#
#kind=add*14, subtract*14#
#typ=(bool, byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble)*2#
*/

static void 
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((@typ@ *)op)=*((@typ@ *)i1) @OP@ *((@typ@ *)i2);
	}
}

/**end repeat**/

/**begin repeat

#TYPE=(CFLOAT, CDOUBLE, CLONGDOUBLE)*2#
#OP=+*3,-*3#
#kind=add*3,subtract*3#
#typ=(float, double, longdouble)*2#

*/

static void 
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		((@typ@ *)op)[0]=((@typ@ *)i1)[0] @OP@ ((@typ@ *)i2)[0]; 
		((@typ@ *)op)[1]=((@typ@ *)i1)[1] @OP@ ((@typ@ *)i2)[1];
	}
}

/**end repeat**/


/** Routines borrowed from numarray **/

/* The following routine is used in the event of a detected integer *
** divide by zero so that a floating divide by zero is generated.   *
** This is done since Numeric uses the floating point exception    *
** sticky bits to detect errors. The last bit is an attempt to      *
** prevent optimization of the divide by zero away, the output value *
** should always be 0                                               *
*/

static int numeric_zero = 0.0;

static int int_dividebyzero_error(void) {
	double dummy;
	dummy = 1./numeric_zero;
	if (dummy) /* to prevent optimizer from eliminating expression */
		return 0;
	else
		return 1;
}

/* Likewise for Integer overflows */
static int int_overflow_error(double value) {
	double dummy;
	dummy = pow(1.e10, fabs(value/2));
	if (dummy) /* to prevent optimizer from eliminating expression */
		return (int) value;
	else
		return 1;
}


static int ulonglong_overflow(ulonglong a, ulonglong b)
{
        ulonglong ah, al, bh, bl, w, x, y, z;

#if SIZEOF_LONGLONG == 64
	ah = (a >> 32);
	al = (a & 0xFFFFFFFFL);
	bh = (b >> 32);
	bl = (b & 0xFFFFFFFFL);
#elif SIZEOF_LONGLONG == 128
	ah = (a >> 64);
	al = (a & 0xFFFFFFFFFFFFFFFFL);
	bh = (b >> 64);
	bl = (b & 0xFFFFFFFFFFFFFFFFL);
#else
	ah = al = bh = bl = 0;
#endif

        /* 128-bit product:  z*2**64 + (x+y)*2**32 + w  */
	w = al*bl;
	x = bh*al;
	y = ah*bl;
	z = ah*bh;

	/* *c = ((x + y)<<32) + w; */
#if SIZEOF_LONGLONG == 64
	return z || (x>>32) || (y>>32) ||
		(((x & 0xFFFFFFFFL) + (y & 0xFFFFFFFFL) + (w >> 32)) >> 32);
#elif SIZEOF_LONGLONG == 128
	return z || (x>>64) || (y>>64) ||
		(((x & 0xFFFFFFFFFFFFFFFFL) + (y & 0xFFFFFFFFFFFFFFFFL) + (w >> 64)) >> 64);
#else
	return 0;
#endif
	
}

static int slonglong_overflow(longlong a0, longlong b0)
{
	ulonglong a, b;
        ulonglong ah, al, bh, bl, w, x, y, z;

        /* Convert to non-negative quantities */
	if (a0 < 0) { a = -a0; } else { a = a0; }
	if (b0 < 0) { b = -b0; } else { b = b0; }


#if SIZEOF_LONGLONG == 64
	ah = (a >> 32);
	al = (a & 0xFFFFFFFFL);
	bh = (b >> 32);
	bl = (b & 0xFFFFFFFFL);
#elif SIZEOF_LONGLONG == 128
	ah = (a >> 64);
	al = (a & 0xFFFFFFFFFFFFFFFFL);
	bh = (b >> 64);
	bl = (b & 0xFFFFFFFFFFFFFFFFL);
#else 
	ah = al = bh = bl = 0;
#endif

	w = al*bl;
	x = bh*al;
	y = ah*bl;
	z = ah*bh;

        /* 
	   ulonglong c = ((x + y)<<32) + w;
	   if ((a0 < 0) ^ (b0 < 0))
	   *c = -c;
	   else 
	   *c = c
	   */

#if SIZEOF_LONGLONG == 64
	return z || (x>>31) || (y>>31) ||
		(((x & 0xFFFFFFFFL) + (y & 0xFFFFFFFFL) + (w >> 32)) >> 31);
#elif SIZEOF_LONGLONG == 128
	return z || (x>>63) || (y>>63) ||
		(((x & 0xFFFFFFFFFFFFFFFFL) + (y & 0xFFFFFFFFFFFFFFFFL) + (w >> 64)) >> 63);
#else
	return 0;
#endif
}

/** end direct numarray code **/

static void
BOOL_multiply(char **args, intp *dimensions, intp *steps, void *func) {
	register intp i;
	intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((bool *)op) = *((bool *)i1) && *((bool *)i2);
	}  
}

/**begin repeat

#TYP= UBYTE,USHORT,UINT, ULONG#
#typ= ubyte, ushort, uint, ulong#
#bigtyp= int, int, double, double#
*/

static void 
@TYP@_multiply(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	@bigtyp@ temp;
	for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		temp = (@bigtyp@)(*((@typ@ *)i1)) * (@bigtyp@)(*((@typ@ *)i2));
		if (temp > MAX_@TYP@) 
			temp = (@bigtyp@)int_overflow_error(MAX_@TYP@);
		*((@typ@ *)op) = temp;
	}  
}

/**end repeat**/

static void 
ULONGLONG_multiply(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	ulonglong temp;
	for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		temp = *((ulonglong *)i1) * *((ulonglong *)i2);
		if (ulonglong_overflow(*((ulonglong *)i1), *((ulonglong *)i2)))
			temp = (ulonglong )int_overflow_error(MAX_ULONGLONG);
		*((ulonglong *)op) = temp;
	}  
}

/**begin repeat

#TYP= BYTE,SHORT,INT, LONG#
#typ= byte, short, int, long#
#bigtyp= int, int, double, double#
*/

static void 
@TYP@_multiply(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	@bigtyp@ temp;
	for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		temp = (@bigtyp@)*((@typ@ *)i1) * (@bigtyp@)*((@typ@ *)i2);
		if (temp > MAX_@TYP@) 
			temp = (@bigtyp@)int_overflow_error(MAX_@TYP@);
		if (temp < MIN_@TYP@) 
			temp = (@bigtyp@)int_overflow_error(MIN_@TYP@);
		*((@typ@ *)op) = temp;
	}  
}

/**end repeat**/

static void 
LONGLONG_multiply(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	longlong temp;
	for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		temp = *((longlong *)i1) * *((longlong *)i2);
		if (slonglong_overflow(*((longlong *)i1), *((longlong *)i2)))
			temp = (longlong )int_overflow_error(MAX_LONGLONG);
		*((longlong *)op) = temp;
	}  
}


/**begin repeat

#TYP=FLOAT,DOUBLE,LONGDOUBLE#
#typ=float,double,longdouble#
*/
static void 
@TYP@_multiply(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((@typ@ *)op)=*((@typ@ *)i1) * *((@typ@ *)i2);
	}    
}
/**end repeat**/


/**begin repeat

#TYP=BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG#
#typ=char, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong#
#otyp=float*4, double*6#
*/
static void
@TYP@_divide(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((@typ@ *)op)= ((*((@typ@ *)i2)==0) ? \
				 int_dividebyzero_error() : \
				 *((@typ@ *)i1) / *((@typ@ *)i2));
	}
}
static void
@TYP@_true_divide(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((@otyp@ *)op)= ((*((@typ@ *)i2)==0) ?	    \
				  int_dividebyzero_error() :  \
				  *((@typ@ *)i1) / (double )*((@typ@ *)i2));
	}
}
#define @TYP@_floor_divide @TYP@_divide
/**end repeat**/

/**begin repeat

#TYP=(FLOAT,DOUBLE,LONGDOUBLE)*2#
#typ=(float,double,longdouble)*2#
#kind=divide*3, true_divide*3#
*/
static void 
@TYP@_@kind@(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((@typ@ *)op)=*((@typ@ *)i1) / *((@typ@ *)i2);
	}
}
/**end repeat**/

/**begin repeat

#TYP=FLOAT,DOUBLE,LONGDOUBLE#
#typ=float,double,longdouble#
#c=f,,l#
*/
static void 
@TYP@_floor_divide(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((@typ@ *)op)=floor@c@(*((@typ@ *)i1) / *((@typ@ *)i2));
	}
}
/**end repeat**/


/**begin repeat

#TYP=BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG#
#typ=char, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong#
#btyp=float*4, double*6#
*/
static void 
@TYP@_power(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i, is1=steps[0],is2=steps[1];
	register intp os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	@btyp@ x, y, v;
    @typ@ z;
    
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		x = *((@typ@ *)i1);
		y = *((@typ@ *)i2);
		z = (@typ@) y;
		if ((x < 0.0) && (y != z))  v = 1.0/numeric_zero;
		else v = pow(x,y);
		*((@typ@ *)op) = (@typ@) v;
	}
}
/**end repeat**/

/**begin repeat

#TYP=UBYTE, BYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE#
#typ=ubyte, char, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble#
*/
static void 
@TYP@_conjugate(char **args, intp *dimensions, intp *steps, void *func)  
{
	register intp i, is1=steps[0], os=steps[1], n=dimensions[0]; 
	char *i1=args[0], *op=args[1]; 
	for(i=0; i<n; i++, i1+=is1, op+=os) {
		*((@typ@ *)op)=*((@typ@ *)i1);
	}
}
/**end repeat**/

/**begin repeat

#TYP=CFLOAT, CDOUBLE, CLONGDOUBLE#
#typ=float, double, longdouble#
*/
static void 
@TYP@_conjugate(char **args, intp *dimensions, intp *steps, void *func) {
	register intp i, is1=steps[0], os=steps[1], n=dimensions[0];
	char *i1=args[0], *op=args[1]; 

	for(i=0; i<n; i++, i1+=is1, op+=os) {
		((@typ@ *)op)[0]=((@typ@ *)i1)[0]; 
		((@typ@ *)op)[1]=-(((@typ@ *)i1)[1]);
	}
}
/**end repeat**/


/**begin repeat

#TYPE=BOOL,UBYTE,USHORT,UINT,ULONG,ULONGLONG#
#typ=bool, ubyte, ushort, uint, ulong, ulonglong#
*/
static void 
@TYPE@_absolute(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i, n;
	intp is1=steps[0], os=steps[1];
	char *i1=args[0], *op=args[1];

    n=dimensions[0];

	for(i=0; i<n; i++, i1+=is1, op+=os) {
		*((@typ@ *)op) = *((@typ@*)i1);
	}
}
/**end repeat**/

/**begin repeat

#TYPE=BYTE,SHORT,INT,LONG,LONGLONG,FLOAT,DOUBLE,LONGDOUBLE#
#typ=byte, short, int, long, longlong, float, double, longdouble#
*/
static void 
@TYPE@_absolute(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i, n;
	intp is1=steps[0], os=steps[1];
	char *i1=args[0], *op=args[1];

    n=dimensions[0]; 

	for(i=0; i<n; i++, i1+=is1, op+=os) {
		*((@typ@ *)op) = *((@typ@ *)i1) < 0 ? -*((@typ@ *)i1) : *((@typ@ *)i1);
	}
}
/**end repeat**/

/**begin repeat
   #TYPE=CFLOAT,CDOUBLE,CLONGDOUBLE#
   #typ= float, double, longdouble#
   #c= f,,l#
*/
static void 
@TYPE@_absolute(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i, n;
	register intp is1=steps[0], os=steps[1]; 
	char *i1=args[0], *op=args[1]; 
	n=dimensions[0];
	for(i=0; i<n; i++, i1+=is1, op+=os) {
		*((@typ@ *)op) = (@typ@)sqrt@c@(((@typ@ *)i1)[0]*((@typ@ *)i1)[0] + ((@typ@ *)i1)[1]*((@typ@ *)i1)[1]);
	}
}
/**end repeat**/

/**begin repeat 

#TYPE=(BOOL,BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE,CFLOAT,CDOUBLE,CLONGDOUBLE)*4#
#OP= >*17, >=*17, <*17, <=*17#
#typ=(bool, byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble, float, double, longdouble)*4#
#kind= greater*17, greater_equal*17, less*17, less_equal*17#
*/

static void 
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((bool *)op)=*((@typ@ *)i1) @OP@ *((@typ@ *)i2);
	}
}
/**end repeat**/


/**begin repeat

#TYPE=(BOOL,BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE)*4#
#typ=(bool, byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble)*4#
#OP= ==*14, !=*14, &&*14, ||*14#
#kind=equal*14, not_equal*14, logical_and*14, logical_or*14#
*/
static void 
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((bool *)op) = *((@typ@ *)i1) @OP@ *((@typ@ *)i2);
	}
}
/**end repeat**/


/**begin repeat

#TYPE=(CFLOAT, CDOUBLE, CLONGDOUBLE)*2#
#typ=(float, double, longdouble)*2#
#OP= ==*3, !=*3#
#OP2= &&*3, ||*3#
#kind=equal*3, not_equal*3#
*/
static void 
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((bool *)op) = (*((@typ@ *)i1) @OP@ *((@typ@ *)i2)) @OP2@ (*((@typ@ *)i1+1) @OP@ *((@typ@ *)i2+1));
	}
}
/**end repeat**/


/** OBJECT comparison for OBJECT arrays **/

/**begin repeat

#kind=greater, greater_equal, less, less_equal, equal, not_equal#
#op=GT, GE, LT, LE, EQ, NE#
*/
static void
OBJECT_@kind@(char **args, intp *dimensions, intp *steps, void *func) {
	register intp i, is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((bool *)op)=PyObject_RichCompareBool(*((PyObject **)i1),
						       *((PyObject **)i2), 
						       Py_@op@);
	}
}
/**end repeat**/

/**begin repeat

#TYPE=BOOL,BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE#
#typ=bool, byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble#
*/
static void 
@TYPE@_negative(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],os=steps[1], n=dimensions[0];
	char *i1=args[0], *op=args[1];
	for(i=0; i<n; i++, i1+=is1, op+=os) {
		*((@typ@ *)op) = - *((@typ@ *)i1);
	}
}
/**end repeat**/


/**begin repeat

#TYPE=BOOL,BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE#
#typ=bool, byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble#
*/
static void 
@TYPE@_logical_not(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],os=steps[1], n=dimensions[0];
	char *i1=args[0], *op=args[1];
	for(i=0; i<n; i++, i1+=is1, op+=os) {
		*((bool *)op) = ! *((@typ@ *)i1);
	}
}
/**end repeat**/



/**begin repeat

#TYPE=(BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG)*6#
#typ=(byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong)*6#
#OP= %*10, &*10, |*10, ^*10, <<*10, >>*10#
#kind=remainder*10, bitwise_and*10, bitwise_or*10, bitwise_xor*10, left_shift*10, right_shift*10#

*/
static void 
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((@typ@ *)op)=*((@typ@ *)i1) @OP@ *((@typ@ *)i2);
	} 
}
/**end repeat**/

/**begin repeat

#TYPE=BOOL*3#
#typ=bool*3#
#OP= &, |, ^#
#kind=and, or, xor#

*/
static void 
@TYPE@_bitwise_@kind@(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((@typ@ *)op)=*((@typ@ *)i1) @OP@ *((@typ@ *)i2);
	} 
}
/**end repeat**/


/**begin repeat
   #TYPE=BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG#
   #typ=byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong#
*/
static void 
@TYPE@_invert(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0], os=steps[1], n=dimensions[0];
	char *i1=args[0], *op=args[1]; 
	for(i=0; i<n; i++, i1+=is1, op+=os) {
		*((@typ@ *)op) = ~ *((@typ@*)i1);
	}
}
/**end repeat**/

static void
BOOL_invert(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0], os=steps[1], n=dimensions[0];
	char *i1=args[0], *op=args[1]; 
	for(i=0; i<n; i++, i1+=is1, op+=os) {
		*((bool *)op) = (*((bool *)i1) ? false : true);
	}
}


/**begin repeat

#TYPE=BOOL,BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE#
#typ=bool, byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble#

*/
static void 
@TYPE@_logical_xor(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((bool *)op)=(*((@typ@ *)i1) || *((@typ@ *)i2)) && !(*((@typ@ *)i1) && *((@typ@ *)i2));
	}
}
/**end repeat**/

/**begin repeat 

#TYPE=(BOOL,BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE,CFLOAT,CDOUBLE,CLONGDOUBLE)*2#
#OP= >*17, <*17#
#typ=(bool, byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble, float, double, longdouble)*2#
#kind= maximum*17, minimum*17#
*/
static void 
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func) 
{
	register intp i;
	intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
	char *i1=args[0], *i2=args[1], *op=args[2];
	for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
		*((@typ@ *)op)=*((@typ@ *)i1) @OP@ *((@typ@ *)i2) ? *((@typ@ *)i1) : *((@typ@ *)i2);
	}
}
/**end repeat**/


/*** isinf, isinf, isfinite, signbit ***/
/**begin repeat
#kind=isnan*3, isinf*3, isfinite*3, signbit*3#
#TYPE=(FLOAT, DOUBLE, LONGDOUBLE)*4#
#typ=(float, double, longdouble)*4#
#c=(f,,l)*4#
*/
static void
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
        register intp i;
        intp is=steps[0], os=steps[1], n=dimensions[0];
        char *ip=args[0], *op=args[1];
        for(i=0; i<n; i++, ip+=is, op+=os) {
                *((bool *)op) = @kind@@c@(*((@typ@ *)ip));
        }
}
/**end repeat**/


/**begin repeat
#kind=isnan*3, isinf*3, isfinite*3#
#TYPE=(CFLOAT, CDOUBLE, CLONGDOUBLE)*3#
#typ=(float, double, longdouble)*3#
#c=(f,,l)*3#
#OP=||*6,&&*3#
*/
static void
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
        register intp i;
        intp is=steps[0], os=steps[1], n=dimensions[0];
        char *ip=args[0], *op=args[1];
        for(i=0; i<n; i++, ip+=is, op+=os) {
                *((bool *)op) = @kind@@c@(((@typ@ *)ip)[0]) @OP@        \
                        @kind@@c@(((@typ@ *)ip)[1]);
        }
}
/**end repeat**/




/****** modf ****/

/**begin repeat
#TYPE=FLOAT, DOUBLE, LONGDOUBLE#
#typ=float, double, longdouble#
#c=f,,l#
*/
static void
@TYPE@_modf(char **args, intp *dimensions, intp *steps, void *func)
{
        register intp i;
        intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
        char *i1=args[0], *op1=args[1], *op2=args[2];
        @typ@ x1, y1, y2;
        for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
                x1 = *((@typ@ *)i1);
                y1 = modf@c@(x1, &y2);
                *((@typ@ *)op1) = y1;
                *((@typ@ *)op2) = y2;
        }
}
/**end repeat**/

#define HAVE_DOUBLE_FUNCS
/**begin repeat
#TYPE=FLOAT, DOUBLE, LONGDOUBLE#
#typ=float, double, longdouble#
#c=f,,l#
*/
#ifdef HAVE_@TYPE@_FUNCS
static void
@TYPE@_frexp(char **args, intp *dimensions, intp *steps, void *func)
{
        register intp i;
        intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
        char *i1=args[0], *op1=args[1], *op2=args[2];
        @typ@ x1, y1;
        int y2;
        for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
                x1 = *((@typ@ *)i1);
                y1 = frexp@c@(x1, &y2);
                *((@typ@ *)op1) = y1;
                *((int *) op2) = y2;
        }
}

static void
@TYPE@_ldexp(char **args, intp *dimensions, intp *steps, void *func)
{
        register intp i;
        intp is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
        char *i1=args[0], *i2=args[1], *op=args[2];
        @typ@ x1, y1;
        int x2;
        for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
                x1 = *((@typ@ *)i1);
                x2 = *((int *)i2);
                y1 = ldexp@c@(x1, x2);
                *((@typ@ *)op) = y1;
        }
}
#endif
/**end repeat**/
#undef HAVE_DOUBLE_FUNCS


static PyUFuncGenericFunction frexp_functions[] = { 
#ifdef HAVE_FLOAT_FUNCS
        FLOAT_frexp,
#endif
        DOUBLE_frexp
#ifdef HAVE_LONGDOUBLE_FUNCS
        ,LONGDOUBLE_frexp
#endif
};

static void * blank3_data[] = { (void *)NULL, (void *)NULL, (void *)NULL};
static char frexp_signatures[] = { 
#ifdef HAVE_FLOAT_FUNCS
        PyArray_FLOAT, PyArray_FLOAT, PyArray_INT,
#endif
        PyArray_DOUBLE, PyArray_DOUBLE, PyArray_INT
#ifdef HAVE_LONGDOUBLE_FUNCS
        ,PyArray_LONGDOUBLE, PyArray_LONGDOUBLE, PyArray_INT
#endif
};


static PyUFuncGenericFunction ldexp_functions[] = { 
#ifdef HAVE_FLOAT_FUNCS
        FLOAT_ldexp,
#endif
        DOUBLE_ldexp
#ifdef HAVE_LONGDOUBLE_FUNCS
        ,LONGDOUBLE_ldexp
#endif
};

static char ldexp_signatures[] = { 
#ifdef HAVE_FLOAT_FUNCS
        PyArray_FLOAT, PyArray_INT, PyArray_FLOAT,
#endif
        PyArray_DOUBLE, PyArray_INT, PyArray_DOUBLE
#ifdef HAVE_LONGDOUBLE_FUNCS
        ,PyArray_LONGDOUBLE, PyArray_INT, PyArray_LONGDOUBLE
#endif
};



#include "__umath_generated.c"


#include "ufuncobject.c"

#include "__ufunc_api.c"

static double
pinf_init(void)
{
    double mul = 1e10;
    double tmp = 0.0;
    double pinf;

    pinf = mul;
    for (;;) {
        pinf *= mul;
        if (pinf == tmp) break;
        tmp = pinf;
    }
    return pinf;
}

static double
pzero_init(void)
{
    double div = 1e10;
    double tmp = 0.0;
    double pinf;

    pinf = div;
    for (;;) {
        pinf /= div;
        if (pinf == tmp) break;
        tmp = pinf;
    }
    return pinf;
}

/* Less automated additions to the ufuncs */

static void
InitOtherOperators(PyObject *dictionary) {
        PyObject *f;
        int num=1;
     
#ifdef HAVE_LONGDOUBLE_FUNCS
        num += 1;
#endif
#ifdef HAVE_FLOAT_FUNCS
        num += 1;
#endif
        f = PyUFunc_FromFuncAndData(frexp_functions, blank3_data, 
				    frexp_signatures, num,
                                    1, 2, PyUFunc_None, "frexp",
                                    "Split the number, x, into a normalized"\
				    " fraction (y1) and exponent (y2)",0);
        PyDict_SetItemString(dictionary, "frexp", f);
        Py_DECREF(f);

        f = PyUFunc_FromFuncAndData(ldexp_functions, blank3_data, ldexp_signatures, num,
                                    2, 1, PyUFunc_None, "ldexp",
                                    "Compute y = x1 * 2**x2.",0);
        PyDict_SetItemString(dictionary, "ldexp", f);
        Py_DECREF(f);
        return;
}


static struct PyMethodDef methods[] = {
        {"frompyfunc", (PyCFunction) ufunc_frompyfunc,
         METH_VARARGS | METH_KEYWORDS, doc_frompyfunc},
	{NULL,		NULL, 0}		/* sentinel */
};

DL_EXPORT(void) initumath(void) {
	PyObject *m, *d, *s, *c_api;
	double pinf, pzero, mynan;
  
	/* Create the module and add the functions */
	m = Py_InitModule("umath", methods); 

	/* Import the array */
	if (import_array() < 0) return;

	/* Initialize the types */
	if (PyType_Ready(&PyUFunc_Type) < 0)
                return;         

	if (PyType_Ready(&PyUFuncLoop_Type) < 0)
		return; 
        
	if (PyType_Ready(&PyUFuncReduce_Type) < 0)
                return; 


	/* Add some symbolic constants to the module */
	d = PyModule_GetDict(m);

	c_api = PyCObject_FromVoidPtr((void *)PyUFunc_API, NULL);
	if (PyErr_Occurred()) goto err;
	PyDict_SetItemString(d, "_UFUNC_API", c_api);
	Py_DECREF(c_api);
	if (PyErr_Occurred()) goto err;

	s = PyString_FromString("0.4.0");
	PyDict_SetItemString(d, "__version__", s);
	Py_DECREF(s);

	/* Load the ufunc operators into the array module's namespace */
	InitOperators(d); 

        InitOtherOperators(d);

	PyDict_SetItemString(d, "pi", s = PyFloat_FromDouble(M_PI));
	Py_DECREF(s);
	PyDict_SetItemString(d, "e", s = PyFloat_FromDouble(exp(1.0)));
	Py_DECREF(s);
        PyDict_SetItemString(d, "ERR_IGNORE", 
			     s=PyInt_FromLong(UFUNC_ERR_IGNORE));
        Py_DECREF(s);
        PyDict_SetItemString(d, "ERR_WARN", s=PyInt_FromLong(UFUNC_ERR_WARN));
        Py_DECREF(s);
        PyDict_SetItemString(d, "ERR_RAISE", 
			     s=PyInt_FromLong(UFUNC_ERR_RAISE));
        Py_DECREF(s);
        PyDict_SetItemString(d, "ERR_CALL", s=PyInt_FromLong(UFUNC_ERR_CALL));
        Py_DECREF(s);

        PyDict_SetItemString(d, "ERR_DEFAULT", 
			     s=PyInt_FromLong(UFUNC_DEFAULT_ERROR));
        Py_DECREF(s);

        PyDict_SetItemString(d, "SHIFT_DIVIDEBYZERO", 
			     s=PyInt_FromLong(UFUNC_SHIFT_DIVIDEBYZERO));
        Py_DECREF(s);
        PyDict_SetItemString(d, "SHIFT_OVERFLOW", 
			     s=PyInt_FromLong(UFUNC_SHIFT_OVERFLOW));
        Py_DECREF(s);
        PyDict_SetItemString(d, "SHIFT_UNDERFLOW", 
			     s=PyInt_FromLong(UFUNC_SHIFT_UNDERFLOW));
        Py_DECREF(s);
        PyDict_SetItemString(d, "SHIFT_INVALID", 
			     s=PyInt_FromLong(UFUNC_SHIFT_INVALID));
        Py_DECREF(s);

        PyDict_SetItemString(d, "UFUNC_ERRMASK_NAME", 
                             s=PyString_FromString(UFUNC_ERRMASK_NAME));
        Py_DECREF(s);
        PyDict_SetItemString(d, "UFUNC_ERRFUNC_NAME", 
                             s=PyString_FromString(UFUNC_ERRFUNC_NAME));
        Py_DECREF(s);
        PyDict_SetItemString(d, "UFUNC_BUFSIZE_NAME", 
                             s=PyString_FromString(UFUNC_BUFSIZE_NAME));
        Py_DECREF(s);
        PyDict_SetItemString(d, "UFUNC_BUFSIZE_DEFAULT", 
			     s=PyInt_FromLong(PyArray_BUFSIZE));
        Py_DECREF(s);


        pinf = pinf_init();
        PyDict_SetItemString(d, "PINF", s = PyFloat_FromDouble(pinf));
        Py_DECREF(s);
        PyDict_SetItemString(d, "NINF", s = PyFloat_FromDouble(-pinf));
        Py_DECREF(s);
        pzero = pzero_init();
        PyDict_SetItemString(d, "PZERO", s = PyFloat_FromDouble(pzero));
        Py_DECREF(s);
        PyDict_SetItemString(d, "NZERO", s = PyFloat_FromDouble(-pzero));
        Py_DECREF(s);
        mynan = pinf / pinf;
        PyDict_SetItemString(d, "NAN", s = PyFloat_FromDouble(mynan));
        Py_DECREF(s);


	s = PyDict_GetItemString(d, "conjugate");
	/* Setup the array object's numerical structures with appropriate 
	   ufuncs in d*/
	PyArray_SetNumericOps(d);

	PyDict_SetItemString(d, "conj", s);

 err:  
	/* Check for errors */
	if (PyErr_Occurred())
		Py_FatalError("can't initialize module umath");
}
