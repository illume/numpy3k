/* -*- c -*- */

/* The purpose of this module is to add faster math for array scalars
   that does not go through the ufunc machinery  

   but still supports error-modes. 

   NOT FINISHED
*/

#include "Python.h"
#include "numpy/arrayobject.h"
#include "numpy/arrayscalars.h"
#include "numpy/ufuncobject.h"



/** numarray adapted routines.... **/

static int ulonglong_overflow(ulonglong a, ulonglong b)
{
    ulonglong ah, al, bh, bl, w, x, y, z;

#if SIZEOF_LONGLONG == 64
    ah = (a >> 32);
    al = (a & 0xFFFFFFFFL);
    bh = (b >> 32);
    bl = (b & 0xFFFFFFFFL);
#elif SIZEOF_LONGLONG == 128
    ah = (a >> 64);
    al = (a & 0xFFFFFFFFFFFFFFFFL);
    bh = (b >> 64);
    bl = (b & 0xFFFFFFFFFFFFFFFFL);
#else
    ah = al = bh = bl = 0;
#endif

    /* 128-bit product:  z*2**64 + (x+y)*2**32 + w  */
    w = al*bl;
    x = bh*al;
    y = ah*bl;
    z = ah*bh;

    /* *c = ((x + y)<<32) + w; */
#if SIZEOF_LONGLONG == 64
    return z || (x>>32) || (y>>32) ||
	(((x & 0xFFFFFFFFL) + (y & 0xFFFFFFFFL) + (w >> 32)) >> 32);
#elif SIZEOF_LONGLONG == 128
    return z || (x>>64) || (y>>64) ||
	(((x & 0xFFFFFFFFFFFFFFFFL) + (y & 0xFFFFFFFFFFFFFFFFL) + (w >> 64)) >> 64);
#else
    return 0;
#endif

}

static int slonglong_overflow(longlong a0, longlong b0)
{
    ulonglong a, b;
    ulonglong ah, al, bh, bl, w, x, y, z;

    /* Convert to non-negative quantities */
    if (a0 < 0) { a = -a0; } else { a = a0; }
    if (b0 < 0) { b = -b0; } else { b = b0; }


#if SIZEOF_LONGLONG == 64
    ah = (a >> 32);
    al = (a & 0xFFFFFFFFL);
    bh = (b >> 32);
    bl = (b & 0xFFFFFFFFL);
#elif SIZEOF_LONGLONG == 128
    ah = (a >> 64);
    al = (a & 0xFFFFFFFFFFFFFFFFL);
    bh = (b >> 64);
    bl = (b & 0xFFFFFFFFFFFFFFFFL);
#else
    ah = al = bh = bl = 0;
#endif

    w = al*bl;
    x = bh*al;
    y = ah*bl;
    z = ah*bh;

    /*
      ulonglong c = ((x + y)<<32) + w;
      if ((a0 < 0) ^ (b0 < 0))
      *c = -c;
      else
      *c = c
      */

#if SIZEOF_LONGLONG == 64
    return z || (x>>31) || (y>>31) ||
	(((x & 0xFFFFFFFFL) + (y & 0xFFFFFFFFL) + (w >> 32)) >> 31);
#elif SIZEOF_LONGLONG == 128
    return z || (x>>63) || (y>>63) ||
	(((x & 0xFFFFFFFFFFFFFFFFL) + (y & 0xFFFFFFFFFFFFFFFFL) + (w >> 64)) >> 63);
#else
    return 0;
#endif
}
/** end direct numarray code **/


/* Basic operations:

BINARY:

add, subtract, multiply, divide, remainder, divmod, power, 
floor, divide, true_divide

lshift, rshift, and, or, xor (integers only)

UNARY:

negative, positive, absolute, nonzero, invert, int, long, float, oct, hex

*/

/**begin repeat
   #name=byte,short,int,long,longlong#
**/
static void
@name@_ctype_add(@name@ a, @name@ b, @name@ *out) {
    *out = a + b;
    if ((*out^a) >= 0 || (*out^b) >= 0)
	return;
    generate_overflow_error();
    return;
}
static void
@name@_ctype_subtract(@name@ a, @name@ b, @name@ *out) {
    *out = a - b;
    if ((*out^a) >= 0 || (*out^~b) >= 0)
	return;
    generate_overflow_error();
    return;
}
/**end repeat**/
/**begin repeat
   #name=ubyte,ushort,uint,ulong,ulonglong#
**/
static void
@name@_ctype_add(@name@ a, @name@ b, @name@ *out) {
    *out = a + b;
    if (*out >= a && *out >= b)
	return;
    generate_overflow_error();
    return;
}
static void
@name@_ctype_subtract(@name@ a, @name@ b, @name@ *out) {
    *out = a - b;
    if (a >= b) return;
    generate_overflow_error();
    return;
}
/**end repeat**/

/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong#
   #big=(int,uint)*2,(longlong,ulonglong)*2#
   #NAME=BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG#
   #SIZE=INT*4,LONGLONG*4#
   #neg=(1,0)*4#
 **/
#if SIZEOF_@SIZE@ > SIZEOF_@NAME@
static void
@name@_ctype_multiply(@name@ a, @name@ b, @name@ *out) {
        @big@ temp;
        temp = ((@big@) a) * ((@big@) b);
        *out = (@name@) temp;
#if @neg@
        if (temp > MAX_@NAME@ || temp < MIN_@NAME@)
#else
        if (temp > MAX_@NAME@) 
#endif
                generate_overflow_error();
        return;
}
#endif
/**end repeat**/

/**begin repeat
   #name=int,uint,long,ulong,longlong,ulonglong#
   #SIZE=INT*2,LONG*2,LONGLONG*2#
   #char=(s,u)*3#
 **/
#if SIZEOF_LONGLONG == SIZEOF_@SIZE@
static void
@name@_ctype_multiply(@name@ a, @name@ b, @name@ *out) {
        *out = a * b;
        if (@char@longlong_overflow(a, b))
                generate_overflow_error();
        return;
}
#endif
/**end repeat**/

/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong#
 **/
static void
@name@_ctype_divide(@name@ a, @name@ b, @name@ *out) {
	if (b == 0) {
		generate_divbyzero_error();
		*out = 0;
	}
	else {
		*out = a / b;
	}
}
#define @name@_ctype_floor_divide @name@_ctype_divide
/**end repeat**/


/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong#
   #otyp=float*4, double*6#
 **/
#define @name@_ctype_true_divide(a, b, out)	\
	*(out) = ((@otyp@) (a)) / ((@otyp@) (b));
/**end repeat**/

/**begin repeat
   #name=(byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong)*5#
   #oper=and*10, xor*10, or*10, lshift*10, rshift*10#
   #op=&*10, ^*10, |*10, <<*10, >>*10#
 **/
#define @name@_ctype_@oper@(arg1, arg2, out) *(out) = (arg1) @op@ (arg2)
/**end repeat**/

/**begin repeat
   #name=float, double, longdouble#
   #c=f,,l#
**/
#define @name@_ctype_add(a, b, outp) *(outp) = a + b
#define @name@_ctype_subtract(a, b, outp) *(outp) = a - b
#define @name@_ctype_multiply(a, b, outp) *(outp) = a * b
#define @name@_ctype_divide(a, b, outp) *(outp) = a / b
#define @name@_ctype_true_divide @name@_ctype_divide
#define @name@_ctype_floor_divide(a, b, outp) *(outp) = floor@c@((a) / (b))
/**end repeat**/

/**begin repeat
   #name=cfloat, cdouble, clongdouble#
   #rtype=float, double, longdouble#
   #c=f,,l#
**/
#define @name@_ctype_add(a, b, outp) do{		\
    (outp)->real = (a).real + (b).real;			\
    (outp)->imag = (a).imag + (b).imag;			\
    }while(0)
#define @name@_ctype_subtract(a, b, outp) do{		\
    (outp)->real = (a).real - (b).real;			\
    (outp)->imag = (a).imag - (b).imag;			\
    }while(0)
#define @name@_ctype_multiply(a, b, outp) do{			\
    (outp)->real = (a).real * (b).real - (a).imag * (b).imag;	\
    (outp)->imag = (a).real * (b).imag + (a).imag * (b).real;	\
    }while(0)
#define @name@_ctype_divide(a, b, outp) do{			\
    @rtype@ d = (a).real*(b).real + (b).imag*(b).imag;		\
    (outp)->real = ((a).real*(b).real + (a).imag*(b).imag)/d;	\
    (outp)->imag = ((a).imag*(b).real - (a).real*(b).imag)/d;	\
    }while(0)
#define @name@_ctype_true_divide @name@_ctype_divide
#define @name@_ctype_floor_divide(a, b, outp) do {               \
        @rtype@ d = (a).real*(b).real + (b).imag*(b).imag;       \
        (outp)->real = ((a).real*(b).real + (a).imag*(b).imag) / \
        ((a).real*(b).real + (b).imag*(b).imag);                 \
        (outp)->imag = 0;                                        \
        }while(0)
/**end repeat**/

/**begin repeat
   #name=float,double,longdouble#
   #c=f,,l#
**/
static void 
@name@_ctype_remainder(@name@ a, @name@ b, @name@ *out) { 
    *out = a - floor@c@(a/b)*b;
} 
/**end repeat**/ 

/**begin repeat
   #name= float, double, longdouble#
   #fun= powf, pow, powl#
**/
static void
@name@_ctype_power(@name@ a, @name@ b, @name@ *out) {
    *out = @fun@(a, b);
}
/**end repeat**/

/**begin repeat
   #name=byte, short, int, long, longlong, float, double, longdouble#
**/
static void
@name@_ctype_negative(@name@ a, @name@ *out)
{
    *out = -a;
}
/**end repeat**/

/**begin repeat
   #name= cfloat, cdouble, clongdouble#
**/
static void
@name@_ctype_negative(@name@ a, @name@ *out)
{
    out->real = -a.real;
    out->imag = -a.imag;
}
/**end repeat**/

/**begin repeat
   #name=byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble#
**/
static void
@name@_ctype_positive(@name@ a, @name@ *out)
{
    *out = a;
}
/**end repeat**/

#define NOP
/**begin repeat
   #name=byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble#
   #fun= abs,  NOP,   abs,   NOP,    abs, NOP,  labs, NOP,   llabs,    NOP,       fabsf, fabs,   fabsl#   
**/
static void
@name@_ctype_absolute(@name@ a, @name@ *out)
{
    *out = @fun@(a);
}
/**end repeat**/

/**begin repeat
   #name= cfloat, cdouble, clongdouble#
   #sqrt= sqrtf, sqrt, sqrtl#
**/
static void
@name@_ctype_absolute(@name@ a, @name@ *out)
{
    out->real = @sqrt@(a.real*a.real + a.imag*a.imag);
    out->imag = 0;
}
/**end repeat**/

/**begin repeat
   #name=byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong#
**/
#define @name@_ctype_invert(a, out) *(out) = ~a;
/**end repeat**/

/*** END OF BASIC CODE **/


/* The general strategy for commutative binary operators is to

1) Convert the types to the common type if both are scalars (0 return)
2) If both are not scalars use ufunc machinery (-2 return)
3) If both are scalars but cannot be cast to the right type 
return NotImplmented (-1 return)

4) Perform the function on the C-type.
5) If an error condition occurred, check to see
what the current error-handling is and handle the error.

6) Construct and return the output scalar.
*/
	       

/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,double,longdouble,cfloat,cdouble,clongdouble#
   #Name=Byte, UByte, Short, UShort, Int, UInt, Long, ULong, LongLong, ULongLong, Float, Double, LongDouble, CFloat, CDouble, CLongDouble#
   #NAME=BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, CFLOAT, CDOUBLE, CLONGDOUBLE#
**/ 

static int
_@name@_convert_to_ctype(PyObject *a, @name@ *arg1)
{
    PyObject *temp; 

    if (PyArray_IsScalar(a, @Name@)) {
	*arg1 = PyArrayScalar_VAL(a, @Name@);
	return 0;
    }
    else if (PyArray_IsScalar(a, Generic)) {
	PyArray_Descr *descr1;
	int ret;
	if (!PyArray_IsScalar(a, Number)) return -1;
	descr1 = PyArray_DescrFromTypeObject((PyObject *)(a->ob_type));
 	if (PyArray_CanCastSafely(descr1->type_num, PyArray_@NAME@)) {
	    PyArray_CastScalarDirect(a, descr1, arg1, PyArray_@NAME@);
	    ret = 0;
	}
	else ret = -1;
	Py_DECREF(descr1);
	return ret;
    }
    else if ((temp = PyArray_ScalarFromObject(a)) != NULL) {
	return _@name@_convert_to_ctype(temp, arg1);
    }
    return -2;
}	

static int
_@name@_convert2_to_ctypes(PyObject *a, @name@ *arg1, 
			   PyObject *b, @name@ *arg2)
{
    int ret;
    ret = _@name@_convert_to_ctype(a, arg1);
    if (ret < 0) return ret;
    ret = _@name@_convert_to_ctype(b, arg2);
    if (ret < 0) return ret;
    return 0;
}

/**end repeat**/

/**begin repeat
   #name=(byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong)*14, (float, double, longdouble, cfloat, cdouble, clongdouble)*9#
   #Name=(Byte, UByte, Short, UShort, Int, UInt, Long, ULong, LongLong, ULongLong)*14, (Float, Double, LongDouble, CFloat, CDouble, CLongDouble)*9#
   #oper=add*10, subtract*10, multiply*10, divide*10, remainder*10, divmod*10, power*10, floor_divide*10, lshift*10, rshift*10, true_divide*10, and*10, or*10, xor*10, add*6, subtract*6, multiply*6, divide*6, remainder*6, divmod*6, power*6, floor_divide*6, true_divide*6#
   #fperr=1*110,0*30,1*54#
   #power=0*60,1*10,0*106,1*6,0*12#
   #otyp=(byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong)*13, float*4, double*6, (float, double, longdouble, cfloat, cdouble, clongdouble)*9#
**/

#if @power@
static PyObject *
@name@_power(PyObject *a, PyObject *b, PyObject *c)
#else
static PyObject *
@name@_@oper@(PyObject *a, PyObject *b)
#endif
{
    PyObject *ret;
    @name@ arg1, arg2, out;
#if @fperr@
    int retstatus;
#endif    
	
    switch(_@name@_convert2_to_ctypes(a, &arg1, b, &arg2)) {
    case 0:
        break;
    case -1: /* can't cast both safely use different add function */
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case -2: /* use default handling */
	if (PyErr_Occurred()) return NULL;
#if @power@
        return PyGenericArrType_Type.tp_as_number->nb_power(a,b,NULL);
#else
        return PyGenericArrType_Type.tp_as_number->nb_@oper@(a,b);
#endif
    }

#if @fperr@
    PyUFunc_clearfperr();
#endif

    /* here we do the actual calculation with arg1 and arg2 */
    /* as a function call. */
    @name@_ctype_@oper@(arg1, arg2, &out);

#if @fperr@
    /* Check status flag.  If it is set, then look up what to do */
    retstatus = PyUFunc_getfperr();
    if (retstatus) {
	int bufsize, errmask;
	PyObject *errobj;
	if (PyUFunc_GetPyValues("@name@_scalars", &bufsize, &errmask, 
				&errobj) < 0) 
	    return NULL;
	if (PyUFunc_handlefperr(errmask, errobj, retstatus))
	    return NULL;
    }
#endif
    ret = PyArrayScalar_New(@Name@);
    PyArrayScalar_VAL(ret, @Name@) = out;
    return ret;
}
/**end repeat**/


/**begin repeat
   #name=(float,double,longdouble,cfloat,cdouble,clongdouble)*6#
   #oper=lshift*6, rshift*6, and*6, or*6, xor*6, index*6#
**/
#define @name@_@oper@ NULL
/**end repeat**/


/**begin repeat
   #name=(byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,double,longdouble,cfloat,cdouble,clongdouble)*4#
   #Name=(Byte, UByte, Short, UShort, Int, UInt, Long, ULong, LongLong, ULongLong, Float, Double, LongDouble, CFloat, CDouble, CLongDouble)*4#
   #oper=negative*16, positive*16, absolute*16, invert*16#
**/
static PyObject *
@name@_@oper@(PyObject *a)
{
    @name@ arg1, out;
    PyObject *ret;
	
    switch(_@name@_convert_to_ctype(a, &arg1)) {
    case 0:
        break;
    case -1: /* can't cast both safely use different add function */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
    case -2: /* use default handling */
	if (PyErr_Occurred()) return NULL;
        return PyGenericArrType_Type.tp_as_number->nb_@oper@(a);
    }

    /* here we do the actual calculation with arg1 and arg2 */
    /* make it a function call. */

    @name@_ctype_@oper@(arg1, &out);

    ret = PyArrayScalar_New(@Name@);
    PyArrayScalar_VAL(ret, @Name@) = out;

    return ret;
}
/**end repeat**/


/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,double,longdouble,cfloat,cdouble,clongdouble#
   #simp=1*13,0*3#
**/
static int
@name@_nonzero(PyObject *a)
{
    int ret;
    @name@ arg1;
	
    if (_@name@_convert_to_ctype(a, &arg1) < 0) {
	if (PyErr_Occurred()) return -1;
        return PyGenericArrType_Type.tp_as_number->nb_nonzero(a);
    }
    
    /* here we do the actual calculation with arg1 and arg2 */
    /* make it a function call. */

#if @simp@
    ret = (arg1 != 0);
#else 
    ret = ((arg1.real != 0) || (arg1.imag != 0));
#endif
    
    return ret;
}
/**end repeat**/


/**begin repeat
   #name=(byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,double,longdouble,cfloat,cdouble,clongdouble)*5#
   #oper=int*16, long*16, float*16, oct*16, hex*16#
**/
#define @name@_@oper@ NULL
/**end repeat**/


#if PY_VERSION_HEX >= 0x02050000
/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong#
   #Name=Byte, UByte, Short, UShort, Int, UInt, Long, ULong, LongLong, ULongLong#
**/
static Py_ssize_t
@name@_index(PyObject *a)
{
    return PyArrayScalar_VAL(a, @Name@);    
}
/**end repeat**/
#endif


/**begin repeat
   #oper=le,ge,lt,gt,eq,ne#
   #op=<=,>=,<,>,==,!=#
**/
#define def_cmp_@oper@(arg1, arg2) (arg1 @op@ arg2)
#define cmplx_cmp_@oper@(arg1, arg2) ((arg1.real == arg2.real) ?	\
				      arg1.imag @op@ arg2.imag :	\
				      arg1.real @op@ arg2.real)
/**end repeat**/

/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,double,longdouble,cfloat,cdouble,clongdouble#
   #simp=def*13,cmplx*3#
**/
static PyObject*
@name@_richcompare(PyObject *self, PyObject *other, int cmp_op)
{
    @name@ arg1, arg2;
    int out=0;
	
    switch(_@name@_convert2_to_ctypes(self, &arg1, other, &arg2)) {
    case 0:
	break;
    case -1: /* can't cast both safely use different add function */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
    case -2: /* use ufunc */
	if (PyErr_Occurred()) return NULL;
	return PyGenericArrType_Type.tp_richcompare(self, other, cmp_op);
    }

    /* here we do the actual calculation with arg1 and arg2 */
    switch (cmp_op) {
    case Py_EQ:
	out = @simp@_cmp_eq(arg1, arg2);
	break;
    case Py_NE:
	out = @simp@_cmp_ne(arg1, arg2);
	break;
    case Py_LE:
	out = @simp@_cmp_le(arg1, arg2);
	break;
    case Py_GE:
	out = @simp@_cmp_ge(arg1, arg2);
	break;
    case Py_LT:
	out = @simp@_cmp_lt(arg1, arg2);
	break;
    case Py_GT:
	out = @simp@_cmp_gt(arg1, arg2);
	break;
    }
    
    if (out) 
	PyArrayScalar_RETURN_TRUE;
    else
	PyArrayScalar_RETURN_FALSE;
}
/**end repeat**/


/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,double,longdouble,cfloat,cdouble,clongdouble#
**/
static PyNumberMethods @name@_as_number = {
    (binaryfunc)@name@_add,                    /*nb_add*/
    (binaryfunc)@name@_subtract,               /*nb_subtract*/
    (binaryfunc)@name@_multiply,               /*nb_multiply*/
    (binaryfunc)@name@_divide,                 /*nb_divide*/
    (binaryfunc)@name@_remainder,              /*nb_remainder*/
    (binaryfunc)@name@_divmod,                 /*nb_divmod*/
    (ternaryfunc)@name@_power,                 /*nb_power*/
    (unaryfunc)@name@_negative,
    (unaryfunc)@name@_positive,                /*nb_pos*/
    (unaryfunc)@name@_absolute,                /*nb_abs*/
    (inquiry)@name@_nonzero,                   /*nb_nonzero*/
    (unaryfunc)@name@_invert,                  /*nb_invert*/
    (binaryfunc)@name@_lshift,                /*nb_lshift*/
    (binaryfunc)@name@_rshift,                /*nb_rshift*/
    (binaryfunc)@name@_and,                  /*nb_and*/
    (binaryfunc)@name@_xor,                  /*nb_xor*/
    (binaryfunc)@name@_or,                   /*nb_or*/
    0,                                      /*nb_coerce*/
    (unaryfunc)@name@_int,                   /*nb_int*/
    (unaryfunc)@name@_long,                  /*nb_long*/
    (unaryfunc)@name@_float,                 /*nb_float*/
    (unaryfunc)@name@_oct,                   /*nb_oct*/
    (unaryfunc)@name@_hex,                  /*nb_hex*/
    0,                                     /*inplace_add*/
    0,                                     /*inplace_subtract*/
    0,                                     /*inplace_multiply*/
    0,                                     /*inplace_divide*/
    0,                                    /*inplace_remainder*/
    0,                              /*inplace_power*/
    0,                            /*inplace_lshift*/
    0,                            /*inplace_rshift*/
    0,                            /*inplace_and*/
    0,                            /*inplace_xor*/
    0,                            /*inplace_or*/
    (binaryfunc)@name@_floor_divide,            /*nb_floor_divide*/
    (binaryfunc)@name@_true_divide,             /*nb_true_divide*/
    0,                                         /*nb_inplace_floor_divide*/
    0,                                         /*nb_inplace_true_divide*/
#if PY_VERSION_HEX >= 0x02050000
    (lenfunc)@name@_index,                     /*nb_index*/
#endif
};
/**end repeat**/

static void
add_scalarmath(void)
{
    /**begin repeat
       #name=byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,double,longdouble,cfloat,cdouble,clongdouble#
       #NAME=Byte, UByte, Short, UShort, Int, UInt, Long, ULong, LongLong, ULongLong, Float, Double, LongDouble, CFloat, CDouble, CLongDouble#
    **/
    Py@NAME@ArrType_Type.tp_as_number = &(@name@_as_number);
    Py@NAME@ArrType_Type.tp_richcompare = @name@_richcompare;
    /**end repeat**/
}

static void *saved_tables[9];

char doc_alterpyscalars[] = "";

static PyObject *
alter_pyscalars(PyObject *dummy, PyObject *args)
{
    int n;
    PyObject *obj;
    n = PyTuple_GET_SIZE(args);
    while(n--) {
	obj = PyTuple_GET_ITEM(args, n);
	if (obj == (PyObject *)(&PyInt_Type)) {
	    PyInt_Type.tp_as_number = PyLongArrType_Type.tp_as_number;
	    PyInt_Type.tp_compare = PyLongArrType_Type.tp_compare;
	    PyInt_Type.tp_richcompare = PyLongArrType_Type.tp_richcompare;
	}
	else if (obj == (PyObject *)(&PyFloat_Type)) {
	    PyFloat_Type.tp_as_number = PyDoubleArrType_Type.tp_as_number;
	    PyFloat_Type.tp_compare = PyDoubleArrType_Type.tp_compare;
	    PyFloat_Type.tp_richcompare = PyDoubleArrType_Type.tp_richcompare;
	}
	else if (obj == (PyObject *)(&PyComplex_Type)) {
	    PyComplex_Type.tp_as_number = PyCDoubleArrType_Type.tp_as_number;
	    PyComplex_Type.tp_compare = PyCDoubleArrType_Type.tp_compare;
	    PyComplex_Type.tp_richcompare =		\
		PyCDoubleArrType_Type.tp_richcompare;
	} 
	else {
	    PyErr_SetString(PyExc_ValueError, 
			    "arguments must be int, float, or complex");
	    return NULL;
	}
    }
    Py_INCREF(Py_None);
    return Py_None;
}

char doc_restorepyscalars[] = "";
static PyObject *
restore_pyscalars(PyObject *dummy, PyObject *args)
{
    int n;
    PyObject *obj;
    n = PyTuple_GET_SIZE(args);
    while(n--) {
	obj = PyTuple_GET_ITEM(args, n);
	if (obj == (PyObject *)(&PyInt_Type)) {
	    PyInt_Type.tp_as_number = saved_tables[0];
	    PyInt_Type.tp_compare = saved_tables[1];
	    PyInt_Type.tp_richcompare = saved_tables[2];
	}
	else if (obj == (PyObject *)(&PyFloat_Type)) {
	    PyFloat_Type.tp_as_number = saved_tables[3];
	    PyFloat_Type.tp_compare = saved_tables[4];
	    PyFloat_Type.tp_richcompare = saved_tables[5];
	}
	else if (obj == (PyObject *)(&PyComplex_Type)) {
	    PyComplex_Type.tp_as_number = saved_tables[6];
	    PyComplex_Type.tp_compare = saved_tables[7];
	    PyComplex_Type.tp_richcompare = saved_tables[8];
	} 
	else {
	    PyErr_SetString(PyExc_ValueError, 
			    "arguments must be int, float, or complex");
	    return NULL;
	}
    }
    Py_INCREF(Py_None);
    return Py_None;
}

static struct PyMethodDef methods[] = {
    {"alter_scalars", (PyCFunction) alter_pyscalars,
     METH_VARARGS, doc_alterpyscalars},
    {"restore_scalars", (PyCFunction) restore_pyscalars,
     METH_VARARGS, doc_restorepyscalars},
    {NULL, NULL, 0}
};

PyMODINIT_FUNC initscalarmath(void) {
    PyObject *m;

    m = Py_InitModule("scalarmath", methods);
	
    if (import_array() < 0) return;
    if (import_umath() < 0) return;

    add_scalarmath();

    saved_tables[0] = PyInt_Type.tp_as_number;
    saved_tables[1] = PyInt_Type.tp_compare;
    saved_tables[2] = PyInt_Type.tp_richcompare;
    saved_tables[3] = PyFloat_Type.tp_as_number;
    saved_tables[4] = PyFloat_Type.tp_compare;
    saved_tables[5] = PyFloat_Type.tp_richcompare;
    saved_tables[6] = PyComplex_Type.tp_as_number;
    saved_tables[7] = PyComplex_Type.tp_compare;
    saved_tables[8] = PyComplex_Type.tp_richcompare;

    return;
}
