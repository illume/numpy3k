/* -*- c -*- */

/* The purpose of this module is to add faster math for array scalars
   that does not go through the ufunc machinery  

   but still supports error-modes. 

   NOT FINISHED
*/

#include "numpy/arrayobject.h"
#include "numpy/arrayscalars.h"
#include "numpy/ufuncobject.h"

/* The general strategy for commutative binary operators is to

1) Make self the array scalar and "other" the other data-type
2) If both are the same data-type, then do a quick exit.
3) If other is another array scalar, then
a) If it can be cast then cast and calculate
b) Otherwise, return NotImplemented 
(or call the appropriate function on other... ---
shortcut what Python will do anyway). 
4) If other is a 0-d array
-- Cast it to an array scalar and do #3
5) If other is a Python scalar
-- Cast it to an array scalar and do #3
6) Go through the ufunc machinery for all other cases. 

*/

 /* For error-handling.  If an error is detected, only then 
    should we lookup get the current error-handling state and
    act accordingly. 
 */
	       
static PyObject *
_object_to_scalar(PyObject *object)
{
    PyObject *ret=NULL;
    if PyArray_IsZeroDim(object) 
	return PyArray_ToScalar(PyArray_DATA(object), object)
	if PyInt_Check(object) {
	    ret = PyArrayScalar_New(Long);
	    if (ret == NULL) return NULL;
	    PyArrayScalar_VAL(ret, Long) = PyInt_AS_LONG(object);
	}
	else if PyFloat_Check(object) {
	    ret = PyArrayScalar_New(Double);
	    if (ret == NULL) return NULL;
	    PyArrayScalar_VAL(ret, Double) = PFloat_AS_DOUBLE(object);
	}
	else if PyComplex_Check(object) {
	    ret = PyArrayScalar_New(CDouble);
	    if (ret == NULL) return NULL;
	    PyArrayScalar_VAL(ret, CDouble).real = \
		((PyComplexObject *)object)->cval.real;	
	    PyArrayScalar_VAL(ret, CDouble).imag = \
		((PyComplexObject *)object)->cval.imag;
	}
	else if PyLong_Check(object) {
	    longlong val;
	    val = PyLong_AsLongLong(object);		
	    if (val==-1 && PyErr_Occurred()) {
		PyErr_Clear();
		return NULL;
	    }
	    ret = PyArrayScalar_New(LongLong);
	    if (ret == NULL) return NULL;
	    PyArrayScalar_VAL(ret, LongLong) = val;
	}
	else if PyBool_Check(object) {
	    if (object == Py_True) {
		PyArrayScalar_RETURN_TRUE;
	    }
	    else {
		PyArrayScalar_RETURN_FALSE;
	    }
	}
    return ret;
}


/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,float,double,longdouble,cfloat,cdouble,clongdouble#
   #Name=Byte, UByte, Short, UShort, Int, UInt, Long, ULong, LongLong, ULongLong, Float, Double, LongDouble, CFloat, CDouble, CLongDouble#
   #NAME=BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, CFLOAT, CDOUBLE, CLONGDOUBLE#
**/ 

static int
_@name@_convert_to_ctype(PyObject *a, @name@ *arg1)
{
    PyObject *temp; 

    if (PyObject_IsScalar(a, @Name@)) {
	*arg1 = PyArrayScalar_VAL(a);
	return 0;
    }
    else if (PyObject_IsScalar(a, Generic)) {
	PyArray_Descr *descr1, *descr2;
	int ret;
	if (!PyObject_IsScalar(a, Number)) return -1;
	descr1 = PyArray_DescrFromTypeObject(a->ob_type);
 	if (PyArray_CanCastSafely(descr1->type_num, PyArray_@NAME@)) {
	    PyArray_CastScalarDirect(a, descr1, arg1, PyArray_@NAME@);
	    ret = 0
	}
	else ret = -1;
	Py_DECREF(descr1);
	return ret;
    }
    else if ((temp = _object_to_scalar(a)) != NULL) {
	return _@nam@_convert_to_ctype(temp, arg1);
    }
    return -2;
}	

static int
_@name@_convert2_to_ctypes(PyObject *a, @name@ *arg1, 
			   PyObject *b, @name@ *arg2)
{
    ret = _@name@_convert_to_ctype(a, arg1);
    if (ret < 0) return ret;
    ret = _@name@_convert_to_ctype(b, arg2);
    if (ret < 0) return ret;
    return 0;
}

/**end repeat**/

/**begin repeat
   #name=(byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong)*14, (float, double, longdouble, cfloat, cdouble, clongdouble)*9#
   #Name=(Byte, UByte, Short, UShort, Int, UInt, Long, ULong, LongLong, ULongLong)*14, (Float, Double, LongDouble, CFloat, CDouble, CLongDouble)*9#
   #oper=add*10, subtract*10, multiply*10, divide*10, remainder*10, divmod*10, power*10, floor_divide*10, true_divide*10, lshift*10, rshift*10, and*10, or*10, xor*10, add*6, subtract*6, multiply*6, divide*6, remainder*6, divmod*6, power*6, floor_divide*6, true_divide*6#
**/

static PyObject *
@name@_@oper@(PyObject *a, PyObject *b)
{
    @name@ arg1, arg2, out;
	
    switch(_@name@_convert2_to_ctypes(a, &arg1, b, &arg2)) {
    case 0:
	break;
    case -1: /* can't cast both safely use different add function */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
    case -2: /* use ufunc */
	if (PyErr_Occurred()) return NULL;
	return PyGenericArrType_Type.tp_as_number->nb_@oper@(a,b);
    }
	
    /* here we do the actual calculation with arg1 and arg2 */
    /* make it a function call. */
    if (@name@_ctype_@oper@(arg1, arg2, &out) < 0) {
	/* Look-up error-handling */
    }
    ret = PyArrayScalar_New(@Name@);
    PyArrayScalar_VAL(ret, @Name@) = out;
    return ret;
}

/**end repeat**/	

/**begin repeat
   #name=(float,double,longdouble,cfloat,cdouble,clongdouble)*6#
   #oper=lshift*6, rshift*6, and*6, or*6, xor*6, index*6#
**/
#define @name@_@oper@ NULL
/**end repeat**/

/**begin repeat
   #name=(byte,ubyte,short,ushort,int,uint,long,ulong,float,double,longdouble,cfloat,cdouble,clongdouble)*10#
   #Name=(Byte, UByte, Short, UShort, Int, UInt, Long, ULong, LongLong, ULongLong, Float, Double, LongDouble, CFloat, CDouble, CLongDouble)*10#
   #oper=negative*14, positive*14, absolute*14, nonzero*14, invert*14, int*14, long*14, float*14, oct*14, hex*14#
**/

static PyObject *
@name@_@oper@(PyObject *a)
{
    @name@ arg1, out;
	
    switch(_@name@_convert_to_ctype(a, &arg1)) {
    case 0:
	break;
    case -1: /* can't cast both safely use different add function */
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
    case -2: /* use ufunc */
	if (PyErr_Occurred()) return NULL;
	return PyGenericArrType_Type.tp_as_number->nb_@oper@(a);
    }
	
    /* here we do the actual calculation with arg1 and arg2 */
    /* make it a function call. */
    if (@name@_ctype_@oper@(arg1, &out) < 0) {
	/* Look-up error-handling */
    }
    ret = PyArrayScalar_New(@Name@);
    PyArrayScalar_VAL(ret, @Name@) = out;
    return ret;

}
/**end repeat**/


#if PY_VERSION_HEX >= 0x02050000
/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong#
   #Name=Byte, UByte, Short, UShort, Int, UInt, Long, ULong, LongLong, ULongLong#
**/
static Py_ssize_t
@name@_index(PyObject *a)
{
    return PyArrayScalar_VAL(a, @Name@);    
}
/**end repeat**/
#endif


static PyObject*
@name@_richcompare(PyObject *self, PyObject *other, int cmp_op)
{
}
/**end repeat**/




/**begin repeat
   #name=byte,ubyte,short,ushort,int,uint,long,ulong,float,double,longdouble,cfloat,cdouble,clongdouble#
**/
static PyNumberMethods @name@_as_number = {
    (binaryfunc)@name@_add,                    /*nb_add*/
    (binaryfunc)@name@_subtract,               /*nb_subtract*/
    (binaryfunc)@name@_multiply,               /*nb_multiply*/
    (binaryfunc)@name@_divide,                 /*nb_divide*/
    (binaryfunc)@name@_remainder,              /*nb_remainder*/
    (binaryfunc)@name@_divmod,                 /*nb_divmod*/
    (ternaryfunc)@name@_power,                 /*nb_power*/
    (unaryfunc)@name@_negative,
    (unaryfunc)@name@_positive,                    /*nb_pos*/
    (unaryfunc)@name@_absolute,                /*nb_abs*/
    (inquiry)@name@_nonzero_number,            /*nb_nonzero*/
    (unaryfunc)@name@_invert,                  /*nb_invert*/
    (binaryfunc)@name@_lshift,                /*nb_lshift*/
    (binaryfunc)@name@_rshift,                /*nb_rshift*/
    (binaryfunc)@name@_and,                  /*nb_and*/
    (binaryfunc)@name@_xor,                  /*nb_xor*/
    (binaryfunc)@name@_or,                   /*nb_or*/
    0,                                      /*nb_coerce*/
    (unaryfunc)@name@_int,                   /*nb_int*/
    (unaryfunc)@name@_long,                  /*nb_long*/
    (unaryfunc)@name@_float,                 /*nb_float*/
    (unaryfunc)@name@_oct,                   /*nb_oct*/
    (unaryfunc)@name@_hex,                  /*nb_hex*/
    0,                                     /*inplace_add*/
    0,                                     /*inplace_subtract*/
    0,                                     /*inplace_multiply*/
    0,                                     /*inplace_divide*/
    0,                                    /*inplace_remainder*/
    0,                              /*inplace_power*/
    0,                            /*inplace_lshift*/
    0,                            /*inplace_rshift*/
    0,                            /*inplace_and*/
    0,                            /*inplace_xor*/
    0,                            /*inplace_or*/
    (binaryfunc)@name@_floor_divide,            /*nb_floor_divide*/
    (binaryfunc)@name@_true_divide,             /*nb_true_divide*/
    0,                                         /*nb_inplace_floor_divide*/
    0,                                         /*nb_inplace_true_divide*/
#if PY_VERSION_HEX >= 0x02050000
    (lenfunc)@name@_index,                     /*nb_index*/
#endif
};

static void
add_scalarmath(void)
{
    /**begin repeat
       #name=byte,ubyte,short,ushort,int,uint,long,ulong,float,double,longdouble,cfloat,cdouble,clongdouble#
       #NAME=Byte, Short, Int, Long, LongLong, UByte, UShort, UInt, ULong, ULongLong, Float, Double, LongDouble, CFloat, CDouble, CLongDouble#
    **/
    PyArr@NAME@Type_Type.tp_as_number = @name@_as_number;
    PyArr@NAME@Type_Type.tp_richcompare = @name@_richcompare;
    /**end repeat**/
}



static struct PyMethodDef methods[] = {
    {"alter_pyscalars", (PyCFunction) alter_pyscalars,
     METH_VARARGS , doc_alterpyscalars},
    {NULL, NULL, 0}
};

PyMODINIT_FUNC initscalarmath(void) {
    PyObject *m;

    m = Py_initModule("scalarmath", methods);
	
    if (import_array() < 0) return;
    if (import_umath() < 0) return;

    add_scalarmath();
	
    return;
}
