/* The purpose of this module is to add faster math for array scalars
    that does not go through the ufunc machinery

    NOT FINISHED
 */

#include "numpy/arrayobject.h"
#include "numpy/ufuncobject.h"


/**begin repeat
name=bool,

**/
static PyNumberMethods @name@_as_number = {
        (binaryfunc)@name@_add,                    /*nb_add*/
        (binaryfunc)@name@_subtract,               /*nb_subtract*/
        (binaryfunc)@name@_multiply,               /*nb_multiply*/
        (binaryfunc)@name@_divide,                 /*nb_divide*/
        (binaryfunc)@name@_remainder,              /*nb_remainder*/
        (binaryfunc)@name@_divmod,                 /*nb_divmod*/
        (ternaryfunc)@name@_power,                 /*nb_power*/
        (unaryfunc)@name@_negative,
        (unaryfunc)@name@_copy,                    /*nb_pos*/
        (unaryfunc)@name@_absolute,                /*nb_abs*/
        (inquiry)@name@_nonzero_number,            /*nb_nonzero*/
        (unaryfunc)@name@_invert,                  /*nb_invert*/
        (binaryfunc)@name@_lshift,                /*nb_lshift*/
        (binaryfunc)@name@_rshift,                /*nb_rshift*/
        (binaryfunc)@name@_and,                  /*nb_and*/
        (binaryfunc)@name@_xor,                  /*nb_xor*/
        (binaryfunc)@name@_or,                   /*nb_or*/
        0,                                      /*nb_coerce*/
        (unaryfunc)@name@_int,                   /*nb_int*/
        (unaryfunc)@name@_long,                  /*nb_long*/
        (unaryfunc)@name@_float,                 /*nb_float*/
        (unaryfunc)@name@_oct,                   /*nb_oct*/
        (unaryfunc)@name@_hex,                  /*nb_hex*/
        0,                                     /*inplace_add*/
        0,                                     /*inplace_subtract*/
        0,                                     /*inplace_multiply*/
        0,                                     /*inplace_divide*/
        0,                                    /*inplace_remainder*/
        0,                              /*inplace_power*/
        0,                            /*inplace_lshift*/
        0,                            /*inplace_rshift*/
        0,                            /*inplace_and*/
        0,                            /*inplace_xor*/
        0,                            /*inplace_or*/
        (binaryfunc)@name@_floor_divide,            /*nb_floor_divide*/
        (binaryfunc)@name@_true_divide,             /*nb_true_divide*/
        0,                                         /*nb_inplace_floor_divide*/
        0,                                         /*nb_inplace_true_divide*/

};

/**end repeat**/


/**begin repeat

**/

static PyObject*
@name@_richcompare(PyObject *self, PyObject *other, int cmp_op)
{
}
/**end repeat**/



static void
add_scalarmath(void)
{
/**begin repeat
name=bool,
NAME=Bool
**/
	PyArr@NAME@Type_Type.tp_as_number = @name@_as_number;
	PyArr@NAME@Type_Type.tp_richcompare = @name@_richcompare;
/**end repeat**/
}



static struct PyMethodDef methods[] = {
	{"alter_pyscalars", (PyCFunction) alter_pyscalars,
	 METH_VARARGS , doc_alterpyscalars},
	{NULL, NULL, 0}
};

DL_EXPORT(void) initscalarmath(void) {
	PyObject *m;

	m = Py_initModule("scalarmath", methods);
	
	if (import_array() < 0) return;
	if (import_umath() < 0) return;

	add_scalarmath();
	
	return;
}
