/* The purpose of this module is to add faster sort functions
   that are type-specific.  This is done by altering the
   function table for the builtin descriptors. 

   These sorting functions are copied from numarray 
*/


#include "Python.h"
#include "scipy/arrayobject.h"

#define STDC_LT(a,b) ((a) < (b))
#define STDC_LE(a,b) ((a) <= (b))
#define STDC_EQ(a,b) ((a) == (b))
#define SWAP(a,b) {SWAP_temp = (b); (b)=(a); (a) = SWAP_temp;}

/**begin repeat
#TYPE=BOOL,BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE#
#type=Bool,byte,ubyte,short,ushort,int,uint,long,ulong,longlong,ulonglong,float,double,longdouble#
 **/
static void 
@TYPE@_quicksort(@type@ *start, intp num, int elsize, void *unused)
{
	@type@ *pl = start;
	@type@ *pr = start + num - 1;
	@type@ vp, SWAP_temp;
	@type@ *stack[100], **sptr = stack, *pm, *pi, *pj, *pt;

        for(;;) {
                while ((pr - pl) > 15) {
                        /* quicksort partition */
                        pm = pl + ((pr - pl) >> 1);
                        if (STDC_LT(*pm,*pl)) SWAP(*pm,*pl);
                        if (STDC_LT(*pr,*pm)) SWAP(*pr,*pm);
                        if (STDC_LT(*pm,*pl)) SWAP(*pm,*pl);
                        vp = *pm;
                        pi = pl;
                        pj = pr - 1;
                        SWAP(*pm,*pj);
                        for(;;) {
                                do ++pi; while (STDC_LT(*pi,vp));
                                do --pj; while (STDC_LT(vp,*pj));
                                if (pi >= pj)  break;
                                SWAP(*pi,*pj);
                        }
                        SWAP(*pi,*(pr-1));
                        /* push largest partition on stack */
                        if (pi - pl < pr - pi) {
                                *sptr++ = pi + 1;
                                *sptr++ = pr;
                                pr = pi - 1;
                        }else{
                                *sptr++ = pl;
                                *sptr++ = pi - 1;
                                pl = pi + 1;
                        }
                }
                /* insertion sort */
                for(pi = pl + 1; pi <= pr; ++pi) {
                        vp = *pi;
                        for(pj = pi, pt = pi - 1; pj > pl && STDC_LT(vp, *pt);) {
                                *pj-- = *pt--;
                        }
                        *pj = vp;
                }
                if (sptr == stack) break;
                pr = *(--sptr);
                pl = *(--sptr);
        }
}

static void 
@TYPE@_aquicksort(@type@ *v, intp* tosort, intp num, int elsize, void *unused)
{
	@type@ vp;
	intp *pl, *pr, SWAP_temp;
	intp *stack[100], **sptr=stack, *pm, *pi, *pj, *pt, vi;

	pl = tosort;
	pr = tosort + num - 1;

        for(;;) {
                while ((pr - pl) > 15) {
                        /* quicksort partition */
                        pm = pl + ((pr - pl) >> 1);
                        if (STDC_LT(v[*pm],v[*pl])) SWAP(*pm,*pl);
                        if (STDC_LT(v[*pr],v[*pm])) SWAP(*pr,*pm);
                        if (STDC_LT(v[*pm],v[*pl])) SWAP(*pm,*pl);
                        vp = v[*pm];
                        pi = pl;
                        pj = pr - 1;
                        SWAP(*pm,*pj);
                        for(;;) {
                                do ++pi; while (STDC_LT(v[*pi],vp));
                                do --pj; while (STDC_LT(vp,v[*pj]));
                                if (pi >= pj)  break;
                                SWAP(*pi,*pj);
                        }
                        SWAP(*pi,*(pr-1));
                        /* push largest partition on stack */
                        if (pi - pl < pr - pi) {
                                *sptr++ = pi + 1;
                                *sptr++ = pr;
                                pr = pi - 1;
                        }else{
                                *sptr++ = pl;
                                *sptr++ = pi - 1;
                                pl = pi + 1;
                        }
                }
                /* insertion sort */
                for(pi = pl + 1; pi <= pr; ++pi) {
                        vi = *pi;
                        vp = v[vi];
                        for(pj = pi, pt = pi - 1; pj > pl && STDC_LT(vp, v[*pt]);)
				{
					*pj-- = *pt--;
				}
                        *pj = vi;
                }
                if (sptr == stack) break;
                pr = *(--sptr);
                pl = *(--sptr);
        }
}
/**end repeat**/
	
static void 
add_sortfuncs(void)
{
	PyArray_Descr *descr;

/**begin repeat
#TYPE=BOOL,BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE#
**/
	descr = PyArray_DescrFromType(PyArray_@TYPE@);
	descr->f->sort[PyArray_QUICKSORT] = (PyArray_SortFunc *)@TYPE@_quicksort;
	descr->f->argsort[PyArray_QUICKSORT] = (PyArray_ArgSortFunc *)@TYPE@_aquicksort;
/**end repeat**/
}

static struct PyMethodDef methods[] = {
	{NULL, NULL, 0}
};

PyMODINIT_FUNC
init_sort(void) {
	PyObject *m;

	m = Py_InitModule("_sort", methods);
	
	if (import_array() < 0) return;
	add_sortfuncs();
}
