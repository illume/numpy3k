/* -*- c -*- */

static int PyArrayScalar_Offset[PyArray_NTYPES+1];
/* to be exposed in C-API */
#define PyArrayScalar_False ((PyObject *)&_PyArrayScalar_BoolValues[0])
#define PyArrayScalar_True ((PyObject *)&_PyArrayScalar_BoolValues[1])
#define PyArrayScalar_RETURN_BOOL_FROM_LONG(i)			\
	return Py_INCREF(&_PyArrayScalar_BoolValues[((i)!=0)]),	\
		(PyObject *)&_PyArrayScalar_BoolValues[((i)!=0)]
#define PyArrayScalar_RETURN_FALSE		\
	return Py_INCREF(PyArrayScalar_False),	\
		PyArrayScalar_False
#define PyArrayScalar_RETURN_TRUE		\
	return Py_INCREF(PyArrayScalar_True),	\
		PyArrayScalar_True
/* end to be exposed in C-API */

#define _SOFFSET_(obj, type_num) ((char *)(obj) + PyArrayScalar_Offset[(type_num)])

/**begin repeat
#name=Bool, Byte, Short, Int, Long, LongLong, UByte, UShort, UInt, ULong, ULongLong, Float, Double, LongDouble,  CFloat, CDouble, CLongDouble, Object,#
#type=Bool, signed char, short, int, long, longlong, unsigned char, unsigned short, unsigned int, unsigned long, ulonglong, float, double, longdouble, cfloat, cdouble, clongdouble, PyObject *,char#
*/
typedef struct {
	PyObject_HEAD
	@type@ obval;
} Py@name@ScalarObject;
/**end repeat**/

static PyBoolScalarObject _PyArrayScalar_BoolValues[] = {
	{PyObject_HEAD_INIT(&PyBoolArrType_Type) 0},
	{PyObject_HEAD_INIT(&PyBoolArrType_Type) 1},
};


/* Inheritance established later when tp_bases is set (or tp_base for 
   single inheritance) */

/**begin repeat

#name=number, integer, signedinteger, unsignedinteger, inexact, floating, complexfloating, flexible, 
character#
#NAME=Number, Integer, SignedInteger, UnsignedInteger, Inexact, Floating, ComplexFloating, Flexible, Character#
*/

static PyTypeObject Py@NAME@ArrType_Type = { 
        PyObject_HEAD_INIT(NULL)
        0,					  /*ob_size*/
        "@name@_arrtype",		          /*tp_name*/
        sizeof(PyObject),		          /*tp_basicsize*/
};
/**end repeat**/


#define PyStringScalarObject PyStringObject
#define PyUnicodeScalarObject PyUnicodeObject

typedef struct {
	PyObject_VAR_HEAD
	char *obval;
	PyArray_Descr *descr;
	int flags;
	PyObject *base;
} PyVoidScalarObject;

/* no error checking is performed -- ctypeptr must be same type as scalar */
/* in case of flexible type, the data is not copied 
   into ctypeptr which is expected to be a pointer to pointer */
/*OBJECT_API
 Convert to c-type
*/
static void
PyArray_ScalarAsCtype(PyObject *scalar, void *ctypeptr)
{
	PyArray_Descr *typecode;
	typecode = PyArray_DescrFromScalar(scalar);
	
	if (PyTypeNum_ISEXTENDED(typecode->type_num)) {
		void **newptr = (void **)ctypeptr;
		switch(typecode->type_num) {
		case PyArray_STRING:
			*newptr = (void *)PyString_AS_STRING(scalar);
		case PyArray_UNICODE:
			*newptr = (void *)PyUnicode_AS_DATA(scalar);
		default:
			*newptr = ((PyVoidScalarObject *)scalar)->obval;
		}
		return;
	}
	memcpy(ctypeptr, _SOFFSET_(scalar, typecode->type_num),
	       typecode->elsize);
	Py_DECREF(typecode);
	return;
}

/* The output buffer must be large-enough to receive the value */
/*  Even for flexible types which is different from ScalarAsCtype
    where only a reference for flexible types is returned 
*/

/*OBJECT_API
 Cast Scalar to c-type
*/
static int
PyArray_CastScalarToCtype(PyObject *scalar, void *ctypeptr, 
			  PyArray_Descr *outcode)
{
	PyArray_Descr* descr;
	
	descr = PyArray_DescrFromScalar(scalar);
	if (PyTypeNum_ISEXTENDED(descr->type_num) ||
	    PyTypeNum_ISEXTENDED(outcode->type_num)) {
		PyArrayObject *ain, *aout;

		ain = (PyArrayObject *)PyArray_FromScalar(scalar, NULL);
		if (ain == NULL) {Py_DECREF(descr); return -1;}
		aout = (PyArrayObject *)\
			PyArray_NewFromDescr(&PyArray_Type, 
					     outcode,
					     0, NULL, 
					     NULL, ctypeptr, 
					     CARRAY_FLAGS, NULL);
		if (aout == NULL) {Py_DECREF(ain); return -1;}
		descr->f->cast[outcode->type_num](ain->data, 
					       aout->data, 1, ain, aout);
		Py_DECREF(ain);
		Py_DECREF(aout);
	}
	else {
		descr->f->cast[outcode->type_num](_SOFFSET_(scalar, 
							 descr->type_num), 
					       ctypeptr, 1, NULL, NULL);
	}
	Py_DECREF(descr);
	return 0;
}

/* 0-dim array from array-scalar object */
/* always contains a copy of the data 
   unless outcode is NULL, it is of void type and the referrer does
   not own it either.
*/

/* steals reference to outcode */
/*OBJECT_API
 Get 0-dim array from scalar
*/
static PyObject *
PyArray_FromScalar(PyObject *scalar, PyArray_Descr *outcode)
{
	PyArray_Descr *typecode;
	PyObject *r;
	char *memptr;
	PyObject *ret;

	/* convert to 0-dim array of scalar typecode */
	typecode = PyArray_DescrFromScalar(scalar);
	if ((typecode->type_num == PyArray_VOID) &&			\
	    !(((PyVoidScalarObject *)scalar)->flags & OWNDATA) &&	\
	    outcode == NULL) {
		r = PyArray_NewFromDescr(&PyArray_Type,
					 typecode,
					 0, NULL, NULL,
					 ((PyVoidScalarObject *)scalar)->obval,
					 ((PyVoidScalarObject *)scalar)->flags,
					 NULL);
		PyArray_BASE(r) = (PyObject *)scalar;
		Py_INCREF(scalar);
		return r;
	}
	r = PyArray_NewFromDescr(&PyArray_Type, 
				 typecode,
				 0, NULL, 
				 NULL, NULL, 0, NULL);
	if (r==NULL) {Py_XDECREF(outcode); return NULL;}

	switch(typecode->type_num) {
	case PyArray_STRING:
		memptr = PyString_AS_STRING(scalar);
		break;
	case PyArray_UNICODE:
		memptr = (char *)PyUnicode_AS_DATA(scalar);
		break;
	default:
		if (PyTypeNum_ISEXTENDED(typecode->type_num)) {
			memptr = (((PyVoidScalarObject *)scalar)->obval);
		}
		else {
			memptr = _SOFFSET_(scalar, typecode->type_num);
		}
		break;
	}

	memcpy(PyArray_DATA(r), memptr, PyArray_ITEMSIZE(r));
	if (PyArray_ISOBJECT(r)) {
		Py_INCREF(*((PyObject **)memptr));
	}
	
	if (outcode == NULL) return r;
	
	if (outcode->type_num == typecode->type_num) {
		if (!PyTypeNum_ISEXTENDED(typecode->type_num))
			return r;
		if (outcode->elsize == typecode->elsize);
		return r;			
	}
	
	/* cast if necessary to desired output typecode */
	ret = PyArray_CastToType((PyArrayObject *)r, outcode, 0);
	Py_DECREF(r);
	return ret;
}

static PyObject *
gentype_alloc(PyTypeObject *type, int nitems)
{
        PyObject *obj;
        const size_t size = _PyObject_VAR_SIZE(type, nitems+1);

        obj = (PyObject *)_pya_malloc(size);
	memset(obj, 0, size);
	if (type->tp_itemsize == 0)
                PyObject_INIT(obj, type);
        else
                (void) PyObject_INIT_VAR((PyVarObject *)obj, type, nitems);
        return obj;
}

static void
gentype_dealloc(PyObject *v) 
{
	v->ob_type->tp_free(v);
}


static PyObject *
gentype_power(PyObject *m1, PyObject *m2, PyObject *m3)
{
	PyObject *arr, *ret, *arg2;
	char *msg="unsupported operand type(s) for ** or pow()";
	
	if (!PyArray_IsScalar(m1,Generic)) {
		if (PyArray_Check(m1)) {
			ret = m1->ob_type->tp_as_number->nb_power(m1,m2, 
								  Py_None);
		}
		else {
			if (!PyArray_IsScalar(m2,Generic)) {
				PyErr_SetString(PyExc_TypeError, msg);
				return NULL;
			}
			arr = PyArray_FromScalar(m2, NULL);
			if (arr == NULL) return NULL;
			ret = arr->ob_type->tp_as_number->nb_power(m1, arr,
								   Py_None);
			Py_DECREF(arr);
		}
		return ret;
	}
	if (!PyArray_IsScalar(m2, Generic)) {
		if (PyArray_Check(m2)) {
			ret = m2->ob_type->tp_as_number->nb_power(m1,m2, 
								  Py_None);
		}
		else {
			if (!PyArray_IsScalar(m1, Generic)) {
				PyErr_SetString(PyExc_TypeError, msg);
				return NULL;
			}
			arr = PyArray_FromScalar(m1, NULL);
			if (arr == NULL) return NULL;
			ret = arr->ob_type->tp_as_number->nb_power(arr, m2,
								   Py_None);
			Py_DECREF(arr);
		}
		return ret;
	}
	arr=arg2=NULL;
	arr = PyArray_FromScalar(m1, NULL);
	arg2 = PyArray_FromScalar(m2, NULL);	
	if (arr == NULL || arg2 == NULL) {
		Py_XDECREF(arr); Py_XDECREF(arg2); return NULL;
	}
	ret = arr->ob_type->tp_as_number->nb_power(arr, arg2, Py_None);
	Py_DECREF(arr);
	Py_DECREF(arg2);
	return ret;
}

static PyObject *
gentype_generic_method(PyObject *self, PyObject *args, PyObject *kwds, 
		       char *str)
{
	PyObject *arr, *meth, *ret;

	arr = PyArray_FromScalar(self, NULL);
	if (arr == NULL) return NULL;
	meth = PyObject_GetAttrString(arr, str);
	if (meth == NULL) {Py_DECREF(arr); return NULL;}
	if (kwds == NULL) 
		ret = PyObject_CallObject(meth, args);
	else
		ret = PyObject_Call(meth, args, kwds);
	Py_DECREF(meth);
	Py_DECREF(arr);
        if (ret && PyArray_Check(ret))
                return PyArray_Return((PyArrayObject *)ret);
        else
                return ret;
}

/**begin repeat

#name=add, subtract, divide, remainder, divmod, lshift, rshift, and, xor, or, floor_divide, true_divide#
#PYNAME=Add, Subtract, Divide, Remainder, Divmod, Lshift, Rshift, And, Xor, Or, FloorDivide, TrueDivide#
*/

static PyObject *
gentype_@name@(PyObject *m1, PyObject *m2)
{
	PyObject *arr, *ret=NULL, *tup;
	
	if (!PyArray_IsScalar(m1, Generic)) {
		if (PyArray_Check(m1)) {
			ret = m1->ob_type->tp_as_number->nb_@name@(m1,m2);
		}
                else {
			PyObject *newarr;
			/* Convert object to Array scalar and try again */
			newarr = PyArray_FromAny(m1, NULL, 0, 0, 0, NULL);
			if (newarr!=NULL) {
				ret = newarr->ob_type->tp_as_number->nb_@name@(newarr, m2);
				Py_DECREF(newarr);
			}
			else ret=NULL;
		}
		return ret;
	}
	if (!PyArray_IsScalar(m2, Generic)) {
		if (PyArray_Check(m2)) {
			ret = m2->ob_type->tp_as_number->nb_@name@(m1,m2);
		}
		else {
			PyObject *newarr;
			/* Convert object to Array and try again */
			newarr = PyArray_FromAny(m2, NULL, 0, 0, 0, NULL);
			if (newarr!=NULL) {
				ret = newarr->ob_type->tp_as_number->nb_@name@(m1, newarr);
				Py_DECREF(newarr);
			}
			else ret=NULL;
		}
		return ret;
	}
	arr=tup=NULL;
	arr = PyArray_FromScalar(m1, NULL);
	tup = PyArray_FromScalar(m2, NULL);
	if (arr == NULL || tup == NULL) {
		Py_XDECREF(tup); Py_XDECREF(arr); return NULL;
	}
	ret = arr->ob_type->tp_as_number->nb_@name@(arr, tup);
	Py_DECREF(arr);
	Py_DECREF(tup);
	return ret;
}
/**end repeat**/


static PyObject *
gentype_multiply(PyObject *m1, PyObject *m2)
{
	PyObject *arr, *ret=NULL, *tup;
	long repeat;

	if (!PyArray_IsScalar(m1, Generic)) {
		if (PyArray_Check(m1)) {
			ret = m1->ob_type->tp_as_number->nb_multiply(m1,m2);
		}
		else if ((m1->ob_type->tp_as_number == NULL) ||
			 (m1->ob_type->tp_as_number->nb_multiply == NULL)) {
			/* Convert m2 to an int and assume sequence
			   repeat */
			repeat = PyInt_AsLong(m2);
			if (repeat == -1 && PyErr_Occurred()) return NULL;
			ret = PySequence_Repeat(m1, (int) repeat);
			if (ret == NULL) {
				PyErr_Clear();
				arr = PyArray_FromScalar(m2, NULL);
				if (arr == NULL) return NULL;
				ret = arr->ob_type->tp_as_number->\
					nb_multiply(m1, arr);
				Py_DECREF(arr);
			}
		}
		else {
			PyObject *newarr;
			/* Convert object to Array scalar and try again */
			newarr = PyArray_FromAny(m1, NULL, 0, 0, 0, NULL);
			if (newarr!=NULL) {
				ret = newarr->ob_type->tp_as_number->nb_multiply(newarr, m2);
				Py_DECREF(newarr);
			}
			else ret=NULL;
		}
		return ret;
	}
	if (!PyArray_IsScalar(m2, Generic)) {
		if (PyArray_Check(m2)) {
			ret = m2->ob_type->tp_as_number->nb_multiply(m1,m2);
		}
		else if ((m2->ob_type->tp_as_number == NULL) ||
			 (m2->ob_type->tp_as_number->nb_multiply == NULL)) {
			/* Convert m1 to an int and assume sequence
			   repeat */
			repeat = PyInt_AsLong(m1);
			if (repeat == -1 && PyErr_Occurred()) return NULL;
			ret = PySequence_Repeat(m2, (int) repeat);
			if (ret == NULL) {
				PyErr_Clear();
				arr = PyArray_FromScalar(m1, NULL);
				if (arr == NULL) return NULL;
				ret = arr->ob_type->tp_as_number->	\
					nb_multiply(arr, m2);
				Py_DECREF(arr);
			}			
		}
		else {
			PyObject *newarr;
			/* Convert object to Array scalar and try again */
			newarr = PyArray_FromAny(m2, NULL, 0, 0, 0, NULL);
			if (newarr!=NULL) {
				ret = newarr->ob_type->tp_as_number->nb_multiply(m1, newarr);
				Py_DECREF(newarr);
			}
			else ret =NULL;
		}
		return ret;
	}
	/* Both are array scalar objects */
	arr=tup=NULL;
	arr = PyArray_FromScalar(m1, NULL);
	tup = PyArray_FromScalar(m2, NULL);
	if (arr == NULL || tup == NULL) {
		Py_XDECREF(tup); Py_XDECREF(arr); return NULL;
	}
	ret = arr->ob_type->tp_as_number->nb_multiply(arr, tup);
	Py_DECREF(arr);
	Py_DECREF(tup);
	return ret;

}



/**begin repeat

#name=negative, absolute, invert, int, long, float, oct, hex#
*/

static PyObject *
gentype_@name@(PyObject *m1)
{
	PyObject *arr, *ret;

	arr = PyArray_FromScalar(m1, NULL);
	if (arr == NULL) return NULL;
	ret = arr->ob_type->tp_as_number->nb_@name@(arr);
	Py_DECREF(arr);
	return ret;
}
/**end repeat**/

static int
gentype_nonzero_number(PyObject *m1)
{
	PyObject *arr;
	int ret;

	arr = PyArray_FromScalar(m1, NULL);
	if (arr == NULL) return -1;
	ret = arr->ob_type->tp_as_number->nb_nonzero(arr);
	Py_DECREF(arr);
	return ret;
}

static PyObject *
gentype_str(PyObject *self)
{
	PyArrayObject *arr;
	PyObject *ret, *tmp;

	arr = (PyArrayObject *)PyArray_FromScalar(self, NULL);
	if (arr==NULL) return NULL;
	ret = PyObject_Str((tmp=arr->descr->f->getitem(arr->data, arr)));
	Py_DECREF(arr);
	Py_XDECREF(tmp);
	return ret;
}

static PyObject *
gentype_repr(PyObject *self)
{
	PyArrayObject *arr;
	PyObject *ret, *tmp ;

	arr = (PyArrayObject *)PyArray_FromScalar(self, NULL);
	if (arr==NULL) return NULL;
	ret = PyObject_Repr((tmp=arr->descr->f->getitem(arr->data, arr)));
	Py_DECREF(arr);
	Py_XDECREF(tmp);
	return ret;
}

static void
format_longdouble(char *buf, size_t buflen, longdouble val, int precision)
{
        register char *cp;

        PyOS_snprintf(buf, buflen, "%.*" LONGDOUBLE_FMT, precision, val);
        cp = buf;
        if (*cp == '-')
                cp++;
        for (; *cp != '\0'; cp++) {
                if (!isdigit(Py_CHARMASK(*cp)))
                        break;
        }
        if (*cp == '\0') {
                *cp++ = '.';
                *cp++ = '0';
                *cp++ = '\0';
        }
}

#if SIZEOF_LONGDOUBLE == SIZEOF_DOUBLE
#define PREC_REPR 15
#define PREC_STR 15
#else
#define PREC_REPR 21
#define PREC_STR 21
#endif

static PyObject *
longdoubletype_repr(PyObject *self)
{
        static char buf[100];
        format_longdouble(buf, sizeof(buf), ((PyLongDoubleScalarObject *)self)->obval, PREC_REPR);
        return PyString_FromString(buf);
}

static PyObject *
clongdoubletype_repr(PyObject *self)
{
        static char buf1[100];
        static char buf2[100];
	static char buf3[202];
        clongdouble x;
        x = ((PyCLongDoubleScalarObject *)self)->obval;
        format_longdouble(buf1, sizeof(buf1), x.real, PREC_REPR);
        format_longdouble(buf2, sizeof(buf2), x.imag, PREC_REPR);

	snprintf(buf3, sizeof(buf3), "(%s+%sj)", buf1, buf2);
	return PyString_FromString(buf3);
}

#define longdoubletype_str longdoubletype_repr
#define clongdoubletype_str clongdoubletype_repr

/** Could improve this with a PyLong_FromLongDouble(longdouble ldval)
    but this would need some more work...
**/

/**begin repeat

#name=(int, long, hex, oct, float)*2#
#KIND=(Long*4, Float)*2#
#char=,,,,,c*5#
#CHAR=,,,,,C*5#
#POST=,,,,,.real*5#
*/
static PyObject *
@char@longdoubletype_@name@(PyObject *self)
{
	double dval;
	PyObject *obj, *ret;
	
	dval = (double)(((Py@CHAR@LongDoubleScalarObject *)self)->obval)@POST@;
	obj = Py@KIND@_FromDouble(dval);
	ret = obj->ob_type->tp_as_number->nb_@name@(obj);
	Py_DECREF(obj);
	return ret;
}
/**end repeat**/


static PyObject *gentype_copy(PyObject *, PyObject *);

static PyNumberMethods gentype_as_number = {
        (binaryfunc)gentype_add,		    /*nb_add*/
        (binaryfunc)gentype_subtract,		    /*nb_subtract*/
        (binaryfunc)gentype_multiply,		    /*nb_multiply*/
        (binaryfunc)gentype_divide,		    /*nb_divide*/
        (binaryfunc)gentype_remainder,	    /*nb_remainder*/
        (binaryfunc)gentype_divmod,		    /*nb_divmod*/
        (ternaryfunc)gentype_power,		    /*nb_power*/
        (unaryfunc)gentype_negative,	            
        (unaryfunc)gentype_copy,		    /*nb_pos*/ 
        (unaryfunc)gentype_absolute,		    /*(unaryfunc)gentype_abs,*/
        (inquiry)gentype_nonzero_number,		    /*nb_nonzero*/
        (unaryfunc)gentype_invert,		    /*nb_invert*/
        (binaryfunc)gentype_lshift,	    /*nb_lshift*/
        (binaryfunc)gentype_rshift,	    /*nb_rshift*/
        (binaryfunc)gentype_and,	    /*nb_and*/
        (binaryfunc)gentype_xor,	    /*nb_xor*/
        (binaryfunc)gentype_or,	    /*nb_or*/
        0,		                    /*nb_coerce*/
        (unaryfunc)gentype_int,		    /*nb_int*/
        (unaryfunc)gentype_long,		    /*nb_long*/
        (unaryfunc)gentype_float,		    /*nb_float*/
        (unaryfunc)gentype_oct,		    /*nb_oct*/
        (unaryfunc)gentype_hex,		    /*nb_hex*/
        0,                               /*inplace_add*/
        0,                              /*inplace_subtract*/
        0,                              /*inplace_multiply*/
        0,                              /*inplace_divide*/
        0,                            /*inplace_remainder*/
        0,                              /*inplace_power*/
        0,                            /*inplace_lshift*/
        0,                            /*inplace_rshift*/
        0,                            /*inplace_and*/
        0,                            /*inplace_xor*/
        0,                            /*inplace_or*/
        (binaryfunc)gentype_floor_divide,	     /*nb_floor_divide*/
        (binaryfunc)gentype_true_divide,	     /*nb_true_divide*/
        0,                                         /*nb_inplace_floor_divide*/
        0,                                         /*nb_inplace_true_divide*/

};

static PyObject *
gentype_richcompare(PyObject *self, PyObject *other, int cmp_op) 
{

	PyObject *arr, *ret;

	arr = PyArray_FromScalar(self, NULL);
	if (arr == NULL) return NULL;
	ret = arr->ob_type->tp_richcompare(arr, other, cmp_op);
	Py_DECREF(arr);
	return ret;
}

static PyObject *
gentype_ndim_get(PyObject *self)
{
	return PyInt_FromLong(0);
}

static PyObject *
gentype_flags_get(PyObject *self)
{
	static int flags=CONTIGUOUS | OWNDATA | FORTRAN | ALIGNED;

        return PyObject_CallMethod(_numpy_internal, "flagsobj", "Oii", 
                                   self, flags, 1);
}

static PyObject *
voidtype_flags_get(PyVoidScalarObject *self)
{
	return PyObject_CallMethod(_numpy_internal, "flagsobj", "Oii", 
                                   self, self->flags, 1);
}

static PyObject *
voidtype_dtypedescr_get(PyVoidScalarObject *self)
{
	Py_INCREF(self->descr);
	return (PyObject *)self->descr;
}



static PyObject *
gentype_shape_get(PyObject *self)
{
	return PyTuple_New(0);
}

/*
static int
gentype_shape_set(PyObject *self, PyObject *val)
{
	if (!PyTuple_Check(val) || PyTuple_GET_SIZE(val) > 0) {
		PyErr_SetString(PyExc_ValueError, \
				"invalid shape for scalar");
		return -1;
	}
	return 0;
}
*/

static PyObject *
gentype_dataptr_get(PyObject *self)
{
	return Py_BuildValue("NO",PyString_FromString(""),Py_True);
}


static PyObject *
gentype_data_get(PyObject *self)
{
	PyArray_Descr *typecode;
	PyObject *ret;

	typecode = PyArray_DescrFromScalar(self);
	ret = PyBuffer_FromObject(self, 0, typecode->elsize);
	Py_DECREF(typecode);
	return ret;
}


static PyObject *
gentype_itemsize_get(PyObject *self)
{	
	PyArray_Descr *typecode;
	PyObject *ret;

	typecode = PyArray_DescrFromScalar(self);
	ret = PyInt_FromLong((long) typecode->elsize);
	Py_DECREF(typecode);
	return ret;
}

static PyObject *
gentype_size_get(PyObject *self)
{
	return PyInt_FromLong(1);
}

static void
gentype_struct_free(void *ptr, void *arr)
{
        Py_DECREF((PyObject *)arr);
        _pya_free(ptr);
}

static PyObject *
gentype_struct_get(PyObject *self)
{
        PyArrayObject *arr;
        PyArrayInterface *inter;
        
        arr = (PyArrayObject *)PyArray_FromScalar(self, NULL);
        inter = (PyArrayInterface *)_pya_malloc(sizeof(PyArrayInterface));
        inter->version = 2;
        inter->nd = 0;
        inter->flags = arr->flags;
        inter->typekind = arr->descr->kind;
        inter->itemsize = arr->descr->elsize;
        inter->strides = NULL;
        inter->shape = NULL;
        inter->data = arr->data;
        return PyCObject_FromVoidPtrAndDesc(inter, arr, gentype_struct_free);
}

static PyObject *
gentype_typestr_get(PyObject *self)
{
	PyArrayObject *arr;
	PyObject *ret;

	arr = (PyArrayObject *)PyArray_FromScalar(self, NULL);
	ret = PyObject_GetAttrString((PyObject *)arr->descr, "str");
	Py_DECREF(arr);
	return ret;
}

static PyObject *
gentype_descr_get(PyObject *self)
{
	PyArrayObject *arr;
	PyObject *ret;

	arr = (PyArrayObject *)PyArray_FromScalar(self, NULL);
	ret = PyObject_GetAttrString((PyObject *)arr, "__array_descr__");
	Py_DECREF(arr);
	return ret;
}


static PyObject *
gentype_typedescr_get(PyObject *self)
{
	return (PyObject *)PyArray_DescrFromScalar(self);
}


static PyObject *
gentype_base_get(PyObject *self)
{
	Py_INCREF(Py_None);
	return Py_None;
}


static PyArray_Descr *
_realdescr_fromcomplexscalar(PyObject *self, int *typenum)
{
	if PyArray_IsScalar(self, CDouble) {
		*typenum = PyArray_CDOUBLE;
		return PyArray_DescrFromType(PyArray_DOUBLE);
	}
	if PyArray_IsScalar(self, CFloat) {
		*typenum = PyArray_CFLOAT;
		return PyArray_DescrFromType(PyArray_FLOAT);
	}
	if PyArray_IsScalar(self, CLongDouble) {
		*typenum = PyArray_CLONGDOUBLE;
		return PyArray_DescrFromType(PyArray_LONGDOUBLE);
	}
	return NULL;
}

static PyObject *
gentype_real_get(PyObject *self)
{
	PyArray_Descr *typecode;
	PyObject *ret;
	int typenum;

	if (PyArray_IsScalar(self, ComplexFloating)) {
		typecode = _realdescr_fromcomplexscalar(self, &typenum);
		ret = PyArray_Scalar(_SOFFSET_(self, typenum), typecode,
				     NULL);
		Py_DECREF(typecode);
		return ret;
	}
	else if PyArray_IsScalar(self, Object) {
		PyObject *obj = ((PyObjectScalarObject *)self)->obval;
		ret = PyObject_GetAttrString(obj, "real");
		if (ret != NULL) return ret;
		PyErr_Clear();
	}
	Py_INCREF(self);
	return (PyObject *)self;
}

static PyObject *
gentype_imag_get(PyObject *self)
{	
	PyArray_Descr *typecode;
	PyObject *ret;	
	int typenum;
	
	typecode = _realdescr_fromcomplexscalar(self, &typenum);
	if (PyArray_IsScalar(self, ComplexFloating)) {
		ret = PyArray_Scalar(_SOFFSET_(self, typenum)		\
				     + typecode->elsize, typecode, NULL);
	}
	else if PyArray_IsScalar(self, Object) {
		PyObject *obj = ((PyObjectScalarObject *)self)->obval;
		PyArray_Descr *newtype;
		ret = PyObject_GetAttrString(obj, "imag");
		if (ret == NULL) {
			PyErr_Clear();
			obj = PyInt_FromLong(0);
			newtype = PyArray_DescrFromType(PyArray_OBJECT);
			ret = PyArray_Scalar((char *)&obj, newtype, NULL);
			Py_DECREF(newtype);
			Py_DECREF(obj);
		}
	}
	else {
		char *temp;
		temp = PyDataMem_NEW(typecode->elsize);
		memset(temp, '\0', typecode->elsize);
		ret = PyArray_Scalar(temp, typecode, NULL);
		PyDataMem_FREE(temp);
	}
	
	Py_DECREF(typecode);
	return ret;
}

static PyObject *
gentype_flat_get(PyObject *self)
{
	PyObject *ret, *arr;

	arr = PyArray_FromScalar(self, NULL);
	if (arr == NULL) return NULL;
	ret = PyArray_IterNew(arr);
	Py_DECREF(arr);
	return ret;
}

static PyGetSetDef gentype_getsets[] = {
        {"ndim", 
	 (getter)gentype_ndim_get, 
	 (setter) 0, 
	 "number of array dimensions"},
        {"flags", 
	 (getter)gentype_flags_get, 
	 (setter)0, 
	 "integer value of flags"},
        {"shape", 
	 (getter)gentype_shape_get, 
	 (setter)0, 
	 "tuple of array dimensions"},
        {"strides", 
	 (getter)gentype_shape_get, 
	 (setter) 0, 
	 "tuple of bytes steps in each dimension"},
        {"data",
	 (getter)gentype_data_get, 
	 (setter) 0, 
	 "pointer to start of data"},
        {"itemsize", 
	 (getter)gentype_itemsize_get, 
	 (setter)0, 
	 "length of one element in bytes"},
        {"size",
         (getter)gentype_size_get,
         (setter)0,
         "number of elements in the gentype"},
        {"nbytes",
         (getter)gentype_itemsize_get,
         (setter)0,
         "length of item in bytes"},
	{"base",
	 (getter)gentype_base_get,
	 (setter)0,
	 "base object"},
	{"dtype",
	 (getter)gentype_typedescr_get,
	 NULL,
	 "get array data-descriptor"},
        {"real", 
	 (getter)gentype_real_get, 
	 (setter)0,
	 "real part of scalar"},
        {"imag", 
	 (getter)gentype_imag_get, 
	 (setter)0, 
	 "imaginary part of scalar"},
	{"flat", 
	 (getter)gentype_flat_get, 
	 (setter)0, 
	 "a 1-d view of scalar"}, 
	{"__array_data__", 
	 (getter)gentype_dataptr_get,
	 NULL,
	 "Array protocol: data"},
	{"__array_typestr__",
	 (getter)gentype_typestr_get,
	 NULL,
	 "Array protocol: typestr"},
	{"__array_descr__",
	 (getter)gentype_descr_get,
	 NULL,
	 "Array protocol: descr"},
	{"__array_shape__", 
	 (getter)gentype_shape_get,
	 NULL,
	 "Array protocol: shape"},
	{"__array_strides__",
	 (getter)gentype_shape_get,
	 NULL,
	 "Array protocol: strides"},
        {"__array_struct__",
         (getter)gentype_struct_get,
         NULL,
         "Array protocol: struct"},
	/* Does not have __array_priority__ because it is not a subtype.
	 */
       	{NULL, NULL, NULL, NULL}  /* Sentinel */
};


/* 0-dim array from scalar object */

static char doc_getarray[] = "sc.__array__(|type) return 0-dim array";

static PyObject *
gentype_getarray(PyObject *scalar, PyObject *args) 
{
	PyArray_Descr *outcode=NULL;
	PyObject *ret;
	
	if (!PyArg_ParseTuple(args, "|O&", &PyArray_DescrConverter,
			      &outcode)) return NULL;
	ret = PyArray_FromScalar(scalar, outcode);
	return ret;
}

static char doc_sc_wraparray[] = "sc.__array_wrap__(obj) return scalar from array";

static PyObject *
gentype_wraparray(PyObject *scalar, PyObject *args)
{
	PyObject *arr;

	if (PyTuple_Size(args) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"only accepts 1 argument.");
		return NULL;
	}
	arr = PyTuple_GET_ITEM(args, 0);
	if (!PyArray_Check(arr)) {
		PyErr_SetString(PyExc_TypeError,
				"can only be called with ndarray object");
		return NULL;
	}

	return PyArray_Scalar(PyArray_DATA(arr), PyArray_DESCR(arr), arr);
}


/**begin repeat

#name=tolist, item, tostring, astype, copy, resize, __deepcopy__, choose, searchsorted, argmax, argmin, reshape, view, swapaxes, max, min, ptp, conj, conjugate, nonzero, all, any, flatten, ravel, fill, transpose, newbyteorder#
*/

static PyObject *
gentype_@name@(PyObject *self, PyObject *args)
{
	return gentype_generic_method(self, args, NULL, "@name@");
}
/**end repeat**/

static PyObject *
gentype_squeeze(PyObject *self, PyObject *args)
{
        if (!PyArg_ParseTuple(args, "")) return NULL;
	Py_INCREF(self);
	return self;
}

static int
gentype_getreadbuf(PyObject *, int, void **);

static PyObject *
gentype_byteswap(PyObject *self, PyObject *args)
{
	Bool inplace=FALSE;
	
	if (!PyArg_ParseTuple(args, "|O&", PyArray_BoolConverter, &inplace))
		return NULL;
	
	if (inplace) {
		PyErr_SetString(PyExc_ValueError, 
				"cannot byteswap a scalar in-place");
		return NULL;
	}
	else {
		/* get the data, copyswap it and pass it to a new Array scalar
		 */
		char *data;
		int numbytes;
		PyArray_Descr *descr;
		PyObject *new;
		char *newmem;

		numbytes = gentype_getreadbuf(self, 0, (void **)&data);
		descr = PyArray_DescrFromScalar(self);
		newmem = _pya_malloc(descr->elsize);
		if (newmem == NULL) {Py_DECREF(descr); return PyErr_NoMemory();}
		else memcpy(newmem, data, descr->elsize);
		descr->f->copyswap(newmem, NULL, 1, descr->elsize);
		new = PyArray_Scalar(newmem, descr, NULL);
		_pya_free(newmem);
		Py_DECREF(descr);
		return new;
	}
}


/**begin repeat

#name=take, getfield, put, putmask, repeat, tofile, mean, trace, diagonal, clip, std, var, sum, cumsum, prod, cumprod, compress, sort, argsort#
*/

static PyObject *
gentype_@name@(PyObject *self, PyObject *args, PyObject *kwds)
{
	return gentype_generic_method(self, args, kwds, "@name@");
}
/**end repeat**/

static PyObject *
voidtype_getfield(PyVoidScalarObject *self, PyObject *args, PyObject *kwds)
{
	PyObject *ret;

	ret = gentype_generic_method((PyObject *)self, args, kwds, "getfield");
	if (!ret) return ret;
	if (PyArray_IsScalar(ret, Generic) &&	\
	    (!PyArray_IsScalar(ret, Void))) {
		PyArray_Descr *new;
		if (!PyArray_ISNBO(self->descr->byteorder)) {
			new = PyArray_DescrFromScalar(ret);
			new->f->copyswap(_SOFFSET_(ret, 
						   new->type_num),
					 NULL, 1, new->elsize);
			Py_DECREF(new);
		}
	}
	return ret;
}

static PyObject *
gentype_setfield(PyObject *self, PyObject *args, PyObject *kwds)
{
	
	PyErr_SetString(PyExc_TypeError, 
			"Can't set fields in a non-void array scalar.");
	return NULL;
}	

static PyObject *
voidtype_setfield(PyVoidScalarObject *self, PyObject *args, PyObject *kwds)
{
	PyArray_Descr *typecode;
	int offset = 0;
	PyObject *value, *src;
	int mysize;
	char *dptr;
	static char *kwlist[] = {"value", "dtype", "offset", 0};/* XXX ? */
	
	if ((self->flags & WRITEABLE) != WRITEABLE) {
		PyErr_SetString(PyExc_RuntimeError,
				"Can't write to memory");
		return NULL;
	}
	if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO&|i", kwlist,
					 &value,
					 PyArray_DescrConverter, 
					 &typecode, &offset)) return NULL;

	mysize = self->ob_size;
	
	if (offset < 0 || (offset + typecode->elsize) > mysize) {
		PyErr_Format(PyExc_ValueError,
			     "Need 0 <= offset <= %d for requested type "  \
			     "but received offset = %d",
			     mysize-typecode->elsize, offset);
		Py_DECREF(typecode);
		return NULL;
	}	

	dptr = self->obval + offset;

	/* Copy data from value to correct place in dptr */
        src = PyArray_FromAny(value, typecode, 0, 0, CARRAY_FLAGS, NULL);
        if (src == NULL) return NULL;
	typecode->f->copyswap(dptr, PyArray_DATA(src), 
			      !PyArray_ISNBO(self->descr->byteorder),
			      PyArray_ITEMSIZE(src));
	Py_DECREF(src);
	Py_INCREF(Py_None);
	return Py_None;
}


static PyObject *
gentype_reduce(PyObject *self, PyObject *args)
{
	PyObject *ret=NULL, *obj=NULL, *mod=NULL;
	const char *buffer; 
	int buflen;

	/* Return a tuple of (callable object, arguments) */

	ret = PyTuple_New(2);
	if (ret == NULL) return NULL;	
	if (PyObject_AsReadBuffer(self, (const void **)&buffer, &buflen)<0) {
		Py_DECREF(ret); return NULL;
	}
	mod = PyImport_ImportModule("numpy.core.multiarray");
	if (mod == NULL) return NULL;
	obj = PyObject_GetAttrString(mod, "scalar");
	Py_DECREF(mod);
	if (obj == NULL) return NULL;
	PyTuple_SET_ITEM(ret, 0, obj);
	obj = PyObject_GetAttrString((PyObject *)self, "dtype");
	if PyArray_IsScalar(self, Object) {
		mod = ((PyObjectScalarObject *)self)->obval;
		PyTuple_SET_ITEM(ret, 1,
				 Py_BuildValue("NO", obj, mod));
	}
	else {
		mod = PyString_FromStringAndSize(buffer, buflen);
		PyTuple_SET_ITEM(ret, 1, 
				 Py_BuildValue("NN", obj, mod));
	}
	return ret;
}

/* ignores everything */
static PyObject *
gentype_setstate(PyObject *self, PyObject *args)
{
	Py_INCREF(Py_None);
	return (Py_None);
}

static PyObject *
gentype_dump(PyObject *self, PyObject *args)
{
	PyObject *file=NULL;
	int ret;

	if (!PyArg_ParseTuple(args, "O", &file))
		return NULL;
	ret = PyArray_Dump(self, file, 2);
	if (ret < 0) return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}

static PyObject *
gentype_dumps(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ""))
		return NULL;
	return PyArray_Dumps(self, 2);
}


/* setting flags cannot be done for scalars */
static PyObject *
gentype_setflags(PyObject *self, PyObject *args, PyObject *kwds)
{
	Py_INCREF(Py_None);
	return Py_None;
}


/* need to fill in doc-strings for these methods on import -- copy from 
   array docstrings 
*/
static PyMethodDef gentype_methods[] = {
        {"tolist",	 (PyCFunction)gentype_tolist,	1, NULL},
        {"item", (PyCFunction)gentype_item, METH_VARARGS, NULL},
	{"tofile", (PyCFunction)gentype_tofile, 
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"tostring", (PyCFunction)gentype_tostring, METH_VARARGS, NULL},
        {"byteswap",   (PyCFunction)gentype_byteswap,1, NULL},
        {"astype", (PyCFunction)gentype_astype, 1, NULL},
	{"getfield", (PyCFunction)gentype_getfield, 
	 METH_VARARGS | METH_KEYWORDS, NULL},
	{"setfield", (PyCFunction)gentype_setfield, 
	 METH_VARARGS | METH_KEYWORDS, NULL},
        {"copy", (PyCFunction)gentype_copy, 1, NULL},  
        {"resize", (PyCFunction)gentype_resize, 1, NULL}, 

	{"__array__", (PyCFunction)gentype_getarray, 1, doc_getarray},
	{"__array_wrap__", (PyCFunction)gentype_wraparray, 1, doc_sc_wraparray},

     /* for the copy module */
        {"__copy__", (PyCFunction)gentype_copy, 1, NULL},
        {"__deepcopy__", (PyCFunction)gentype___deepcopy__, 1, NULL},


        {"__reduce__", (PyCFunction) gentype_reduce, 1, NULL},	
	/* For consistency does nothing */
	{"__setstate__", (PyCFunction) gentype_setstate, 1, NULL},

	{"dumps", (PyCFunction) gentype_dumps, 1, NULL},
	{"dump", (PyCFunction) gentype_dump, 1, NULL},

	/* Methods for array */
	{"fill", (PyCFunction)gentype_fill,
	 METH_VARARGS, NULL},
	{"transpose",	(PyCFunction)gentype_transpose, 
	 METH_VARARGS, NULL},
	{"take",	(PyCFunction)gentype_take, 
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"put",	(PyCFunction)gentype_put, 
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"putmask",	(PyCFunction)gentype_putmask, 
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"repeat",	(PyCFunction)gentype_repeat, 
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"choose",	(PyCFunction)gentype_choose, 
	 METH_VARARGS, NULL},	
	{"sort",	(PyCFunction)gentype_sort, 
	 METH_VARARGS, NULL},
	{"argsort",	(PyCFunction)gentype_argsort, 
	 METH_VARARGS, NULL},
	{"searchsorted",  (PyCFunction)gentype_searchsorted, 
	 METH_VARARGS, NULL},	
	{"argmax",	(PyCFunction)gentype_argmax, 
	 METH_VARARGS, NULL},
	{"argmin",  (PyCFunction)gentype_argmin,
	 METH_VARARGS, NULL},
	{"reshape",	(PyCFunction)gentype_reshape, 
	 METH_VARARGS, NULL},
	{"squeeze",	(PyCFunction)gentype_squeeze, 
	 METH_VARARGS, NULL},
	{"view",  (PyCFunction)gentype_view, 
	 METH_VARARGS, NULL},
	{"swapaxes", (PyCFunction)gentype_swapaxes,
	 METH_VARARGS, NULL},
	{"max", (PyCFunction)gentype_max,
	 METH_VARARGS, NULL},
	{"min", (PyCFunction)gentype_min,
	 METH_VARARGS, NULL},
	{"ptp", (PyCFunction)gentype_ptp,
	 METH_VARARGS, NULL},
	{"mean", (PyCFunction)gentype_mean,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"trace", (PyCFunction)gentype_trace,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"diagonal", (PyCFunction)gentype_diagonal,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"clip", (PyCFunction)gentype_clip,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"conj", (PyCFunction)gentype_conj,
	 METH_VARARGS, NULL},
	{"conjugate", (PyCFunction)gentype_conjugate,
	 METH_VARARGS, NULL},
	{"nonzero", (PyCFunction)gentype_nonzero,
	 METH_VARARGS, NULL},
	{"std", (PyCFunction)gentype_std,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"var", (PyCFunction)gentype_var,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"sum", (PyCFunction)gentype_sum,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"cumsum", (PyCFunction)gentype_cumsum,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"prod", (PyCFunction)gentype_prod,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"cumprod", (PyCFunction)gentype_cumprod,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"all", (PyCFunction)gentype_all,
	 METH_VARARGS, NULL},
	{"any", (PyCFunction)gentype_any,
	 METH_VARARGS, NULL},
	{"compress", (PyCFunction)gentype_compress,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"flatten", (PyCFunction)gentype_flatten,
	 METH_VARARGS, NULL},
	{"ravel", (PyCFunction)gentype_ravel,
	 METH_VARARGS, NULL},
	{"setflags", (PyCFunction)gentype_setflags,
	 METH_VARARGS|METH_KEYWORDS, NULL},
	{"newbyteorder", (PyCFunction)gentype_newbyteorder,
	 METH_VARARGS, NULL},
        {NULL,		NULL}		/* sentinel */
};


static PyGetSetDef voidtype_getsets[] = {
        {"flags", 
	 (getter)voidtype_flags_get, 
	 (setter)0, 
	 "integer value of flags"},
	{"dtype",
	 (getter)voidtype_dtypedescr_get,
	 (setter)0,
	 "dtype object"},
	{NULL, NULL}
};

static PyMethodDef voidtype_methods[] = {
	{"getfield", (PyCFunction)voidtype_getfield, 
	 METH_VARARGS | METH_KEYWORDS, NULL},
	{"setfield", (PyCFunction)voidtype_setfield, 
	 METH_VARARGS | METH_KEYWORDS, NULL},
	{NULL, NULL}
};

/************* As_mapping functions for void array scalar ************/


static int
voidtype_length(PyVoidScalarObject *self) 
{
	if (!self->descr->fields || self->descr->fields == Py_None) {
		return 0;
	}
	else { /* return the number of fields */
		PyObject *key;
		PyObject *flist;
		key = PyInt_FromLong(-1);
		flist = PyDict_GetItem(self->descr->fields, key);
		Py_DECREF(key);
		if (!flist) return 0;
		return PyList_GET_SIZE(flist);
	}
}

/* get field by name or number */
static PyObject *
voidtype_subscript(PyVoidScalarObject *self, PyObject *ind)
{
	int n, m;
	char *msg = "invalid index";
	PyObject *flist=NULL, *key, *fieldinfo;

	if (!self->descr->fields || self->descr->fields == Py_None) {
		PyErr_SetString(PyExc_IndexError, 
				"can't index void scalar without fields");
		return NULL;
	}

	if (PyString_Check(ind) || PyUnicode_Check(ind)) {
		/* look up in fields */
		fieldinfo = PyDict_GetItem(self->descr->fields, ind);
		if (!fieldinfo) {
			PyErr_SetString(PyExc_IndexError, msg);
			return NULL;
		}
		return voidtype_getfield(self, fieldinfo, NULL);
	}
	
	/* try to convert it to a number */
	n = PyArray_PyIntAsIntp(ind);
	if (error_converting(n)) {
		PyErr_Clear();
		goto fail;
	}
	key = PyInt_FromLong(-1);
	flist = PyDict_GetItem(self->descr->fields, key);
	Py_DECREF(key);
	if (!flist) m = 0; 
	m = PyList_GET_SIZE(flist);
	if (n < 0) n += m;
	if (n < 0 || n >= m) goto fail;
	fieldinfo = PyDict_GetItem(self->descr->fields, 
				   PyList_GET_ITEM(flist, n));
	return voidtype_getfield(self, fieldinfo, NULL);

 fail:
	PyErr_SetString(PyExc_IndexError, msg);
	return NULL;
}

static int
voidtype_ass_subscript(PyVoidScalarObject *self, PyObject *ind, PyObject *val) 
{
	int n, m;
	char *msg = "invalid index";
	PyObject *flist=NULL, *key, *fieldinfo, *newtup;
	PyObject *res;

	if (!self->descr->fields || self->descr->fields == Py_None) {
		PyErr_SetString(PyExc_IndexError, 
				"can't index void scalar without fields");
		return -1;
	}

	if (PyString_Check(ind) || PyUnicode_Check(ind)) {
		/* look up in fields */
		fieldinfo = PyDict_GetItem(self->descr->fields, ind);
		if (!fieldinfo) {
			PyErr_SetString(PyExc_IndexError, msg);
			return -1;
		}
		newtup = Py_BuildValue("(OOO)", val, 
				       PyTuple_GET_ITEM(fieldinfo, 0),
				       PyTuple_GET_ITEM(fieldinfo, 1));
		res = voidtype_setfield(self, newtup, NULL);
		Py_DECREF(newtup);
		if (!res) return -1;
		Py_DECREF(res);
		return 0;
	}
	
	/* try to convert it to a number */
	n = PyArray_PyIntAsIntp(ind);
	if (error_converting(n)) {
		PyErr_Clear();
		goto fail;
	}
	key = PyInt_FromLong(-1);
	flist = PyDict_GetItem(self->descr->fields, key);
	Py_DECREF(key);
	if (!flist) m = 0; 
	m = PyList_GET_SIZE(flist);
	if (n < 0) n += m;
	if (n < 0 || n >= m) goto fail;
	fieldinfo = PyDict_GetItem(self->descr->fields, 
				   PyList_GET_ITEM(flist, n));
	newtup = Py_BuildValue("(OOO)", val, 
			       PyTuple_GET_ITEM(fieldinfo, 0),
			       PyTuple_GET_ITEM(fieldinfo, 1));
	res = voidtype_setfield(self, fieldinfo, NULL);
	Py_DECREF(newtup);
	if (!res) return -1;
	Py_DECREF(res);
	return 0;

 fail:
	PyErr_SetString(PyExc_IndexError, msg);
	return -1;
}

static PyMappingMethods voidtype_as_mapping = {
        (inquiry)voidtype_length,		        /*mp_length*/
        (binaryfunc)voidtype_subscript,	                /*mp_subscript*/
        (objobjargproc)voidtype_ass_subscript,	        /*mp_ass_subscript*/
};


static int
gentype_getreadbuf(PyObject *self, int segment, void **ptrptr)
{
	int numbytes;
	PyArray_Descr *outcode;
	
	if (segment != 0) {
		PyErr_SetString(PyExc_SystemError, 
				"Accessing non-existent array segment");
		return -1;
	}

	outcode = PyArray_DescrFromScalar(self);
	numbytes = outcode->elsize;
	if PyArray_IsScalar(self, Flexible) {
		if PyArray_IsScalar(self, String)
			*ptrptr = PyString_AS_STRING(self);
		else if PyArray_IsScalar(self, Unicode)
			*ptrptr = (char *)PyUnicode_AS_DATA(self);
		else if PyArray_IsScalar(self, Void)
			*ptrptr = ((PyVoidScalarObject *)self)->obval;
	}
	else 
		*ptrptr = (void *)_SOFFSET_(self, outcode->type_num);

	Py_DECREF(outcode);
	return numbytes;
}

static int
gentype_getsegcount(PyObject *self, int *lenp)
{
	PyArray_Descr *outcode;

	outcode = PyArray_DescrFromScalar(self);
	if (lenp)
		*lenp = outcode->elsize;
	Py_DECREF(outcode);
	return 1;
}

static int
gentype_getcharbuf(PyObject *self, int segment, const char **ptrptr)
{
	if (PyArray_IsScalar(self, String) ||	\
	    PyArray_IsScalar(self, Unicode))
		return gentype_getreadbuf(self, segment, (void **)ptrptr);
	else {
		PyErr_SetString(PyExc_TypeError,
				"Non-character array cannot be interpreted "\
				"as character buffer.");
		return -1;
	}
}


static PyBufferProcs gentype_as_buffer = {
        (getreadbufferproc)gentype_getreadbuf,    /*bf_getreadbuffer*/
        (getwritebufferproc)0,                    /*bf_getwritebuffer*/
        (getsegcountproc)gentype_getsegcount,	  /*bf_getsegcount*/
        (getcharbufferproc)gentype_getcharbuf,      /*bf_getcharbuffer*/
};


#define BASEFLAGS Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES
#define LEAFFLAGS  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES

static PyTypeObject PyGenericArrType_Type = { 
        PyObject_HEAD_INIT(NULL)
        0,					  /*ob_size*/
        "generic_arrtype",	          /*tp_name*/
        sizeof(PyObject),		          /*tp_basicsize*/
};

static void
unicode_dealloc(PyObject *v) 
{
	PyDataMem_FREE(((PyVoidScalarObject *)v)->obval);
	v->ob_type->tp_free(v);
}

static void
void_dealloc(PyVoidScalarObject *v) 
{
	if (v->flags & OWNDATA)
		PyDataMem_FREE(v->obval);
	Py_XDECREF(v->descr);
	Py_XDECREF(v->base);
	v->ob_type->tp_free(v);
}

static void
object_arrtype_dealloc(PyObject *v)
{
	Py_XDECREF(((PyObjectScalarObject *)v)->obval);
	v->ob_type->tp_free(v);
}

/* string and unicode inherit from Python Type first and so GET_ITEM is different to
   get to the Python Type.
 */

/**begin repeat 
#name=byte, short, int, long, longlong, ubyte, ushort, uint, ulong, ulonglong, float, double, longdouble, cfloat, cdouble, clongdouble, string, unicode, object#
#TYPE=BYTE, SHORT, INT, LONG, LONGLONG, UBYTE, USHORT, UINT, ULONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, CFLOAT, CDOUBLE, CLONGDOUBLE, STRING, UNICODE, OBJECT#
#num=1*16,0,0,1#
*/
static PyObject *
@name@_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	PyObject *obj=NULL;
	PyObject *arr;
	PyArray_Descr *typecode;

	if (type->tp_bases && (PyTuple_GET_SIZE(type->tp_bases)==2)) {
		PyTypeObject *sup;
		PyObject *ret;
		/* We are inheriting from a Python type as well so
		   give it first dibs on conversion */
		sup = (PyTypeObject *)PyTuple_GET_ITEM(type->tp_bases, @num@);
		ret = sup->tp_new(type, args, kwds);
		if (ret) return ret;
		PyErr_Clear();
		/* now do default conversion */
	}

	if (!PyArg_ParseTuple(args, "O", &obj)) return NULL;

	typecode = PyArray_DescrFromType(PyArray_@TYPE@);
	arr = PyArray_FromAny(obj, typecode, 0, 0, FORCECAST, NULL);
	return PyArray_Return((PyArrayObject *)arr);
}
/**end repeat**/

/* bool->tp_new only returns Py_True or Py_False */
static PyObject *
bool_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	PyObject *obj=NULL;
	PyObject *arr;

	if (!PyArg_ParseTuple(args, "O", &obj)) return NULL;
	if (obj == Py_False)
		PyArrayScalar_RETURN_FALSE;
	if (obj == Py_True)
		PyArrayScalar_RETURN_TRUE;
	arr = PyArray_FROM_OTF(obj, PyArray_BOOL, FORCECAST);
	if (arr && 0 == PyArray_NDIM(arr)) {
		PyArrayScalar_RETURN_BOOL_FROM_LONG(*(Bool*)PyArray_DATA(arr));
	}
	return PyArray_Return((PyArrayObject *)arr);
}

static PyObject *
void_arrtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	PyObject *obj, *arr;
	ulonglong memu=1;
	PyObject *new=NULL;
	char *destptr;

	if (!PyArg_ParseTuple(args, "O", &obj)) return NULL;
	/* For a VOID scalar first see if obj is an integer or long 
	    and create new memory of that size (filled with 0) for the scalar
	*/

	if (PyLong_Check(obj) || PyInt_Check(obj) || \
	    PyArray_IsScalar(obj, Integer) ||
	    (PyArray_Check(obj) && PyArray_NDIM(obj)==0 &&	\
	     PyArray_ISINTEGER(obj))) {
		new = obj->ob_type->tp_as_number->nb_long(obj);
	}
	if (new && PyLong_Check(new)) {
		PyObject *ret;
		memu = PyLong_AsUnsignedLongLong(new);
		Py_DECREF(new);
		if (PyErr_Occurred() || (memu > MAX_INT)) {
			PyErr_Clear();
			PyErr_Format(PyExc_OverflowError, 
				     "size must be smaller than %d",
				     (int) MAX_INT);
			return NULL;
		}
		destptr = PyDataMem_NEW((int) memu);
		if (destptr == NULL) return PyErr_NoMemory();
		ret = type->tp_alloc(type, 0);
		if (ret == NULL) {
			PyDataMem_FREE(destptr);
			return PyErr_NoMemory();
		}
		((PyVoidScalarObject *)ret)->obval = destptr;
		((PyVoidScalarObject *)ret)->ob_size = (int) memu;
		((PyVoidScalarObject *)ret)->descr = \
			PyArray_DescrNewFromType(PyArray_VOID);
		((PyVoidScalarObject *)ret)->descr->elsize = (int) memu;
		((PyVoidScalarObject *)ret)->flags = BEHAVED_FLAGS | OWNDATA;
		((PyVoidScalarObject *)ret)->base = NULL;
		memset(destptr, '\0', (size_t) memu);
		return ret;
	}

	arr = PyArray_FROM_OTF(obj, PyArray_VOID, FORCECAST);
        return PyArray_Return((PyArrayObject *)arr);
}


/****************  Define Hash functions ********************/

/**begin repeat
#lname=bool,ubyte,ushort#
#name=Bool,UByte, UShort#
 */
static long
@lname@_arrtype_hash(PyObject *obj)
{
        return (long)(((Py@name@ScalarObject *)obj)->obval);
}
/**end repeat**/

/**begin repeat
#lname=byte,short,uint,ulong#
#name=Byte,Short,UInt,ULong#
 */
static long
@lname@_arrtype_hash(PyObject *obj)
{
        long x = (long)(((Py@name@ScalarObject *)obj)->obval);
        if (x == -1) x=-2;
        return x;
}
/**end repeat**/

#if SIZEOF_INT != SIZEOF_LONG
static long
int_arrtype_hash(PyObject *obj)
{
        long x = (long)(((PyIntScalarObject *)obj)->obval);
        if (x == -1) x=-2;
        return x;
}
#endif

/**begin repeat
#char=,u#
#Char=,U#
#ext=&& (x >= LONG_MIN),#
*/
#if SIZEOF_LONG != SIZEOF_LONGLONG
/* we assume SIZEOF_LONGLONG=2*SIZEOF_LONG */
static long
@char@longlong_arrtype_hash(PyObject *obj)
{
        long y;
        @char@longlong x = (((Py@Char@LongLongScalarObject *)obj)->obval);

        if ((x <= LONG_MAX)@ext@) {
                y = (long) x;
        }
        else {
                union Mask {
                        long hashvals[2];
                        @char@longlong v;
                } both;

                both.v = x;
                y = both.hashvals[0] + (1000003)*both.hashvals[1];
        }
        if (y == -1) y = -2;
        return y;
}
#endif
/**end repeat**/

#if SIZEOF_LONG==SIZEOF_LONGLONG
static long
ulonglong_arrtype_hash(PyObject *obj)
{
        long x = (long)(((PyULongLongScalarObject *)obj)->obval);
        if (x == -1) x=-2;
        return x;
}
#endif



/* Wrong thing to do for longdouble, but....*/
/**begin repeat
#lname=float, longdouble#
#name=Float, LongDouble#
 */
static long
@lname@_arrtype_hash(PyObject *obj)
{
        return _Py_HashDouble((double) ((Py@name@ScalarObject *)obj)->obval);
}

/* borrowed from complex_hash */
static long
c@lname@_arrtype_hash(PyObject *obj)
{
        long hashreal, hashimag, combined;
        hashreal = _Py_HashDouble((double)                              \
                                  (((PyC@name@ScalarObject *)obj)->obval).real);

        if (hashreal == -1) return -1;
        hashimag = _Py_HashDouble((double)                              \
                                  (((PyC@name@ScalarObject *)obj)->obval).imag);
        if (hashimag == -1) return -1;

        combined = hashreal + 1000003 * hashimag;
        if (combined == -1) combined = -2;
        return combined;
}
/**end repeat**/

static long
object_arrtype_hash(PyObject *obj)
{
        return PyObject_Hash(((PyObjectScalarObject *)obj)->obval);
}

/* just hash the pointer */
static long
void_arrtype_hash(PyObject *obj)
{
        return _Py_HashPointer((void *)(((PyVoidScalarObject *)obj)->obval));
}

/*object arrtype getattro and setattro */
static PyObject *
object_arrtype_getattro(PyObjectScalarObject *obj, PyObject *attr) {
	PyObject *res;

	/* first look in object and then hand off to generic type */

	res = PyObject_GenericGetAttr(obj->obval, attr);	
	if (res) return res;
	PyErr_Clear();
	return 	PyObject_GenericGetAttr((PyObject *)obj, attr);
}

static int
object_arrtype_setattro(PyObjectScalarObject *obj, PyObject *attr, PyObject *val) {
	int res;
	/* first look in object and then hand off to generic type */

	res = PyObject_GenericSetAttr(obj->obval, attr, val);
	if (res >= 0) return res;
	PyErr_Clear();
	return PyObject_GenericSetAttr((PyObject *)obj, attr, val);
}

static int 
object_arrtype_length(PyObjectScalarObject *self) 
{
	return PyObject_Length(self->obval);
}

static PyObject *
object_arrtype_concat(PyObjectScalarObject *self, PyObject *other)
{
	return PySequence_Concat(self->obval, other);
}

static PyObject *
object_arrtype_repeat(PyObjectScalarObject *self, int count)
{
	return PySequence_Repeat(self->obval, count);
}

static PyObject *
object_arrtype_subscript(PyObjectScalarObject *self, PyObject *key)
{
	return PyObject_GetItem(self->obval, key);
}

static int
object_arrtype_ass_subscript(PyObjectScalarObject *self, PyObject *key, 
			     PyObject *value)
{
	return PyObject_SetItem(self->obval, key, value);
}

static int
object_arrtype_contains(PyObjectScalarObject *self, PyObject *ob)
{
	return PySequence_Contains(self->obval, ob);
}

static PyObject *
object_arrtype_inplace_concat(PyObjectScalarObject *self, PyObject *o)
{
	return PySequence_InPlaceConcat(self->obval, o);
}

static PyObject *
object_arrtype_inplace_repeat(PyObjectScalarObject *self, int count)
{
	return PySequence_InPlaceRepeat(self->obval, count);
}

static PySequenceMethods object_arrtype_as_sequence = {
        (inquiry)object_arrtype_length, /*sq_length*/
        (binaryfunc)object_arrtype_concat, /*sq_concat*/
        (intargfunc)object_arrtype_repeat, /*sq_repeat*/
        0,                                  /*sq_item*/
        0,                                  /*sq_slice*/
        0,                                   /* sq_ass_item */
        0,                                   /* sq_ass_slice */
        (objobjproc)object_arrtype_contains,              /* sq_contains */
        (binaryfunc)object_arrtype_inplace_concat,        /* sq_inplace_concat */
        (intargfunc)object_arrtype_inplace_repeat,        /* sq_inplace_repeat */
};

static PyMappingMethods object_arrtype_as_mapping = {
        (inquiry)object_arrtype_length,
        (binaryfunc)object_arrtype_subscript,
        (objobjargproc)object_arrtype_ass_subscript,
};

static int 
object_arrtype_getsegcount(PyObjectScalarObject *self, int *lenp) 
{
	int newlen;
	int cnt;
	PyBufferProcs *pb = self->obval->ob_type->tp_as_buffer;
	
	if (pb == NULL || \
	    pb->bf_getsegcount == NULL || \
	    (cnt = (*pb->bf_getsegcount)(self->obval, &newlen)) != 1) 
		return 0;
	
	if (lenp) 
		*lenp = newlen;
	
	return cnt;
}

static int 
object_arrtype_getreadbuf(PyObjectScalarObject *self, int segment, void **ptrptr) 
{
	PyBufferProcs *pb = self->obval->ob_type->tp_as_buffer;

	if (pb == NULL || \
	    pb->bf_getreadbuffer == NULL ||
	    pb->bf_getsegcount == NULL) {
		PyErr_SetString(PyExc_TypeError, 
				"expected a readable buffer object");
		return -1;
	}
	
	return (*pb->bf_getreadbuffer)(self->obval, segment, ptrptr);
}

static int 
object_arrtype_getwritebuf(PyObjectScalarObject *self, int segment, void **ptrptr) 
{
	PyBufferProcs *pb = self->obval->ob_type->tp_as_buffer;

	if (pb == NULL || \
	    pb->bf_getwritebuffer == NULL ||
	    pb->bf_getsegcount == NULL) {
		PyErr_SetString(PyExc_TypeError, 
				"expected a writeable buffer object");
		return -1;
	}
	
	return (*pb->bf_getwritebuffer)(self->obval, segment, ptrptr);
}

static int 
object_arrtype_getcharbuf(PyObjectScalarObject *self, int segment, 
			  const char **ptrptr) 
{
	PyBufferProcs *pb = self->obval->ob_type->tp_as_buffer;

	if (pb == NULL || \
	    pb->bf_getcharbuffer == NULL ||
	    pb->bf_getsegcount == NULL) {
		PyErr_SetString(PyExc_TypeError, 
				"expected a character buffer object");
		return -1;
	}
	
	return (*pb->bf_getcharbuffer)(self->obval, segment, ptrptr);
}

static PyBufferProcs object_arrtype_as_buffer = {
        (getreadbufferproc)object_arrtype_getreadbuf,
        (getwritebufferproc)object_arrtype_getwritebuf,
        (getsegcountproc)object_arrtype_getsegcount,
        (getcharbufferproc)object_arrtype_getcharbuf,
};

static PyObject *
object_arrtype_call(PyObjectScalarObject *obj, PyObject *args, PyObject *kwds)
{
	return PyObject_Call(obj->obval, args, kwds);
}

static PyTypeObject PyObjectArrType_Type = {
        PyObject_HEAD_INIT(NULL)
        0,					  /*ob_size*/
        "object_arrtype",	                  /*tp_name*/
        sizeof(PyObjectScalarObject),	          /*tp_basicsize*/
        0,                                        /* tp_itemsize */
        (destructor)object_arrtype_dealloc,       /* tp_dealloc */
        0,                                        /* tp_print */
        0,                                        /* tp_getattr */
        0,                                        /* tp_setattr */
        0,                                        /* tp_compare */
        0,                                        /* tp_repr */
        0,                                        /* tp_as_number */
        &object_arrtype_as_sequence,              /* tp_as_sequence */
        &object_arrtype_as_mapping,               /* tp_as_mapping */
        0,                                        /* tp_hash */
        (ternaryfunc)object_arrtype_call,         /* tp_call */
        0,                                        /* tp_str */
        (getattrofunc)object_arrtype_getattro,     /* tp_getattro */
        (setattrofunc)object_arrtype_setattro,     /* tp_setattro */
        &object_arrtype_as_buffer,                /* tp_as_buffer */
        0,                                        /* tp_flags */
};

/**begin repeat
#name=bool, string, unicode, void#
#NAME=Bool, String, Unicode, Void#
*/
static PyTypeObject Py@NAME@ArrType_Type = { 
        PyObject_HEAD_INIT(NULL)
        0,					  /*ob_size*/
        "@name@_arrtype",	                  /*tp_name*/
        sizeof(Py@NAME@ScalarObject),	          /*tp_basicsize*/
};
/**end repeat**/

/**begin repeat
#NAME=Byte, Short, Int, Long, LongLong, UByte, UShort, UInt, ULong, ULongLong, Float, Double, LongDouble, CFloat, CDouble, CLongDouble#
#name=int*5, uint*5, float*3, complex*3#
#CNAME=(CHAR, SHORT, INT, LONG, LONGLONG)*2, FLOAT, DOUBLE, LONGDOUBLE, CFLOAT, CDOUBLE, CLONGDOUBLE#
*/
static PyTypeObject Py@NAME@ArrType_Type = { 
        PyObject_HEAD_INIT(NULL)
        0,					  /*ob_size*/
        "@name@" STRBITSOF_@CNAME@ "_arrtype",	  /*tp_name*/
        sizeof(Py@NAME@ScalarObject),	          /*tp_basicsize*/
};

/**end repeat**/


static PyNumberMethods longdoubletype_as_number;
static PyNumberMethods clongdoubletype_as_number;


static void
initialize_numeric_types(void)
{
	PyGenericArrType_Type.tp_dealloc = (destructor)gentype_dealloc;
	PyGenericArrType_Type.tp_as_number = &gentype_as_number;
	PyGenericArrType_Type.tp_as_buffer = &gentype_as_buffer;
	PyGenericArrType_Type.tp_flags = BASEFLAGS;
	PyGenericArrType_Type.tp_methods = gentype_methods;
	PyGenericArrType_Type.tp_getset = gentype_getsets;
	PyGenericArrType_Type.tp_new = NULL;
        PyGenericArrType_Type.tp_alloc = gentype_alloc;
	PyGenericArrType_Type.tp_free = _pya_free;
	PyGenericArrType_Type.tp_repr = gentype_repr;
	PyGenericArrType_Type.tp_str = gentype_str;
	PyGenericArrType_Type.tp_richcompare = gentype_richcompare;

	PyStringArrType_Type.tp_alloc = NULL;
	PyStringArrType_Type.tp_free = NULL;

	PyVoidArrType_Type.tp_methods = voidtype_methods;
	PyVoidArrType_Type.tp_getset = voidtype_getsets;
	PyVoidArrType_Type.tp_as_mapping = &voidtype_as_mapping;
	
	/**begin repeat
#NAME=Number, Integer, SignedInteger, UnsignedInteger, Inexact, Floating, 
ComplexFloating, Flexible, Character#
	*/
        Py@NAME@ArrType_Type.tp_flags = BASEFLAGS;
	/**end repeat**/

	/**begin repeat
#name=bool, byte, short, int, long, longlong, ubyte, ushort, uint, ulong, ulonglong, float, double, longdouble, cfloat, cdouble, clongdouble, string, unicode, void, object#
#NAME=Bool, Byte, Short, Int, Long, LongLong, UByte, UShort, UInt, ULong, ULongLong, Float, Double, LongDouble, CFloat, CDouble, CLongDouble, String, Unicode, Void, Object#
	*/
	Py@NAME@ArrType_Type.tp_flags = LEAFFLAGS;
	Py@NAME@ArrType_Type.tp_new = @name@_arrtype_new;
	Py@NAME@ArrType_Type.tp_richcompare = gentype_richcompare;
	/**end repeat**/
	/* Allow the Void type to be subclassed -- for adding new types */
	PyVoidArrType_Type.tp_flags = BASEFLAGS;

        /**begin repeat
#name=bool, byte, short, ubyte, ushort, uint, ulong, ulonglong, float, longdouble, cfloat, clongdouble, void, object#
#NAME=Bool, Byte, Short, UByte, UShort, UInt, ULong, ULongLong, Float, LongDouble, CFloat, CLongDouble, Void, Object#
        */
        Py@NAME@ArrType_Type.tp_hash = @name@_arrtype_hash;
        /**end repeat**/

#if SIZEOF_INT != SIZEOF_LONG
        /* We won't be inheriting from Python Int type. */
        PyIntArrType_Type.tp_hash = int_arrtype_hash;
#endif

#if SIZEOF_LONG != SIZEOF_LONGLONG
        /* We won't be inheriting from Python Int type. */
        PyLongLongArrType_Type.tp_hash = longlong_arrtype_hash;
#endif

	/* These need to be coded specially because getitem does not
	   return a normal Python type
	*/
	PyLongDoubleArrType_Type.tp_as_number = &longdoubletype_as_number;
	PyCLongDoubleArrType_Type.tp_as_number = &clongdoubletype_as_number;

	/**begin repeat
#name=int, long, hex, oct, float, repr, str#
#kind=tp_as_number->nb*5, tp*2#
	*/
	PyLongDoubleArrType_Type.@kind@_@name@ = longdoubletype_@name@;
	PyCLongDoubleArrType_Type.@kind@_@name@ = clongdoubletype_@name@;
	/**end repeat**/

	PyStringArrType_Type.tp_itemsize = sizeof(char);
	PyVoidArrType_Type.tp_dealloc = (destructor) void_dealloc;
	PyUnicodeArrType_Type.tp_dealloc = unicode_dealloc;

	PyArrayIter_Type.tp_iter = PyObject_SelfIter;
	PyArrayMapIter_Type.tp_iter = PyObject_SelfIter;

/**begin repeat
#name=Bool, Byte, Short, Int, Long, LongLong, UByte, UShort, UInt, ULong, ULongLong, Float, Double, LongDouble,  CFloat, CDouble, CLongDouble, Object,#
#num=BOOL, BYTE, SHORT, INT, LONG, LONGLONG, UBYTE, USHORT, UINT, ULONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, CFLOAT, CDOUBLE, CLONGDOUBLE, OBJECT, NTYPES#
**/
        PyArrayScalar_Offset[PyArray_@num@] = (int) offsetof(Py@name@ScalarObject, obval);
/**end repeat**/
}


/* the order of this table is important */
static PyTypeObject *typeobjects[] = {
        &PyBoolArrType_Type,
        &PyByteArrType_Type,
	&PyUByteArrType_Type,
        &PyShortArrType_Type,
        &PyUShortArrType_Type,
	&PyIntArrType_Type,
	&PyUIntArrType_Type,
	&PyLongArrType_Type,
	&PyULongArrType_Type,
	&PyLongLongArrType_Type,
	&PyULongLongArrType_Type,
	&PyFloatArrType_Type,
	&PyDoubleArrType_Type,
	&PyLongDoubleArrType_Type,
	&PyCFloatArrType_Type,
	&PyCDoubleArrType_Type,
	&PyCLongDoubleArrType_Type,
	&PyObjectArrType_Type,
	&PyStringArrType_Type,
	&PyUnicodeArrType_Type,
	&PyVoidArrType_Type
};

static int
_typenum_fromtypeobj(PyObject *type, int user)
{
	int typenum, i;

	typenum = PyArray_NOTYPE;
        i = 0;
	while(i < PyArray_NTYPES) {
		if (type == (PyObject *)typeobjects[i]) {
			typenum = i;
			break;
		}
                i++;
	}
	
	if (!user) return typenum;

	/* Search any registered types */
	i = 0;
	while (i < PyArray_NUMUSERTYPES) {
		if (type == (PyObject *)(userdescrs[i]->typeobj)) {
			typenum = i + PyArray_USERDEF;
			break;
		}
		i++;
	}
	return typenum;
}

/* new reference */
static PyArray_Descr *
PyArray_DescrFromTypeObject(PyObject *type)
{	
	int typenum;
	PyArray_Descr *new, *conv=NULL;

	/* if it's a builtin type, then use the typenumber */
	typenum = _typenum_fromtypeobj(type,1);	
	if (typenum != PyArray_NOTYPE) {
		new = PyArray_DescrFromType(typenum);
		if (PyTypeNum_ISUSERDEF(typenum)) goto finish;
		return new;
	}

	/* Check the generic types */
	if ((type == (PyObject *) &PyNumberArrType_Type) ||		\
	    (type == (PyObject *) &PyInexactArrType_Type) ||		\
	    (type == (PyObject *) &PyFloatingArrType_Type))
		typenum = PyArray_DOUBLE;
	else if (type == (PyObject *)&PyComplexFloatingArrType_Type)
		typenum = PyArray_CDOUBLE;
	else if ((type == (PyObject *)&PyIntegerArrType_Type) ||	\
		 (type == (PyObject *)&PySignedIntegerArrType_Type))
		typenum = PyArray_LONG;
	else if (type == (PyObject *) &PyUnsignedIntegerArrType_Type)
		typenum = PyArray_ULONG;
	else if (type == (PyObject *) &PyCharacterArrType_Type)
		typenum = PyArray_STRING;
	else if ((type == (PyObject *) &PyGenericArrType_Type) || \
		 (type == (PyObject *) &PyFlexibleArrType_Type))
		typenum = PyArray_VOID;

	if (typenum != PyArray_NOTYPE) {
		return PyArray_DescrFromType(typenum);
	}
	
	/* Otherwise --- type is a sub-type of an array scalar
	   currently only VOID allows it -- use it as the type-object.
	*/
	/* look for a dtypedescr attribute */
	new = PyArray_DescrNewFromType(PyArray_VOID);

 finish:
	conv = _arraydescr_fromobj(type);
	if (conv) {
		new->fields = conv->fields;
		Py_INCREF(new->fields);
		new->elsize = conv->elsize;
		new->subarray = conv->subarray;
		conv->subarray = NULL;
		Py_DECREF(conv);
	}
        Py_DECREF(new->typeobj);
        new->typeobj = (PyTypeObject *)type;
        Py_INCREF(type);
	return new;
}

/* New reference */
/*OBJECT_API
 Return descr object from array scalar.
*/
static PyArray_Descr *
PyArray_DescrFromScalar(PyObject *sc)
{
	int type_num;
	PyArray_Descr *descr;

	if PyArray_IsScalar(sc, Void) {
		descr = ((PyVoidScalarObject *)sc)->descr;
		Py_INCREF(descr);
		return descr;
	}
        descr = PyArray_DescrFromTypeObject((PyObject *)sc->ob_type);
        if (descr->elsize == 0) {
		PyArray_DESCR_REPLACE(descr);
                type_num = descr->type_num;
		if (type_num == PyArray_STRING) 
			descr->elsize = PyString_GET_SIZE(sc);
		else if (type_num == PyArray_UNICODE)
			descr->elsize = PyUnicode_GET_DATA_SIZE(sc);
		else {
			descr->elsize =					\
				((PyVoidScalarObject *)sc)->ob_size;
			descr->fields = PyObject_GetAttrString(sc, "fields");
			if (!descr->fields || !PyDict_Check(descr->fields) || \
			    (descr->fields == Py_None)) {
				Py_XDECREF(descr->fields);
				descr->fields = NULL;
			}
			PyErr_Clear();
		}
        }
	return descr;
}

/* New reference */
/*OBJECT_API
 Get a typeobject from a type-number
*/
static PyObject *
PyArray_TypeObjectFromType(int type)
{
	PyArray_Descr *descr;
	PyObject *obj;

	descr = PyArray_DescrFromType(type);
	if (descr == NULL) return NULL;
	Py_INCREF((PyObject *)descr->typeobj);
	obj = (PyObject *)descr->typeobj;
	Py_DECREF(descr);
	return obj;
}

