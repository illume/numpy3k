
/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/*
 * vim:syntax=c
 * A small module to implement missing C99 math capabilities required by numpy
 *
 * Please keep this independant of python !
 */

/*
 *****************************************************************************
 **                     BASIC MATH FUNCTIONS                                **
 *****************************************************************************
 */

/* Original code by Konrad Hinsen.  */
#ifndef HAVE_EXPM1
double expm1(double x)
{
    double u = exp(x);
    if (u == 1.0) {
        return x;
    } else if (u-1.0 == -1.0) {
        return -1;
    } else {
        return (u-1.0) * x/log(u);
    }
}
#endif

#ifndef HAVE_LOG1P
double log1p(double x)
{
    double u = 1. + x;
    if (u == 1.0) {
        return x;
    } else {
        return log(u) * x / (u-1.);
    }
}
#endif

#ifndef HAVE_HYPOT
double hypot(double x, double y)
{
    double yx;

    x = fabs(x);
    y = fabs(y);
    if (x < y) {
        double temp = x;
        x = y;
        y = temp;
    }
    if (x == 0.)
        return 0.;
    else {
        yx = y/x;
        return x*sqrt(1.+yx*yx);
    }
}
#endif

#ifndef HAVE_ACOSH
double acosh(double x)
{
    return 2*log(sqrt((x+1.0)/2)+sqrt((x-1.0)/2));
}
#endif

#ifndef HAVE_ASINH
double asinh(double xx)
{
    double x, d;
    int sign;
    if (xx < 0.0) {
        sign = -1;
        x = -xx;
    }
    else {
        sign = 1;
        x = xx;
    }
    if (x > 1e8) {
        d = x;
    } else {
        d = sqrt(x*x + 1);
    }
    return sign*log1p(x*(1.0 + x/(d+1)));
}
#endif

#ifndef HAVE_ATANH
static double atanh(double x)
{
    return 0.5*log1p(2.0*x/(1.0-x));
}
#endif

#ifndef HAVE_RINT
double rint(double x)
{
    double y, r;

    y = floor(x);
    r = x - y;

    if (r > 0.5) goto rndup;

    /* Round to nearest even */
    if (r==0.5) {
        r = y - 2.0*floor(0.5*y);
        if (r==1.0) {
        rndup:
            y+=1.0;
        }
    }
    return y;
}
#endif

#ifndef HAVE_TRUNC
double trunc(double x)
{
    if (x < 0) {
        return ceil(x);
    }
    else {
        return floor(x);
    }

}
#endif

/*
 *****************************************************************************
 **                     IEEE 754 FPU HANDLING                               **
 *****************************************************************************
 */
#if !defined(HAVE_DECL_ISNAN)
    # define isnan(x) \
              (sizeof (x) == sizeof (long double) ? isnan_ld (x) \
               : sizeof (x) == sizeof (double) ? isnan_d (x) \
               : isnan_f (x))
static int isnan_f  (float x) 
{ 
    return x != x; 
}

static int isnan_d  (double x) 
{ 
    return x != x; 
}

static int isnan_ld  (long double x) 
{ 
    return x != x; 
}
 
#if !defined(HAVE_DECL_ISINF)
    # define isinf(x) \
              (sizeof (x) == sizeof (long double) ? isinf_ld (x) \
               : sizeof (x) == sizeof (double) ? isinf_d (x) \
               : isinf_f (x))

static int isinf_f (float x) 
{ 
    return isnan (x - x); 
}

static int isinf_d (double x) 
{ 
    return isnan (x - x); 
}

static int isinf_ld (long double x) 
{ 
    return isnan (x - x);
}

#if !defined(HAVE_DECL_SIGNBIT)
    #include "_signbit.c"
    # define signbit(x) \
              (sizeof (x) == sizeof (long double) ? signbit_ld (x) \
               : sizeof (x) == sizeof (double) ? signbit_d (x) \
               : signbit_f (x))

static int signbit_f (float x) 
{ 
    return signbit_d((double)x); 
}

static int signbit_ld (long double x) 
{ 
    return signbit_d((double)x); 
}

/* Define isfinie if needed */
#if !defined(HAVE_DECL_ISFINITE)
#define isfinite(x) (!(isinf((x)) || isnan((x))))
#endif

/*
 * if C99 extensions not available then define dummy functions that use the
 * double versions for
 *
 * sin, cos, tan
 * sinh, cosh, tanh,
 * fabs, floor, ceil, rint, trunc
 * sqrt, log10, log, exp, expm1
 * asin, acos, atan,
 * asinh, acosh, atanh
 *
 * hypot, atan2, pow, fmod, modf
 *
 * We assume the above are always available in their double versions.
 */

/*
 * One value argument function
 */

#line 230

#ifndef HAVE_SINL
longdouble sinl(longdouble x)
{
    return (longdouble) sin((double)x);
}
#endif

#line 230

#ifndef HAVE_COSL
longdouble cosl(longdouble x)
{
    return (longdouble) cos((double)x);
}
#endif

#line 230

#ifndef HAVE_TANL
longdouble tanl(longdouble x)
{
    return (longdouble) tan((double)x);
}
#endif

#line 230

#ifndef HAVE_SINHL
longdouble sinhl(longdouble x)
{
    return (longdouble) sinh((double)x);
}
#endif

#line 230

#ifndef HAVE_COSHL
longdouble coshl(longdouble x)
{
    return (longdouble) cosh((double)x);
}
#endif

#line 230

#ifndef HAVE_TANHL
longdouble tanhl(longdouble x)
{
    return (longdouble) tanh((double)x);
}
#endif

#line 230

#ifndef HAVE_FABSL
longdouble fabsl(longdouble x)
{
    return (longdouble) fabs((double)x);
}
#endif

#line 230

#ifndef HAVE_FLOORL
longdouble floorl(longdouble x)
{
    return (longdouble) floor((double)x);
}
#endif

#line 230

#ifndef HAVE_CEILL
longdouble ceill(longdouble x)
{
    return (longdouble) ceil((double)x);
}
#endif

#line 230

#ifndef HAVE_RINTL
longdouble rintl(longdouble x)
{
    return (longdouble) rint((double)x);
}
#endif

#line 230

#ifndef HAVE_TRUNCL
longdouble truncl(longdouble x)
{
    return (longdouble) trunc((double)x);
}
#endif

#line 230

#ifndef HAVE_SQRTL
longdouble sqrtl(longdouble x)
{
    return (longdouble) sqrt((double)x);
}
#endif

#line 230

#ifndef HAVE_LOG10L
longdouble log10l(longdouble x)
{
    return (longdouble) log10((double)x);
}
#endif

#line 230

#ifndef HAVE_LOGL
longdouble logl(longdouble x)
{
    return (longdouble) log((double)x);
}
#endif

#line 230

#ifndef HAVE_EXPL
longdouble expl(longdouble x)
{
    return (longdouble) exp((double)x);
}
#endif

#line 230

#ifndef HAVE_EXPM1L
longdouble expm1l(longdouble x)
{
    return (longdouble) expm1((double)x);
}
#endif

#line 230

#ifndef HAVE_ASINL
longdouble asinl(longdouble x)
{
    return (longdouble) asin((double)x);
}
#endif

#line 230

#ifndef HAVE_ACOSL
longdouble acosl(longdouble x)
{
    return (longdouble) acos((double)x);
}
#endif

#line 230

#ifndef HAVE_ATANL
longdouble atanl(longdouble x)
{
    return (longdouble) atan((double)x);
}
#endif

#line 230

#ifndef HAVE_ASINHL
longdouble asinhl(longdouble x)
{
    return (longdouble) asinh((double)x);
}
#endif

#line 230

#ifndef HAVE_ACOSHL
longdouble acoshl(longdouble x)
{
    return (longdouble) acosh((double)x);
}
#endif

#line 230

#ifndef HAVE_ATANHL
longdouble atanhl(longdouble x)
{
    return (longdouble) atanh((double)x);
}
#endif

#line 230

#ifndef HAVE_SINF
float sinf(float x)
{
    return (float) sin((double)x);
}
#endif

#line 230

#ifndef HAVE_COSF
float cosf(float x)
{
    return (float) cos((double)x);
}
#endif

#line 230

#ifndef HAVE_TANF
float tanf(float x)
{
    return (float) tan((double)x);
}
#endif

#line 230

#ifndef HAVE_SINHF
float sinhf(float x)
{
    return (float) sinh((double)x);
}
#endif

#line 230

#ifndef HAVE_COSHF
float coshf(float x)
{
    return (float) cosh((double)x);
}
#endif

#line 230

#ifndef HAVE_TANHF
float tanhf(float x)
{
    return (float) tanh((double)x);
}
#endif

#line 230

#ifndef HAVE_FABSF
float fabsf(float x)
{
    return (float) fabs((double)x);
}
#endif

#line 230

#ifndef HAVE_FLOORF
float floorf(float x)
{
    return (float) floor((double)x);
}
#endif

#line 230

#ifndef HAVE_CEILF
float ceilf(float x)
{
    return (float) ceil((double)x);
}
#endif

#line 230

#ifndef HAVE_RINTF
float rintf(float x)
{
    return (float) rint((double)x);
}
#endif

#line 230

#ifndef HAVE_TRUNCF
float truncf(float x)
{
    return (float) trunc((double)x);
}
#endif

#line 230

#ifndef HAVE_SQRTF
float sqrtf(float x)
{
    return (float) sqrt((double)x);
}
#endif

#line 230

#ifndef HAVE_LOG10F
float log10f(float x)
{
    return (float) log10((double)x);
}
#endif

#line 230

#ifndef HAVE_LOGF
float logf(float x)
{
    return (float) log((double)x);
}
#endif

#line 230

#ifndef HAVE_EXPF
float expf(float x)
{
    return (float) exp((double)x);
}
#endif

#line 230

#ifndef HAVE_EXPM1F
float expm1f(float x)
{
    return (float) expm1((double)x);
}
#endif

#line 230

#ifndef HAVE_ASINF
float asinf(float x)
{
    return (float) asin((double)x);
}
#endif

#line 230

#ifndef HAVE_ACOSF
float acosf(float x)
{
    return (float) acos((double)x);
}
#endif

#line 230

#ifndef HAVE_ATANF
float atanf(float x)
{
    return (float) atan((double)x);
}
#endif

#line 230

#ifndef HAVE_ASINHF
float asinhf(float x)
{
    return (float) asinh((double)x);
}
#endif

#line 230

#ifndef HAVE_ACOSHF
float acoshf(float x)
{
    return (float) acosh((double)x);
}
#endif

#line 230

#ifndef HAVE_ATANHF
float atanhf(float x)
{
    return (float) atanh((double)x);
}
#endif


/*
 * Two values arguments function
 */

#line 252
#ifndef HAVE_ATAN2L
longdouble atan2l(longdouble x, longdouble y)
{
    return (longdouble) atan2((double)x, (double) y);
}
#endif

#line 252
#ifndef HAVE_HYPOTL
longdouble hypotl(longdouble x, longdouble y)
{
    return (longdouble) hypot((double)x, (double) y);
}
#endif

#line 252
#ifndef HAVE_POWL
longdouble powl(longdouble x, longdouble y)
{
    return (longdouble) pow((double)x, (double) y);
}
#endif

#line 252
#ifndef HAVE_FMODL
longdouble fmodl(longdouble x, longdouble y)
{
    return (longdouble) fmod((double)x, (double) y);
}
#endif

#line 252
#ifndef HAVE_ATAN2F
float atan2f(float x, float y)
{
    return (float) atan2((double)x, (double) y);
}
#endif

#line 252
#ifndef HAVE_HYPOTF
float hypotf(float x, float y)
{
    return (float) hypot((double)x, (double) y);
}
#endif

#line 252
#ifndef HAVE_POWF
float powf(float x, float y)
{
    return (float) pow((double)x, (double) y);
}
#endif

#line 252
#ifndef HAVE_FMODF
float fmodf(float x, float y)
{
    return (float) fmod((double)x, (double) y);
}
#endif


/*
 * One value - one pointer argument function
 */

#line 272
#ifndef HAVE_MODFL
longdouble modfl(longdouble x, longdouble *iptr)
{
    double nx, niptr, y;
    nx = (double) x;
    y = modf(nx, &niptr);
    *iptr = (longdouble) niptr;
    return (longdouble) y;
}
#endif

#line 272
#ifndef HAVE_MODFF
float modff(float x, float *iptr)
{
    double nx, niptr, y;
    nx = (double) x;
    y = modf(nx, &niptr);
    *iptr = (float) niptr;
    return (float) y;
}
#endif


