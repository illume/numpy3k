/* -*- c -*- */

/*
 * vim:syntax=c
 */

/*
 *****************************************************************************
 **                            INCLUDES                                     **
 *****************************************************************************
 */
#include "Python.h"
#include "numpy/noprefix.h"
#define _UMATHMODULE
#include "numpy/ufuncobject.h"
#include "abstract.h"
#include "config.h"
#include <math.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846264338328
#endif
#include "math_c99.inc"

/*
 *****************************************************************************
 **                     BASIC MATH FUNCTIONS                                **
 *****************************************************************************
 */

float degreesf(float x) {
    return x * (float)(180.0/M_PI);
}
double degrees(double x) {
    return x * (180.0/M_PI);
}
longdouble degreesl(longdouble x) {
    return x * (180.0L/M_PI);
}

float radiansf(float x) {
    return x * (float)(M_PI/180.0);
}
double radians(double x) {
    return x * (M_PI/180.0);
}
longdouble radiansl(longdouble x) {
    return x * (M_PI/180.0L);
}

/*
 *****************************************************************************
 **                           COMPLEX FUNCTIONS                             **
 *****************************************************************************
 */


/* Don't pass structures between functions (only pointers) because how
   structures are passed is compiler dependent and could cause
   segfaults if ufuncobject.c is compiled with a different compiler
   than an extension that makes use of the UFUNC API
*/

/**begin repeat

   #typ=float, double, longdouble#
   #c=f,,l#
*/

/* constants */
static c@typ@ nc_1@c@ = {1., 0.};
static c@typ@ nc_half@c@ = {0.5, 0.};
static c@typ@ nc_i@c@ = {0., 1.};
static c@typ@ nc_i2@c@ = {0., 0.5};
/*
  static c@typ@ nc_mi@c@ = {0., -1.};
  static c@typ@ nc_pi2@c@ = {M_PI/2., 0.};
*/

static void
nc_sum@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{
    r->real = a->real + b->real;
    r->imag = a->imag + b->imag;
    return;
}

static void
nc_diff@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{
    r->real = a->real - b->real;
    r->imag = a->imag - b->imag;
    return;
}

static void
nc_neg@c@(c@typ@ *a, c@typ@ *r)
{
    r->real = -a->real;
    r->imag = -a->imag;
    return;
}

static void
nc_prod@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{
    register @typ@ ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
    r->real = ar*br - ai*bi;
    r->imag = ar*bi + ai*br;
    return;
}

static void
nc_quot@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{

    register @typ@ ar=a->real, br=b->real, ai=a->imag, bi=b->imag;
    register @typ@ d = br*br + bi*bi;
    r->real = (ar*br + ai*bi)/d;
    r->imag = (ai*br - ar*bi)/d;
    return;
}

static void
nc_sqrt@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ s,d;
    if (x->real == 0. && x->imag == 0.)
        *r = *x;
    else {
        s = sqrt@c@((fabs@c@(x->real) + hypot@c@(x->real,x->imag))/2);
        d = x->imag/(2*s);
        if (x->real > 0) {
            r->real = s;
            r->imag = d;
        }
        else if (x->imag >= 0) {
            r->real = d;
            r->imag = s;
        }
        else {
            r->real = -d;
            r->imag = -s;
        }
    }
    return;
}

static void
nc_rint@c@(c@typ@ *x, c@typ@ *r)
{
    r->real = rint@c@(x->real);
    r->imag = rint@c@(x->imag);
}

static void
nc_log@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ l = hypot@c@(x->real,x->imag);
    r->imag = atan2@c@(x->imag, x->real);
    r->real = log@c@(l);
    return;
}

static void
nc_log1p@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ l = hypot@c@(x->real + 1,x->imag);
    r->imag = atan2@c@(x->imag, x->real + 1);
    r->real = log@c@(l);
    return;
}

static void
nc_exp@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ a = exp@c@(x->real);
    r->real = a*cos@c@(x->imag);
    r->imag = a*sin@c@(x->imag);
    return;
}

static void
nc_expm1@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ a = exp@c@(x->real);
    r->real = a*cos@c@(x->imag) - 1;
    r->imag = a*sin@c@(x->imag);
    return;
}

static void
nc_pow@c@(c@typ@ *a, c@typ@ *b, c@typ@ *r)
{
    intp n;
    @typ@ ar=a->real, br=b->real, ai=a->imag, bi=b->imag;

    if (br == 0. && bi == 0.) {
        r->real = 1.;
        r->imag = 0.;
        return;
    }
    if (ar == 0. && ai == 0.) {
        r->real = 0.;
        r->imag = 0.;
        return;
    }
    if (bi == 0 && (n=(intp)br) == br) {
        if (n > -100 && n < 100) {
            c@typ@ p, aa;
            intp mask = 1;
            if (n < 0) n = -n;
            aa = nc_1@c@;
            p.real = ar; p.imag = ai;
            while (1) {
                if (n & mask)
                    nc_prod@c@(&aa,&p,&aa);
                mask <<= 1;
                if (n < mask || mask <= 0) break;
                nc_prod@c@(&p,&p,&p);
            }
            r->real = aa.real; r->imag = aa.imag;
            if (br < 0) nc_quot@c@(&nc_1@c@, r, r);
            return;
        }
    }
    /* complexobect.c uses an inline version of this formula
       investigate whether this had better performance or accuracy */
    nc_log@c@(a, r);
    nc_prod@c@(r, b, r);
    nc_exp@c@(r, r);
    return;
}


static void
nc_prodi@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ xr = x->real;
    r->real = -x->imag;
    r->imag = xr;
    return;
}


static void
nc_acos@c@(c@typ@ *x, c@typ@ *r)
{
    nc_prod@c@(x,x,r);
    nc_diff@c@(&nc_1@c@, r, r);
    nc_sqrt@c@(r, r);
    nc_prodi@c@(r, r);
    nc_sum@c@(x, r, r);
    nc_log@c@(r, r);
    nc_prodi@c@(r, r);
    nc_neg@c@(r, r);
    return;
    /* return nc_neg(nc_prodi(nc_log(nc_sum(x,nc_prod(nc_i,
       nc_sqrt(nc_diff(nc_1,nc_prod(x,x))))))));
    */
}

static void
nc_acosh@c@(c@typ@ *x, c@typ@ *r)
{
    c@typ@ t;

    nc_sum@c@(x, &nc_1@c@, &t);
    nc_sqrt@c@(&t, &t);
    nc_diff@c@(x, &nc_1@c@, r);
    nc_sqrt@c@(r, r);
    nc_prod@c@(&t, r, r);
    nc_sum@c@(x, r, r);
    nc_log@c@(r, r);
    return;
    /*
      return nc_log(nc_sum(x,
      nc_prod(nc_sqrt(nc_sum(x,nc_1)), nc_sqrt(nc_diff(x,nc_1)))));
    */
}

static void
nc_asin@c@(c@typ@ *x, c@typ@ *r)
{
    c@typ@ a, *pa=&a;
    nc_prod@c@(x, x, r);
    nc_diff@c@(&nc_1@c@, r, r);
    nc_sqrt@c@(r, r);
    nc_prodi@c@(x, pa);
    nc_sum@c@(pa, r, r);
    nc_log@c@(r, r);
    nc_prodi@c@(r, r);
    nc_neg@c@(r, r);
    return;
    /*
      return nc_neg(nc_prodi(nc_log(nc_sum(nc_prod(nc_i,x),
      nc_sqrt(nc_diff(nc_1,nc_prod(x,x)))))));
    */
}


static void
nc_asinh@c@(c@typ@ *x, c@typ@ *r)
{
    nc_prod@c@(x, x, r);
    nc_sum@c@(&nc_1@c@, r, r);
    nc_sqrt@c@(r, r);
    nc_sum@c@(r, x, r);
    nc_log@c@(r, r);
    return;
    /*
      return nc_log(nc_sum(nc_sqrt(nc_sum(nc_1,nc_prod(x,x))),x));
    */
}

static void
nc_atan@c@(c@typ@ *x, c@typ@ *r)
{
    c@typ@ a, *pa=&a;
    nc_diff@c@(&nc_i@c@, x, pa);
    nc_sum@c@(&nc_i@c@, x, r);
    nc_quot@c@(r, pa, r);
    nc_log@c@(r,r);
    nc_prod@c@(&nc_i2@c@, r, r);
    return;
    /*
      return nc_prod(nc_i2,nc_log(nc_quot(nc_sum(nc_i,x),nc_diff(nc_i,x))));
    */
}

static void
nc_atanh@c@(c@typ@ *x, c@typ@ *r)
{
    c@typ@ a, *pa=&a;
    nc_diff@c@(&nc_1@c@, x, r);
    nc_sum@c@(&nc_1@c@, x, pa);
    nc_quot@c@(pa, r, r);
    nc_log@c@(r, r);
    nc_prod@c@(&nc_half@c@, r, r);
    return;
    /*
      return nc_prod(nc_half,nc_log(nc_quot(nc_sum(nc_1,x),nc_diff(nc_1,x))));
    */
}

static void
nc_cos@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ xr=x->real, xi=x->imag;
    r->real = cos@c@(xr)*cosh@c@(xi);
    r->imag = -sin@c@(xr)*sinh@c@(xi);
    return;
}

static void
nc_cosh@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ xr=x->real, xi=x->imag;
    r->real = cos@c@(xi)*cosh@c@(xr);
    r->imag = sin@c@(xi)*sinh@c@(xr);
    return;
}


#define M_LOG10_E 0.434294481903251827651128918916605082294397

static void
nc_log10@c@(c@typ@ *x, c@typ@ *r)
{
    nc_log@c@(x, r);
    r->real *= (@typ@) M_LOG10_E;
    r->imag *= (@typ@) M_LOG10_E;
    return;
}

static void
nc_sin@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ xr=x->real, xi=x->imag;
    r->real = sin@c@(xr)*cosh@c@(xi);
    r->imag = cos@c@(xr)*sinh@c@(xi);
    return;
}

static void
nc_sinh@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ xr=x->real, xi=x->imag;
    r->real = cos@c@(xi)*sinh@c@(xr);
    r->imag = sin@c@(xi)*cosh@c@(xr);
    return;
}

static void
nc_tan@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ sr,cr,shi,chi;
    @typ@ rs,is,rc,ic;
    @typ@ d;
    @typ@ xr=x->real, xi=x->imag;
    sr = sin@c@(xr);
    cr = cos@c@(xr);
    shi = sinh@c@(xi);
    chi = cosh@c@(xi);
    rs = sr*chi;
    is = cr*shi;
    rc = cr*chi;
    ic = -sr*shi;
    d = rc*rc + ic*ic;
    r->real = (rs*rc+is*ic)/d;
    r->imag = (is*rc-rs*ic)/d;
    return;
}

static void
nc_tanh@c@(c@typ@ *x, c@typ@ *r)
{
    @typ@ si,ci,shr,chr;
    @typ@ rs,is,rc,ic;
    @typ@ d;
    @typ@ xr=x->real, xi=x->imag;
    si = sin@c@(xi);
    ci = cos@c@(xi);
    shr = sinh@c@(xr);
    chr = cosh@c@(xr);
    rs = ci*shr;
    is = si*chr;
    rc = ci*chr;
    ic = si*shr;
    d = rc*rc + ic*ic;
    r->real = (rs*rc+is*ic)/d;
    r->imag = (is*rc-rs*ic)/d;
    return;
}

/**end repeat**/

/*
 *****************************************************************************
 **                             UFUNC LOOPS                                 **
 *****************************************************************************
 */

#define BINARY_LOOP\
    char *ip1 = args[0], *ip2 = args[1], *op = args[2];\
    intp is1 = steps[0], is2 = steps[1], os = steps[2];\
    intp n = dimensions[0];\
    intp i;\
    for(i = 0; i < n; i++, ip1 += is1, ip2 += is2, op += os)

#define UNARY_LOOP\
    char *ip1 = args[0], *op = args[1];\
    intp is1 = steps[0], os = steps[1];\
    intp n = dimensions[0];\
    intp i;\
    for(i = 0; i < n; i++, ip1 += is1, op += os)
/*
 *****************************************************************************
 **                             BOOLEAN LOOPS                               **
 *****************************************************************************
 */

/**begin repeat
 * #kind = equal, not_equal, greater, greater_equal, less, less_equal,
 *         logical_and, logical_or, logical_xor#
 * #OP =  ==, !=, >, >=, <, <=, &&, ||, ^#
 **/
static void
BOOL_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    BINARY_LOOP {
        Bool in1 = (*((Bool *)ip1) != 0);
        Bool in2 = (*((Bool *)ip2) != 0);
        *((Bool *)op)= in1 @OP@ in2;
    }
}
/**end repeat**/

/**begin repeat
 * #kind = maximum, minimum#
 * #OP =  >, <#
 **/
static void
BOOL_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    BINARY_LOOP {
        Bool in1 = (*((Bool *)ip1) != 0);
        Bool in2 = (*((Bool *)ip2) != 0);
        *((Bool *)op) = (in1 @OP@ in2) ? in1 : in2;
    }
}
/**end repeat**/

/**begin repeat
 * #kind = absolute, logical_not#
 * #OP =  !=, ==#
 **/
static void
BOOL_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    UNARY_LOOP {
        Bool in1 = *(Bool *)ip1;
        *((Bool *)op) = in1 @OP@ 0;
    }
}
/**end repeat**/

static void
BOOL_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    UNARY_LOOP {
        *((Bool *)op) = 1;
    }
}

#define BOOL_invert BOOL_logical_not
#define BOOL_negative BOOL_logical_not
#define BOOL_add BOOL_logical_or
#define BOOL_bitwise_and BOOL_logical_and
#define BOOL_bitwise_or BOOL_logical_or
#define BOOL_bitwise_xor BOOL_logical_xor
#define BOOL_multiply BOOL_logical_and
#define BOOL_subtract BOOL_logical_xor


/*
 *****************************************************************************
 **                           INTEGER LOOPS
 *****************************************************************************
 */

/**begin repeat
 * #type = byte, short, int, long, longlong#
 * #TYPE = BYTE, SHORT, INT, LONG, LONGLONG#
 * #ftype = float, float, double, double, double#
 */

/**begin repeat1
 * both signed and unsigned integer types
 * # s = , u#
 * # S = , U#
 */

static void
@S@@TYPE@_square(char **args, intp *dimensions, intp *steps, void *data)
{
    UNARY_LOOP {
        const @s@@type@ in1 = *((@s@@type@ *)ip1);
        *((@s@@type@ *)op) = in1*in1;
    }
}

static void
@S@@TYPE@_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    UNARY_LOOP {
        const @s@@type@ in1 = *((@s@@type@ *)ip1);
        *((@s@@type@ *)op) = 1.0/in1;
    }
}

static void
@S@@TYPE@_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    UNARY_LOOP {
        *((@s@@type@ *)op) = 1;
    }
}

static void
@S@@TYPE@_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    UNARY_LOOP {
        const @s@@type@ in1 = *((@s@@type@ *)ip1);
        *((@s@@type@ *)op) = in1;
    }
}

static void
@S@@TYPE@_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    UNARY_LOOP {
        const @s@@type@ in1 = *((@s@@type@ *)ip1);
        *((@s@@type@ *)op) = (@s@@type@)(-(@type@)in1);
    }
}

static void
@S@@TYPE@_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    UNARY_LOOP {
        const @s@@type@ in1 = *((@s@@type@ *)ip1);
        *((Bool *)op) = !in1;
    }
}

/**begin repeat2
 * Arithmetic
 * #kind = add, subtract, multiply, bitwise_and, bitwise_or, bitwise_xor,
 *          left_shift, right_shift#
 * #OP = +, -,*, &, |, ^, <<, >>#
 */
static void
@S@@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    BINARY_LOOP {
        const @s@@type@ in1 = *(@s@@type@ *)ip1;
        const @s@@type@ in2 = *(@s@@type@ *)ip2;
        *((@s@@type@ *)op) = in1 @OP@ in2;
    }
}
/**end repeat2**/

/**begin repeat2
 * #kind = equal, not_equal, greater, greater_equal, less, less_equal,
 *         logical_and, logical_or#
 * #OP =  ==, !=, >, >=, <, <=, &&, ||#
 */
static void
@S@@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    BINARY_LOOP {
        const @s@@type@ in1 = *(@s@@type@ *)ip1;
        const @s@@type@ in2 = *(@s@@type@ *)ip2;
        *((Bool *)op) = in1 @OP@ in2;
    }
}
/**end repeat2**/

static void
@S@@TYPE@_true_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    BINARY_LOOP {
        const @s@@type@ in1 = *(@s@@type@ *)ip1;
        const @s@@type@ in2 = *(@s@@type@ *)ip2;
        if (in2 == 0) {
            generate_divbyzero_error();
            *((@ftype@ *)op) = 0;
        }
        else {
            *((@ftype@ *)op) = (@ftype@)in1 / (@ftype@)in2;
        }
    }
}

static void
@S@@TYPE@_power(char **args, intp *dimensions, intp *steps, void *func)
{
    BINARY_LOOP {
        const @ftype@ in1 = (@ftype@)*((@s@@type@ *)ip1);
        const @ftype@ in2 = (@ftype@)*((@s@@type@ *)ip2);
        *((@s@@type@ *)op) = (@s@@type@) pow(in1, in2);
    }
}
/**end repeat1**/

static void
U@TYPE@_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    UNARY_LOOP {
        const u@type@ in1 = *((u@type@ *)ip1);
        *((u@type@ *)op) = in1;
    }
}

static void
@TYPE@_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    UNARY_LOOP {
        const @type@ in1 = *((@type@ *)ip1);
        *((@type@ *)op) = (in1 > 0) ? in1 : -in1;
        *((@type@ *)op) += 0; /* fixme clear sign-bit ? */
    }
}

static void
@TYPE@_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    BINARY_LOOP {
        const @type@ in1 = *(@type@ *)ip1;
        const @type@ in2 = *(@type@ *)ip2;
        if (in2 == 0) {
            generate_divbyzero_error();
            *((@type@ *)op) = 0;
        }
        else if (((in1 > 0) != (in2 > 0)) && (in1 % in2 != 0)) {
            *((@type@ *)op) = in1/in2 - 1;
        }
        else {
            *((@type@ *)op) = in1/in2;
        }
    }
}

static void
U@TYPE@_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    BINARY_LOOP {
        const u@type@ in1 = *(u@type@ *)ip1;
        const u@type@ in2 = *(u@type@ *)ip2;
        if (in2 == 0) {
            generate_divbyzero_error();
            *((u@type@ *)op) = 0;
        }
        else {
            *((u@type@ *)op)= in1/in2;
        }
    }
}

#define @TYPE@_floor_divide @TYPE@_divide
#define U@TYPE@_floor_divide U@TYPE@_divide
/**end repeat**/

/*
 *****************************************************************************
 **                             FLOAT LOOPS                                 **
 *****************************************************************************
 */


/**begin repeat
 * Float types
 *  #type = float, double, longdouble#
 *  #TYPE = FLOAT, DOUBLE, LONGDOUBLE#
 *  #c = f, , l#
 */

/**begin repeat1
 * Arithmetic
 * # OP = +, -, *, /#
 * # kind = add, subtract, multiply, divide#
 */
static void
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((@type@ *)op)=*((@type@ *)i1) @OP@ *((@type@ *)i2);
    }
}
/**end repeat1**/

/**begin repeat1
 * #kind = less, less_equal, greater, greater_equal, equal, not_equal,
 *        logical_and, logical_or#
 * #OP = <, <=, >, >=, ==, !=, &&, ||#
 */
static void
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=*((@type@ *)i1) @OP@ *((@type@ *)i2);
    }
}
/**end repeat1**/

static void
@TYPE@_floor_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i, is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((@type@ *)op)=floor@c@(*((@type@ *)i1) / *((@type@ *)i2));
    }
}

static void
@TYPE@_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        @type@ x = *((@type@ *)i1);
        *((@type@ *)op) = x*x;
    }
}

static void
@TYPE@_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        @type@ x = *((@type@ *)i1);
        *((@type@ *)op) = 1.0/x;
    }
}

static void
@TYPE@_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, os = steps[1], n = dimensions[0];
    char *op = args[1];

    for (i = 0; i < n; i++, op += os) {
        *((@type@ *)op) = 1;
    }
}

static void
@TYPE@_conjugate(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((@type@ *)op)=*((@type@ *)i1);
    }
}

static void
@TYPE@_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];

    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((@type@ *)op) = *((@type@ *)i1) < 0 ? -*((@type@ *)i1) : *((@type@ *)i1);
        *((@type@ *)op) += 0; /* fixme clear sign-bit ? */
    }
}

static void
@TYPE@_negative(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((@type@ *)op) = (@type@)(-*((@type@ *)i1));
    }
}

static void
@TYPE@_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! *((@type@ *)i1);
    }
}

#define @TYPE@_true_divide @TYPE@_divide
/**end repeat**/


/*
 *****************************************************************************
 **                           COMPLEX LOOPS                                 **
 *****************************************************************************
 */

/**begin repeat
 * complex types
 * #ctype= cfloat, cdouble, clongdouble#
 * #CTYPE= CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = float, double, longdouble#
 * #c = f, , l#
 */

/**begin repeat1
 * arithmetic
 * #OP = +, -#
 * #kind = add, subtract#
 */
static void
@CTYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ((@type@ *)op)[0]=((@type@ *)i1)[0] @OP@ ((@type@ *)i2)[0];
        ((@type@ *)op)[1]=((@type@ *)i1)[1] @OP@ ((@type@ *)i2)[1];
    }
}
/**end repeat1**/

/**begin repeat1
   #kind = equal, not_equal, logical_and, logical_or#
   #OP = ==, !=, &&, ||#
   #OP2 = &&, ||, &&, ||#
*/
static void
@CTYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op) = (*((@type@ *)i1) @OP@ *((@type@ *)i2)) @OP2@ (*((@type@ *)i1+1) @OP@ *((@type@ *)i2+1));
    }
}
/**end repeat1**/

static void
@CTYPE@_multiply(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        @type@ ar=((@ctype@ *)i1)->real;
        @type@ ai=((@ctype@ *)i1)->imag;
        @type@ br=((@ctype@ *)i2)->real;
        @type@ bi=((@ctype@ *)i2)->imag;
        ((@ctype@ *)op)->real = ar*br - ai*bi;
        ((@ctype@ *)op)->imag = ar*bi + ai*br;
    }
}

static void
@CTYPE@_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], is2=steps[1], os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        @type@ ar=((@ctype@ *)i1)->real;
        @type@ ai=((@ctype@ *)i1)->imag;
        @type@ br=((@ctype@ *)i2)->real;
        @type@ bi=((@ctype@ *)i2)->imag;
        @type@ d = br*br + bi*bi;
        ((@ctype@ *)op)->real = (ar*br + ai*bi)/d;
        ((@ctype@ *)op)->imag = (ai*br - ar*bi)/d;
    }
}

static void
@CTYPE@_floor_divide(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        @type@ ar=((@ctype@ *)i1)->real;
        @type@ ai=((@ctype@ *)i1)->imag;
        @type@ br=((@ctype@ *)i2)->real;
        @type@ bi=((@ctype@ *)i2)->imag;
        @type@ d = br*br + bi*bi;
        ((@ctype@ *)op)->real = floor@c@((ar*br + ai*bi)/d);
        ((@ctype@ *)op)->imag = 0;
    }
}

static void
@CTYPE@_square(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        @ctype@ *x = (@ctype@ *)i1;
        @ctype@ *y = (@ctype@ *)op;
        @type@ xr = x->real;
        @type@ xi = x->imag;
        y->real = xr*xr - xi*xi;
        y->imag = 2*xr*xi;
    }
}

/* fixme -- need type specific fabs */
static void
@CTYPE@_reciprocal(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        @ctype@ *x = (@ctype@ *)i1;
        @ctype@ *y = (@ctype@ *)op;
        @type@ xr = x->real;
        @type@ xi = x->imag;
        if (fabs(xi) <= fabs(xr)) {
            @type@ r = xi/xr;
            @type@ denom = xr + xi*r;
            y->real = 1/denom;
            y->imag = -r/denom;
        } else {
            @type@ r = xr/xi;
            @type@ denom = xr*r + xi;
            y->real = r/denom;
            y->imag = -1/denom;
        }
    }
}

static void
@CTYPE@_ones_like(char **args, intp *dimensions, intp *steps, void *data)
{
    intp i, is1 = steps[0], os = steps[1], n = dimensions[0];
    char *i1 = args[0], *op = args[1];
    @ctype@ *y;

    for (i = 0; i < n; i++, i1 += is1, op += os) {
        y = (@ctype@ *)op;
        y->real = 1.0;
        y->imag = 0.0;
    }
}

static void
@CTYPE@_conjugate(char **args, intp *dimensions, intp *steps, void *func) {
    intp i, is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];

    for(i=0; i<n; i++, i1+=is1, op+=os) {
        ((@type@ *)op)[0]=((@type@ *)i1)[0];
        ((@type@ *)op)[1]=-(((@type@ *)i1)[1]);
    }
}

static void
@CTYPE@_absolute(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i, n;
    intp is1=steps[0], os=steps[1];
    char *i1=args[0], *op=args[1];
    n=dimensions[0];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((@type@ *)op) = (@type@)sqrt@c@(((@type@ *)i1)[0]*((@type@ *)i1)[0] + ((@type@ *)i1)[1]*((@type@ *)i1)[1]);
    }
}

/**begin repeat1
 * #kind= greater, greater_equal, less, less_equal#
 * #OP = >, >=, <, <=#
 */
static void
@CTYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        if (((c@type@ *)i1)->real == ((c@type@ *)i2)->real)
            *((Bool *)op)=((c@type@ *)i1)->imag @OP@
                ((c@type@ *)i2)->imag;
        else
            *((Bool *)op)=((c@type@ *)i1)->real @OP@
                ((c@type@ *)i2)->real;
    }
}
/**end repeat1**/

static void
@CTYPE@_logical_not(char **args, intp *dimensions, intp *steps, void *func)
{
    intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((Bool *)op) = ! (((@ctype@ *)i1)->real ||
                           ((@ctype@ *)i1)->imag);
    }
}

#define @CTYPE@_true_divide @CTYPE@_divide
/**end repeat**/


/*
 *****************************************************************************
 **                            OBJECT LOOPS                                 **
 *****************************************************************************
 */

static PyObject *
Py_square(PyObject *o)
{
    return PyNumber_Multiply(o, o);
}

static PyObject *
Py_get_one(PyObject *o)
{
    return PyInt_FromLong(1);
}

static PyObject *
Py_reciprocal(PyObject *o)
{
    PyObject *one, *result;
    one = PyInt_FromLong(1);
    if (!one) return NULL;
    result = PyNumber_Divide(one, o);
    Py_DECREF(one);
    return result;
}

static PyObject *
_npy_ObjectMax(PyObject *i1, PyObject *i2)
{
    int cmp;
    PyObject *res;
    if (PyObject_Cmp(i1, i2, &cmp) < 0) return NULL;

    if (cmp >= 0) {
        res = i1;
    }
    else {
        res = i2;
    }
    Py_INCREF(res);
    return res;
}

static PyObject *
_npy_ObjectMin(PyObject *i1, PyObject *i2)
{
    int cmp;
    PyObject *res;
    if (PyObject_Cmp(i1, i2, &cmp) < 0) return NULL;

    if (cmp <= 0) {
        res = i1;
    }
    else {
        res = i2;
    }
    Py_INCREF(res);
    return res;
}

/**begin repeat

   #kind=greater, greater_equal, less, less_equal, equal, not_equal#
   #op=GT, GE, LT, LE, EQ, NE#
*/
static void
OBJECT_@kind@(char **args, intp *dimensions, intp *steps, void *func) {
    register intp i, is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=PyObject_RichCompareBool(*((PyObject **)i1),
                                               *((PyObject **)i2),
                                               Py_@op@);
    }
}
/**end repeat**/

/*
 *****************************************************************************
 **                            UNDONE LOOPS                                 **
 *****************************************************************************
 */

/*sign*/
#define _SIGN1(x) ((x) > 0 ? 1 : ((x) < 0 ? -1 : 0))
#define _SIGN2(x) ((x) == 0 ? 0 : 1)
#define _SIGNC(x) (((x).real > 0) ? 1 : ((x).real < 0 ? -1 : ((x).imag > 0 ? 1 : ((x).imag < 0) ? -1 : 0)))
/**begin repeat
   #TYPE=BYTE,SHORT,INT,LONG,LONGLONG,FLOAT,DOUBLE,LONGDOUBLE,UBYTE,USHORT,UINT,ULONG,ULONGLONG#
   #typ=byte,short,int,long,longlong,float,double,longdouble,ubyte,ushort,uint,ulong,ulonglong#
   #func=_SIGN1*8,_SIGN2*5#
*/
static void
@TYPE@_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    @typ@ t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((@typ@ *)i1);
        *((@typ@ *)op) = (@typ@) @func@(t1);
    }
}
/**end repeat**/

/**begin repeat
   #TYPE=CFLOAT,CDOUBLE,CLONGDOUBLE#
   #typ=cfloat,cdouble,clongdouble#
   #rtyp=float,double,longdouble#
*/
static void
@TYPE@_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    @typ@ t1;
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((@typ@ *)i1);
        (*((@typ@ *)op)).real = (@rtyp@)_SIGNC(t1);
        (*((@typ@ *)op)).imag = (@rtyp@)0;
    }
}
/**end repeat**/

#undef _SIGN1
#undef _SIGN2
#undef _SIGNC


static void
OBJECT_sign(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    PyObject *t1, *zero, *res;
    zero = PyInt_FromLong(0);
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        t1 = *((PyObject **)i1);
        res = PyInt_FromLong((long) PyObject_Compare(t1, zero));
        *((PyObject **)op) = res;
    }
    Py_DECREF(zero);
}




/*remainder*/
/**begin repeat
   #TYPE=BYTE,SHORT,INT,LONG,LONGLONG#
   #typ=byte, short, int, long, longlong#
   #c=f*2,,,l*1#
*/
static void
@TYPE@_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register @typ@ ix,iy, tmp;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((@typ@ *)i1);
        iy = *((@typ@ *)i2);
        if (iy == 0 || ix == 0) {
            if (iy == 0) generate_divbyzero_error();
            *((@typ@ *)op) = 0;
        }
        else if ((ix > 0) == (iy > 0)) {
            *((@typ@ *)op) = ix % iy;
        }
        else {  /* handle mixed case the way Python does */
            tmp = ix % iy;
            if (tmp) tmp += iy;
            *((@typ@ *)op)= tmp;
        }
    }
}
/**end repeat**/

/**begin repeat
   #TYPE=UBYTE,USHORT,UINT,ULONG,ULONGLONG#
   #typ=ubyte, ushort, uint, ulong, ulonglong#
*/
static void
@TYPE@_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    register @typ@ ix,iy;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        ix = *((@typ@ *)i1);
        iy = *((@typ@ *)i2);
        if (iy == 0) {
            generate_divbyzero_error();
            *((@typ@ *)op) = 0;
        }
        *((@typ@ *)op) = ix % iy;
    }
}
/**end repeat**/

/**begin repeat
   #TYPE=FLOAT,DOUBLE,LONGDOUBLE#
   #typ=float,double,longdouble#
   #c=f,,l#
*/
static void
@TYPE@_remainder(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    @typ@ x, y, res;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((@typ@ *)i1);
        y = *((@typ@ *)i2);
        res = fmod@c@(x, y);
        if (res && ((y < 0) != (res < 0))) {
            res += y;
        }
        *((@typ@ *)op)= res;
    }
}
/**end repeat**/

/*fmod*/
/**begin repeat

   #TYPE=BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG#
   #typ=byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong#
*/
static void
@TYPE@_fmod(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    @typ@ x, y;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x = *((@typ@ *)i1);
        y = *((@typ@ *)i2);
        if (y == 0) {
            generate_divbyzero_error();
            *((@typ@ *)op) = 0;
        }
        else {
            *((@typ@ *)op)= x % y;
        }

    }
}
/**end repeat**/


/*invert*/
/**begin repeat
   #TYPE=BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG#
   #typ=byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong#
*/
static void
@TYPE@_invert(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0], os=steps[1], n=dimensions[0];
    char *i1=args[0], *op=args[1];
    for(i=0; i<n; i++, i1+=is1, op+=os) {
        *((@typ@ *)op) = ~ *((@typ@*)i1);
    }
}
/**end repeat**/


/*logical_xor*/
/**begin repeat
   #TYPE=BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE#
   #typ=byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble#

*/
static void
@TYPE@_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((Bool *)op)=(*((@typ@ *)i1) || *((@typ@ *)i2)) && !(*((@typ@ *)i1) && *((@typ@ *)i2));
    }
}
/**end repeat**/


/**begin repeat
   #TYPE=CFLOAT,CDOUBLE,CLONGDOUBLE#
   #typ=cfloat, cdouble, clongdouble#
*/
static void
@TYPE@_logical_xor(char **args, intp *dimensions, intp *steps, void *func)
{
    Bool p1, p2;
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        p1 = ((@typ@ *)i1)->real || ((@typ@ *)i1)->imag;
        p2 = ((@typ@ *)i2)->real || ((@typ@ *)i2)->imag;
        *((Bool *)op)= (p1 || p2) && !(p1 && p2);
    }
}
/**end repeat**/


/*max,min*/
/**begin repeat

   #TYPE=(BYTE,UBYTE,SHORT,USHORT,INT,UINT,LONG,ULONG,LONGLONG,ULONGLONG,FLOAT,DOUBLE,LONGDOUBLE)*2#
   #OP= >*13, <*13#
   #typ=(byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble)*2#
   #kind= maximum*13, minimum*13#
*/
static void
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        *((@typ@ *)op)=*((@typ@ *)i1) @OP@ *((@typ@ *)i2) ? *((@typ@ *)i1) : *((@typ@ *)i2);
    }
}
/**end repeat**/

/**begin repeat

   #TYPE=(CFLOAT,CDOUBLE,CLONGDOUBLE)*2#
   #OP= >*3, <*3#
   #typ=(cfloat, cdouble, clongdouble)*2#
   #kind= maximum*3, minimum*3#
*/
static void
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2], n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    @typ@ *i1c, *i2c;
    for(i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        i1c = (@typ@ *)i1;
        i2c = (@typ@ *)i2;
        if ((i1c->real @OP@ i2c->real) ||                       \
            ((i1c->real==i2c->real) && (i1c->imag @OP@ i2c->imag)))
            memmove(op, i1, sizeof(@typ@));
        else
            memmove(op, i2, sizeof(@typ@));
    }
}
/**end repeat**/



/*** isinf, isinf, isfinite, signbit ***/
/**begin repeat
   #kind=isnan*3, isinf*3, isfinite*3, signbit*3#
   #TYPE=(FLOAT, DOUBLE, LONGDOUBLE)*4#
   #typ=(float, double, longdouble)*4#
*/
static void
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = (Bool) (@kind@(*((@typ@ *)ip)) != 0);
    }
}
/**end repeat**/


/**begin repeat
   #kind=isnan*3, isinf*3, isfinite*3#
   #TYPE=(CFLOAT, CDOUBLE, CLONGDOUBLE)*3#
   #typ=(float, double, longdouble)*3#
   #OP=||*6,&&*3#
*/
static void
@TYPE@_@kind@(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is=steps[0], os=steps[1], n=dimensions[0];
    char *ip=args[0], *op=args[1];
    for(i=0; i<n; i++, ip+=is, op+=os) {
        *((Bool *)op) = @kind@(((@typ@ *)ip)[0]) @OP@        \
            @kind@(((@typ@ *)ip)[1]);
    }
}
/**end repeat**/




/****** modf ****/

/**begin repeat
   #TYPE=FLOAT, DOUBLE, LONGDOUBLE#
   #typ=float, double, longdouble#
   #c=f,,l#
*/
static void
@TYPE@_modf(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
    char *i1=args[0], *op1=args[1], *op2=args[2];
    @typ@ x1, y1, y2;
    for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
        x1 = *((@typ@ *)i1);
        y1 = modf@c@(x1, &y2);
        *((@typ@ *)op1) = y1;
        *((@typ@ *)op2) = y2;
    }
}
/**end repeat**/

/*frexp, ldexp*/
/**begin repeat
   #TYPE=FLOAT, DOUBLE, LONGDOUBLE#
   #typ=float, double, longdouble#
   #c=f,,l#
   #C=F,,L#
*/
#ifdef HAVE_FREXP@C@
static void
@TYPE@_frexp(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],os1=steps[1],os2=steps[2],n=dimensions[0];
    char *i1=args[0], *op1=args[1], *op2=args[2];
    @typ@ x1, y1;
    int y2;
    for (i=0; i<n; i++, i1+=is1, op1+=os1, op2+=os2) {
        x1 = *((@typ@ *)i1);
        y1 = frexp@c@(x1, &y2);
        *((@typ@ *)op1) = y1;
        *((int *) op2) = y2;
    }
}
#endif

#ifdef HAVE_LDEXP@C@
static void
@TYPE@_ldexp(char **args, intp *dimensions, intp *steps, void *func)
{
    register intp i;
    intp is1=steps[0],is2=steps[1],os=steps[2],n=dimensions[0];
    char *i1=args[0], *i2=args[1], *op=args[2];
    @typ@ x1, y1;
    int x2;
    for (i=0; i<n; i++, i1+=is1, i2+=is2, op+=os) {
        x1 = *((@typ@ *)i1);
        x2 = *((int *)i2);
        y1 = ldexp@c@(x1, x2);
        *((@typ@ *)op) = y1;
    }
}
#endif
/**end repeat**/


static PyUFuncGenericFunction frexp_functions[] = {
#ifdef HAVE_FREXPF
    FLOAT_frexp,
#endif
    DOUBLE_frexp
#ifdef HAVE_FREXPL
    ,LONGDOUBLE_frexp
#endif
};

static void * blank3_data[] = { (void *)NULL, (void *)NULL, (void *)NULL};
static char frexp_signatures[] = {
#ifdef HAVE_FREXPF
    PyArray_FLOAT, PyArray_FLOAT, PyArray_INT,
#endif
    PyArray_DOUBLE, PyArray_DOUBLE, PyArray_INT
#ifdef HAVE_FREXPL
    ,PyArray_LONGDOUBLE, PyArray_LONGDOUBLE, PyArray_INT
#endif
};


static PyUFuncGenericFunction ldexp_functions[] = {
#ifdef HAVE_LDEXPF
    FLOAT_ldexp,
#endif
    DOUBLE_ldexp
#ifdef HAVE_LDEXPL
    ,LONGDOUBLE_ldexp
#endif
};

static char ldexp_signatures[] = {
#ifdef HAVE_LDEXPF
    PyArray_FLOAT, PyArray_INT, PyArray_FLOAT,
#endif
    PyArray_DOUBLE, PyArray_INT, PyArray_DOUBLE
#ifdef HAVE_LDEXPL
    ,PyArray_LONGDOUBLE, PyArray_INT, PyArray_LONGDOUBLE
#endif
};



#include "__umath_generated.c"


#include "ufuncobject.c"

#include "__ufunc_api.c"

static double
pinf_init(void)
{
    double mul = 1e10;
    double tmp = 0.0;
    double pinf;

    pinf = mul;
    for (;;) {
        pinf *= mul;
        if (pinf == tmp) break;
        tmp = pinf;
    }
    return pinf;
}

static double
pzero_init(void)
{
    double div = 1e10;
    double tmp = 0.0;
    double pinf;

    pinf = div;
    for (;;) {
        pinf /= div;
        if (pinf == tmp) break;
        tmp = pinf;
    }
    return pinf;
}

/* Less automated additions to the ufuncs */

static void
InitOtherOperators(PyObject *dictionary) {
    PyObject *f;
    int num=1;

#ifdef HAVE_FREXPL
    num += 1;
#endif
#ifdef HAVE_FREXPF
    num += 1;
#endif
    f = PyUFunc_FromFuncAndData(frexp_functions, blank3_data,
                                frexp_signatures, num,
                                1, 2, PyUFunc_None, "frexp",
                                "Split the number, x, into a normalized"\
                                " fraction (y1) and exponent (y2)",0);
    PyDict_SetItemString(dictionary, "frexp", f);
    Py_DECREF(f);

    num = 1;
#ifdef HAVE_LDEXPL
    num += 1;
#endif
#ifdef HAVE_LDEXPF
    num += 1;
#endif
    f = PyUFunc_FromFuncAndData(ldexp_functions, blank3_data, ldexp_signatures, num,
                                2, 1, PyUFunc_None, "ldexp",
                                "Compute y = x1 * 2**x2.",0);
    PyDict_SetItemString(dictionary, "ldexp", f);
    Py_DECREF(f);
    return;
}

static struct PyMethodDef methods[] = {
    {"frompyfunc", (PyCFunction) ufunc_frompyfunc,
     METH_VARARGS | METH_KEYWORDS, doc_frompyfunc},
    {"seterrobj", (PyCFunction) ufunc_seterr,
     METH_VARARGS, NULL},
    {"geterrobj", (PyCFunction) ufunc_geterr,
     METH_VARARGS, NULL},
    {NULL,          NULL, 0}                /* sentinel */
};

PyMODINIT_FUNC initumath(void) {
    PyObject *m, *d, *s, *s2, *c_api;
    double pinf, pzero, mynan;
    int UFUNC_FLOATING_POINT_SUPPORT = 1;

#ifdef NO_UFUNC_FLOATING_POINT_SUPPORT
    UFUNC_FLOATING_POINT_SUPPORT = 0;
#endif
    /* Create the module and add the functions */
    m = Py_InitModule("umath", methods);

    /* Import the array */
    if (_import_array() < 0) {
        if (!PyErr_Occurred()) {
            PyErr_SetString(PyExc_ImportError,
                            "umath failed: Could not import array core.");
        }
        return;
    }

    /* Initialize the types */
    if (PyType_Ready(&PyUFunc_Type) < 0)
        return;

    /* Add some symbolic constants to the module */
    d = PyModule_GetDict(m);

    c_api = PyCObject_FromVoidPtr((void *)PyUFunc_API, NULL);
    if (PyErr_Occurred()) goto err;
    PyDict_SetItemString(d, "_UFUNC_API", c_api);
    Py_DECREF(c_api);
    if (PyErr_Occurred()) goto err;

    s = PyString_FromString("0.4.0");
    PyDict_SetItemString(d, "__version__", s);
    Py_DECREF(s);

    /* Load the ufunc operators into the array module's namespace */
    InitOperators(d);

    InitOtherOperators(d);

    PyDict_SetItemString(d, "pi", s = PyFloat_FromDouble(M_PI));
    Py_DECREF(s);
    PyDict_SetItemString(d, "e", s = PyFloat_FromDouble(exp(1.0)));
    Py_DECREF(s);

#define ADDCONST(str) PyModule_AddIntConstant(m, #str, UFUNC_##str)
#define ADDSCONST(str) PyModule_AddStringConstant(m, "UFUNC_" #str, UFUNC_##str)

    ADDCONST(ERR_IGNORE);
    ADDCONST(ERR_WARN);
    ADDCONST(ERR_CALL);
    ADDCONST(ERR_RAISE);
    ADDCONST(ERR_PRINT);
    ADDCONST(ERR_LOG);
    ADDCONST(ERR_DEFAULT);
    ADDCONST(ERR_DEFAULT2);

    ADDCONST(SHIFT_DIVIDEBYZERO);
    ADDCONST(SHIFT_OVERFLOW);
    ADDCONST(SHIFT_UNDERFLOW);
    ADDCONST(SHIFT_INVALID);

    ADDCONST(FPE_DIVIDEBYZERO);
    ADDCONST(FPE_OVERFLOW);
    ADDCONST(FPE_UNDERFLOW);
    ADDCONST(FPE_INVALID);

    ADDCONST(FLOATING_POINT_SUPPORT);

    ADDSCONST(PYVALS_NAME);

#undef ADDCONST
#undef ADDSCONST
    PyModule_AddIntConstant(m, "UFUNC_BUFSIZE_DEFAULT", (long)PyArray_BUFSIZE);

    pinf = pinf_init();
    pzero = pzero_init();
    mynan = pinf / pinf;

    PyModule_AddObject(m, "PINF", PyFloat_FromDouble(pinf));
    PyModule_AddObject(m, "NINF", PyFloat_FromDouble(-pinf));
    PyModule_AddObject(m, "PZERO", PyFloat_FromDouble(pzero));
    PyModule_AddObject(m, "NZERO", PyFloat_FromDouble(-pzero));
    PyModule_AddObject(m, "NAN", PyFloat_FromDouble(mynan));

    s = PyDict_GetItemString(d, "conjugate");
    s2 = PyDict_GetItemString(d, "remainder");
    /* Setup the array object's numerical structures with appropriate
       ufuncs in d*/
    PyArray_SetNumericOps(d);

    PyDict_SetItemString(d, "conj", s);
    PyDict_SetItemString(d, "mod", s2);

    return;
 err:
    /* Check for errors */
    if (!PyErr_Occurred()) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load umath module.");
    }
    return;
}
