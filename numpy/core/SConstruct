# Last Change: Thu Oct 18 05:00 PM 2007 J
# vim:syntax=python
import os
from os.path import join as pjoin, basename as pbasename, dirname as pdirname
import sys
from copy import deepcopy

from numpy.distutils.scons import get_python_inc
from numpy.distutils.scons import GetNumpyEnvironment, CheckTypeSize

import SCons.Node

def generate_config_header(target, source, env):
    t = open(str(target[0]), 'w')
    if not env.has_key('CONFIG_H_GEN'):
        # XXX
        assert 0 == 1
    sym = env['CONFIG_H_GEN']
    def write_symbol(define, value):
        if value == 1:
            return "#define %s\n\n" % define
        elif value == 0:
            return "/* #undef %s */\n\n" % define
        else:
            return "#define %s %s\n\n" % (define, value)
    t.writelines([write_symbol(i[0], i[1]) for i in sym])
    t.write('\n')
    t.close()

    print 'File: %s' % target[0]
    target_f = open(str(target[0]))
    print target_f.read()
    target_f.close()
    print 'EOF'
    return 0

def generate_config_header_emitter(target, source, env):
    """Add dependency from config list  CONFIG_H_GEN to target.  Returns
    original target, source tuple unchanged.  """
    d = deepcopy(env['CONFIG_H_GEN']) # copy it
    Depends(target, SCons.Node.Python.Value(d))
    return target, source

def define_no_smp():
    """Returns True if we should define NPY_NOSMP, False otherwise."""
    #--------------------------------
    # Checking SMP and thread options
    #--------------------------------
    # Python 2.3 causes a segfault when
    #  trying to re-acquire the thread-state
    #  which is done in error-handling
    #  ufunc code.  NPY_ALLOW_C_API and friends
    #  cause the segfault. So, we disable threading
    #  for now.
    if sys.version[:5] < '2.4.2':
        nosmp = 1
    else:
        # Perhaps a fancier check is in order here.
        #  so that threads are only enabled if there
        #  are actually multiple CPUS? -- but
        #  threaded code can be nice even on a single
        #  CPU so that long-calculating code doesn't
        #  block.
        try:
            nosmp = os.environ['NPY_NOSMP']
            nosmp = 1
        except KeyError:
            nosmp = 0
    return nosmp == 1

def CheckBrokenMathlib(context, mathlib):
    src = """
/* check whether libm is broken */
#include <math.h>
int main(int argc, char *argv[])
{
  return exp(-720.) > 1.0;  /* typically an IEEE denormal */
}
"""

    try:
        oldLIBS = deepcopy(context.env['LIBS'])
    except:
        oldLIBS = []

    try:
        context.Message("Checking if math lib %s is broken ... " % mathlib)
        context.env.AppendUnique(LIBS = mathlib)
        st = context.TryRun(src, '.c')
    finally:
        env['LIBS'] = oldLIBS

    if st[0]:
        context.Result(' not broken !')
    else:
        context.Result(' broken !')
    return st[0]

env = GetNumpyEnvironment(ARGUMENTS)
env.Append(CPPPATH = [get_python_inc()])

#=======================
# Starting Configuration
#=======================
config = env.NumpyConfigure(custom_tests = {'CheckTypeSize' : CheckTypeSize,
    'CheckBrokenMathlib' : CheckBrokenMathlib})

# Convention: list of tuples (definition, value). value:
# - 0: #undef definition
# - 1: #define definition
# - string: #define definition value
config_sym = []

#---------------
# Checking Types
#---------------
def check_type(type, include = None):
    st = config.CheckTypeSize(type, includes = include)
    type = type.replace(' ', '_')
    if st:
        config_sym.append(('SIZEOF_%s' % type.upper(), '%d' % st))
    else:
        config_sym.append(('SIZEOF_%s' % type.upper(), 0))
check_type('short')
check_type('int')
check_type('long')
check_type('float')
check_type('double')
check_type('long double')
check_type('Py_intptr_t', include = ["Python.h"])
check_type('PY_LONG_LONG', include = ["Python.h"])

# TODO: check python extension can be built (in root or here ?)

#-----------------------
# Checking configuration
#-----------------------

#----------------------
# Checking signal stuff
#----------------------
# TODO

#------------------------------------------
# Checking the mathlib and its capabilities
#------------------------------------------
# Function to check:
mfuncs = [('expl', 'HAVE_LONGDOUBLE_FUNCS'),
    ('expf', 'HAVE_FLOAT_FUNCS'),
    ('log1p', 'HAVE_LOG1P'),
    ('expm1', 'HAVE_EXPM1'),
    ('asinh', 'HAVE_INVERSE_HYPERBOLIC'),
    ('atanhf', 'HAVE_INVERSE_HYPERBOLIC_FLOAT'),
    ('atanhl', 'HAVE_INVERSE_HYPERBOLIC_LONGDOUBLE'),
    ('isnan', 'HAVE_ISNAN'),
    ('isinf', 'HAVE_ISINF'),
    ('rint', 'HAVE_RINT'),
    ]

# TODO: getting the math lib automatically ? Having a list ?
# TODO: checklib vs checkfunc ?
mathlib = os.environ.get('MATHLIB')
if mathlib: 
    # XXX: prepend it ?
    mlib = mathlib
else:
    mlib = 'm'
config_sym.append(('MATHLIB', str(mlib)))

def check_lib(f, autoadd = 0):
    """Check that f is available in mlib, and add the symbol appropriately.

    f is expected to be a tuble (symbol, cpp define)."""
    st = config.CheckLib(mlib, f[0], autoadd = autoadd)
    if st:
        config_sym.append((f[1], 1))
    else:
        config_sym.append((f[1], 0))

check_lib(mfuncs[0], autoadd = 1)
for f in mfuncs[1:]:
    check_lib(f)

if not config.CheckBrokenMathlib(mlib):
    raise SCons.Errors.UserError("Your mathlib looks broken: chose another "\
                                 "one using the MATHLIB env variable, eg "\
                                 "MATHLIB=m")

#-------------------------------------------------------
# Define the function PyOS_ascii_strod if not available
#-------------------------------------------------------
# XXX: would be better to check for PyOS_ascii_strod instead of version
if sys.version[:3] < '2.4':
    if config.CheckFunc('strtod'):
        config_sym.append('PyOS_ascii_strtod', 'strtod')

if define_no_smp():
    config_sym.append(('NPY_NOSMP', '1'))
else:
    config_sym.append(('NPY_NOSMP', '0'))

#--------------
# Checking Blas
#--------------
# TODO

config.Finish()

#==========
#  Build
#==========

#---------------------------------------
# Generate the public configuration file
#---------------------------------------
config_dict = {}
# XXX: this is ugly, make the API for config.h and numpyconfig.h similar
for key, value in config_sym:
    config_dict['@%s@' % key] = str(value)
env['SUBST_DICT'] = config_dict

include_dir = 'include/numpy'
env.SubstInFile(pjoin(env['build_dir'], 'numpyconfig.h'), 
                pjoin(env['src_dir'], include_dir, 'numpyconfig.h.in'))

env['CONFIG_H_GEN'] = config_sym

#---------------------------
# Builder for generated code
#---------------------------
from scons_support import do_generate_array_api, do_generate_ufunc_api, \
                        generate_api_emitter,\
                        generate_from_template, generate_from_template_emitter, \
                        generate_umath, generate_umath_emitter

array_api_gen_bld = Builder(action = do_generate_array_api, 
                            emitter = generate_api_emitter)

ufunc_api_gen_bld = Builder(action = do_generate_ufunc_api, 
                            emitter = generate_api_emitter)

template_bld = Builder(action = generate_from_template, 
                       emitter = generate_from_template_emitter)

umath_bld = Builder(action = generate_umath, 
                    emitter = generate_umath_emitter)

config_h_bld = Builder(action = generate_config_header, 
                       emitter = generate_config_header_emitter)

env.Append(BUILDERS = {'GenerateMultiarrayApi' : array_api_gen_bld,
                       'GenerateUfuncApi' : ufunc_api_gen_bld,
                       'GenerateFromTemplate' : template_bld,
                       'GenerateUmath' : umath_bld,
                       'GenerateConfigHeader' : config_h_bld})

#------------------------
# Generate generated code
#------------------------
from os.path import join as pjoin

config_header = env.GenerateConfigHeader(pjoin(env['build_dir'], 'config.h'), [])

scalartypes_src = env.GenerateFromTemplate(
                    pjoin(env['build_dir'], 'src', 'scalartypes'), 
                    pjoin(env['src_dir'], 'src', 'scalartypes.inc.src'))

arraytypes_src = env.GenerateFromTemplate(
                    pjoin(env['build_dir'], 'src', 'arraytypes'), 
                    pjoin(env['src_dir'], 'src', 'arraytypes.inc.src'))

sortmodule_src = env.GenerateFromTemplate(
                    pjoin(env['build_dir'], 'src', '_sortmodule'), 
                    pjoin(env['src_dir'], 'src', '_sortmodule.c.src'))

umathmodule_src = env.GenerateFromTemplate(
                    pjoin(env['build_dir'], 'src', 'umathmodule'), 
                    pjoin(env['src_dir'], 'src', 'umathmodule.c.src'))

scalarmathmodule_src = env.GenerateFromTemplate(
                    pjoin(env['build_dir'], 'src', 'scalarmathmodule'), 
                    pjoin(env['src_dir'], 'src', 'scalarmathmodule.c.src'))

umath = env.GenerateUmath(
            pjoin(env['build_dir'], '__umath_generated'), 
            pjoin(env['src_dir'], 'code_generators', 'generate_umath.py'))

multiarray_api = env.GenerateMultiarrayApi(
                        pjoin(env['build_dir'], 'multiarray_api'), 
                        [ pjoin(env['src_dir'], 'code_generators', 
                                'array_api_order.txt'),
                          pjoin(env['src_dir'], 'code_generators', 
                                'multiarray_api_order.txt')])

ufunc_api = env.GenerateUfuncApi(
                    pjoin(env['build_dir'], 'ufunc_api'), 
                    pjoin(env['src_dir'], 'code_generators', 'ufunc_api_order.txt'))

# XXX
env.Append(CCFLAGS = "-Wall -fno-strict-aliasing")

env.Append(CPPPATH = [pjoin(env['src_dir'], 'include'), env['build_dir']])

#-----------------
# Build multiarray
#-----------------
multiarray_src = [pjoin('src', 'multiarraymodule.c')]
multiarray = env.NumpyPythonExtension('multiarray', source = multiarray_src)

#------------------
# Build sort module
#------------------
sort = env.NumpyPythonExtension('_sort', source = sortmodule_src)

#-------------------
# Build umath module
#-------------------
umathmodule = env.NumpyPythonExtension('umathmodule', source = umathmodule_src)

#------------------------
# Build scalarmath module
#------------------------
scalarmathmodule = env.NumpyPythonExtension('scalarmathmodule', 
                                            source = scalarmathmodule_src)

#----------------------
# Build _dotblas module
#----------------------
dotblas_src = [pjoin('blasdot', i) for i in ['_dotblas.c']]
dotblas = env.NumpyPythonExtension('_dotblas', source = dotblas_src)
