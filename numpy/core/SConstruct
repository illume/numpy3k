# Last Change: Fri Oct 12 07:00 PM 2007 J
# vim:syntax=python
import os
from os.path import join as pjoin, basename as pbasename, dirname as pdirname
import sys

from numpy.distutils.scons import get_python_inc
from numpy.distutils.scons import GetNumpyEnvironment, CheckTypeSize

import SCons.Util

def generate_config_header(target, source, env):
    t = open(str(target[0]), 'w')
    if not env.has_key('config_h_gen'):
        # XXX
        assert 0 == 1
    sym = env['config_h_gen']
    def write_symbol(define, value):
        if value == 1:
            return "#define %s\n\n" % define
        elif value == 0:
            return "#undef %s\n\n" % define
        elif SCons.Util.is_String(value):
            return "#define %s %s\n\n" % (define, value)
    t.writelines([write_symbol(i[0], i[1]) for i in sym])
    t.write('\n')
    t.close()

    return 0

# Convention: list of tuples (definition, value). value:
# - 0: #undef definition
# - 1: #define definition
# - string: #define definition value
config_sym = []

env = GetNumpyEnvironment(ARGUMENTS)

#--------------------------------
# Checking SMP and thread options
#--------------------------------
# Python 2.3 causes a segfault when
#  trying to re-acquire the thread-state
#  which is done in error-handling
#  ufunc code.  NPY_ALLOW_C_API and friends
#  cause the segfault. So, we disable threading
#  for now.
if sys.version[:5] < '2.4.2':
    nosmp = 1
else:
    # Perhaps a fancier check is in order here.
    #  so that threads are only enabled if there
    #  are actually multiple CPUS? -- but
    #  threaded code can be nice even on a single
    #  CPU so that long-calculating code doesn't
    #  block.
    try:
        nosmp = os.environ['NPY_NOSMP']
        nosmp = 1
    except KeyError:
        nosmp = 0
if nosmp:
    config_sym.append(('NPY_ALLOW_THREADS', '0'))
else:
    config_sym.append(('NPY_ALLOW_THREADS', '1'))

env.Append(CPPPATH = [get_python_inc()])
config = env.NumpyConfigure(custom_tests = {'CheckTypeSize' : CheckTypeSize})

# TODO: check python extension can be built (in root or here ?)

#---------------
# Checking Types
#---------------
def check_type(type, include = None):
    st = config.CheckTypeSize(type, includes = include)
    type = type.replace(' ', '_')
    if st:
        config_sym.append(('SIZEOF_%s' % type.upper(), '%d' % st))
    else:
        config_sym.append(('SIZEOF_%s' % type.upper(), 0))
check_type('short')
check_type('int')
#check_type('long')
check_type('float')
check_type('double')
check_type('long double')
check_type('Py_intptr_t', include = ["Python.h"])

#-----------------------
# Checking configuration
#-----------------------

#----------------------
# Checking signal stuff
#----------------------
# TODO

#------------------------------------------
# Checking the mathlib and its capabilities
#------------------------------------------
# Function to check:
mfuncs = [('expl', 'HAVE_LONGDOUBLE_FUNCS'),
    ('expf', 'HAVE_FLOAT_FUNCS'),
    ('log1p', 'HAVE_LOG1P'),
    ('expm1', 'HAVE_EXPM1'),
    ('asinh', 'HAVE_INVERSE_HYPERBOLIC'),
    ('atanhf', 'HAVE_INVERSE_HYPERBOLIC_FLOAT'),
    ('atanhl', 'HAVE_INVERSE_HYPERBOLIC_LONGDOUBLE'),
    ('isnan', 'HAVE_ISNAN'),
    ('isinf', 'HAVE_ISINF'),
    ('rint', 'HAVE_RINT'),
    ]

# TODO: getting the math lib automatically ? Having a list ?
mathlib = os.environ.get('MATHLIB')
if mathlib: 
    # XXX: prepend it ?
    mlib = mathlib
else:
    mlib = 'm'
config_sym.append(('MATHLIB', str(mlib)))
for f in mfuncs:
    st = config.CheckLib(mlib, f[0])
    if st:
        config_sym.append((f[1], 1))
    else:
        config_sym.append((f[1], 0))

#--------------
# Checking Blas
#--------------
# TODO

config.Finish()

#--------------------------
# Generating multiarray API
#--------------------------
from scons_support import do_generate_api, generate_api_emitter

# XXX: put the builder in scons support lib.
bld = Builder(action = do_generate_api, emitter = generate_api_emitter)
env.Append(BUILDERS = {'GenerateApi' : bld})
from os.path import join as pjoin
multiarray_api = env.GenerateApi(pjoin(env['build_dir'], '__multiarray_api'), 
    [pjoin(env['src_dir'], 'code_generators', 'array_api_order.txt'),
    pjoin(env['src_dir'], 'code_generators', 'multiarray_api_order.txt')])

# Take into account the change in config_sym (using emitter, see SubstDic
# example in scons wiki) ?
env['config_h_gen'] = config_sym
bld = Builder(action = generate_config_header)
env.Append(BUILDERS = {'GenerateConfigHeader' : bld})
config_header = env.GenerateConfigHeader(pjoin(env['build_dir'], 'config.h'), [])

# Builder to generate .inc from .inc.src
from numpy.distutils.conv_template import process_str
def do_generate_from_template(targetfile, sourcefile, env):
    t = open(targetfile, 'w')
    s = open(sourcefile, 'r')
    allstr = s.read()
    s.close()
    writestr = process_str(allstr)
    t.write(writestr)
    t.close()
    return 0

def generate_from_template(target, source, env):
    for t, s in zip(target, source):
        do_generate_from_template(str(t), str(s), env)

def generate_from_template_emitter(target, source, env):
    base, ext = SCons.Util.splitext(pbasename(str(source[0])))
    t = pjoin(pdirname(str(target[0])), base)
    return ([t], source)
    
bld = Builder(action = generate_from_template, emitter = generate_from_template_emitter)
env.Append(BUILDERS = {'FromTemplate' : bld})

scalartypes_src = env.FromTemplate(pjoin(env['build_dir'], 'src', 'scalartypes'), 
                                   pjoin(env['src_dir'], 'src', 'scalartypes.inc.src'))
arraytypes_src = env.FromTemplate(pjoin(env['build_dir'], 'src', 'arraytypes'), 
                                   pjoin(env['src_dir'], 'src', 'arraytypes.inc.src'))

# Build multiarray
env.Append(CPPPATH = [pjoin(env['src_dir'], 'include'), env['build_dir']])
multiarray_src = [
    pjoin('src', 'multiarraymodule.c'),
]
multiarray = env.NumpyPythonExtension('multiarray', source = multiarray_src)

# Build sort module
sortmodule_src = env.FromTemplate(pjoin(env['build_dir'], 'src', '_sortmodule'), 
                                   pjoin(env['src_dir'], 'src', '_sortmodule.c.src'))
sort = env.NumpyPythonExtension('_sort', source = sortmodule_src)

# Build umath module
umathmodule_src = env.FromTemplate(pjoin(env['build_dir'], 'src', 'umathmodule'), 
                                   pjoin(env['src_dir'], 'src', 'umathmodule.c.src'))
sort = env.NumpyPythonExtension('_sort', source = sortmodule_src)

