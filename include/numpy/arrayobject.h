
/* This expects the following variables to be defined (besides
   the usual ones from pyconfig.h

   SIZEOF_LONG_DOUBLE -- sizeof(long double) or sizeof(double) if no
                         long double is present on platform.
   CHAR_BIT       --     number of bits in a char (usually 8)
                         (should be in limits.h)
*/

#ifndef Py_ARRAYOBJECT_H
#define Py_ARRAYOBJECT_H
#ifdef __cplusplus
#define CONFUSE_EMACS {
#define CONFUSE_EMACS2 }
extern "C" CONFUSE_EMACS
#undef CONFUSE_EMACS
#undef CONFUSE_EMACS2
/* ... otherwise a semi-smart idententer (like emacs) tries to indent
       everything when you're typing */
#endif
/* This is auto-generated by the installer */
#include "config.h"

/* There are several places in the code where an array of dimensions is */
/* allocated statically.  This is the size of that static allocation. */
/*  The array creation itself could have arbitrary dimensions but
 *  all the places where static allocation is used would need to
 *  be changed to dynamic (including inside of several structures)
 */

#define NPY_MAXDIMS 32

/* Used for Converter Functions "O&" code in ParseTuple */
#define NPY_FAIL 0
#define NPY_SUCCEED 1

        /* Helpful to distinguish what is installed */
#define NDARRAY_VERSION 0x00090908
#define NPY_VERSION NDARRAY_VERSION

	/* Some platforms don't define bool, long long, or long double.
	   Handle that here.
	 */

#ifdef PY_LONG_LONG
typedef PY_LONG_LONG npy_longlong;
typedef unsigned PY_LONG_LONG npy_ulonglong;
#  ifdef _MSC_VER
#    define NPY_LONGLONG_FMT         "I64d"
#    define NPY_ULONGLONG_FMT        "I64u"
#    define NPY_LONGLONG_SUFFIX(x)   (x##i64)
#    define NPY_ULONGLONG_SUFFIX(x)  (x##Ui64)
#  else
	/* #define LONGLONG_FMT   "lld"      Another possible variant
           #define ULONGLONG_FMT  "llu"

	   #define LONGLONG_FMT   "qd"   -- BSD perhaps?
	   #define ULONGLONG_FMT   "qu"
	*/
#    define NPY_LONGLONG_FMT         "Ld"
#    define NPY_ULONGLONG_FMT        "Lu"
#    define NPY_LONGLONG_SUFFIX(x)   (x##LL)
#    define NPY_ULONGLONG_SUFFIX(x)  (x##ULL)
#  endif
#else
typedef long npy_longlong;
typedef unsigned long npy_ulonglong;
#  define NPY_LONGLONG_SUFFIX(x)  (x##L)
#  define NPY_ULONGLONG_SUFFIX(x) (x##UL)
#endif


typedef unsigned char npy_bool;
#define NPY_FALSE 0
#define NPY_TRUE 1

#if SIZEOF_LONG_DOUBLE==SIZEOF_DOUBLE
	typedef double npy_longdouble;
        #define NPY_LONGDOUBLE_FMT "g"
#else
	typedef long double npy_longdouble;
        #define NPY_LONGDOUBLE_FMT "Lg"
#endif

#ifndef Py_USING_UNICODE
#error Must use Python with unicode enabled. 
#endif


typedef signed char npy_byte;
typedef unsigned char npy_ubyte;
typedef unsigned short npy_ushort;
typedef unsigned int npy_uint;
typedef unsigned long npy_ulong;

/* These are for completeness */
typedef float npy_float;
typedef double npy_double;
typedef short npy_short;
typedef int npy_int;
typedef long npy_long;


typedef struct { float real, imag; } npy_cfloat;
typedef struct { double real, imag; } npy_cdouble;
typedef struct {npy_longdouble real, imag;} npy_clongdouble;

enum PyArray_TYPES {    PyArray_BOOL=0,
                        PyArray_BYTE, PyArray_UBYTE,
		        PyArray_SHORT, PyArray_USHORT,
		        PyArray_INT, PyArray_UINT,
			PyArray_LONG, PyArray_ULONG,
                        PyArray_LONGLONG, PyArray_ULONGLONG,
			PyArray_FLOAT, PyArray_DOUBLE, PyArray_LONGDOUBLE,
			PyArray_CFLOAT, PyArray_CDOUBLE, PyArray_CLONGDOUBLE,
			PyArray_OBJECT=17,
                        PyArray_STRING, PyArray_UNICODE,
			PyArray_VOID,
			PyArray_NTYPES,
			PyArray_NOTYPE,
			PyArray_CHAR,      /* special flag */
			PyArray_USERDEF=256  /* leave room for characters */
};

	/* basetype array priority */
#define PyArray_PRIORITY 0.0
	/* default subtype priority */
#define PyArray_SUBTYPE_PRIORITY 1.0

	/* How many floating point types are there */
#define PyArray_NUM_FLOATTYPE 3


	/* We need to match npy_intp to a signed integer of the same size as
	   a pointer variable. npy_uintp to the equivalent unsigned integer
	*/


	/* These characters correspond to the array type and the
	   struct module */

	/*  except 'p' -- signed integer for pointer type */

enum PyArray_TYPECHAR { PyArray_BOOLLTR = '?',
			PyArray_BYTELTR = 'b',
			PyArray_UBYTELTR = 'B',
			PyArray_SHORTLTR = 'h',
			PyArray_USHORTLTR = 'H',
			PyArray_INTLTR = 'i',
			PyArray_UINTLTR = 'I',
			PyArray_LONGLTR = 'l',
			PyArray_ULONGLTR = 'L',
			PyArray_LONGLONGLTR = 'q',
			PyArray_ULONGLONGLTR = 'Q',
			PyArray_FLOATLTR = 'f',
			PyArray_DOUBLELTR = 'd',
			PyArray_LONGDOUBLELTR = 'g',
			PyArray_CFLOATLTR = 'F',
			PyArray_CDOUBLELTR = 'D',
			PyArray_CLONGDOUBLELTR = 'G',
			PyArray_OBJECTLTR = 'O',
			PyArray_STRINGLTR = 'S',
			PyArray_STRINGLTR2 = 'a',
			PyArray_UNICODELTR = 'U',
		        PyArray_VOIDLTR = 'V',
			PyArray_CHARLTR = 'c',

			/* No Descriptor, just a define -- this let's
			 Python users specify an array of integers
			 large enough to hold a pointer on the platform*/
			PyArray_INTPLTR = 'p',
			PyArray_UINTPLTR = 'P',

			PyArray_GENBOOLLTR ='b',
			PyArray_SIGNEDLTR = 'i',
			PyArray_UNSIGNEDLTR = 'u',
			PyArray_FLOATINGLTR = 'f',
			PyArray_COMPLEXLTR = 'c'
};

typedef enum {
	PyArray_QUICKSORT=0,
	PyArray_HEAPSORT=1,
	PyArray_MERGESORT=2,
} PyArray_SORTKIND;
#define PyArray_NSORTS PyArray_MERGESORT + 1


typedef enum {
	PyArray_NOSCALAR=-1,
	PyArray_BOOL_SCALAR,
	PyArray_INTPOS_SCALAR,
	PyArray_INTNEG_SCALAR,
	PyArray_FLOAT_SCALAR,
	PyArray_COMPLEX_SCALAR,
	PyArray_OBJECT_SCALAR,
} PyArray_SCALARKIND;
#define PyArray_NSCALARKINDS PyArray_OBJECT_SCALAR+1

typedef enum {
        PyArray_ANYORDER=-1,
        PyArray_CORDER=0,
        PyArray_FORTRANORDER=1
} PyArray_ORDER;


	/* Define bit-width array types and typedefs */

#define NPY_MAX_INT8 127
#define NPY_MIN_INT8 -128
#define NPY_MAX_UINT8 255
#define NPY_MAX_INT16 32767
#define NPY_MIN_INT16 -32768
#define NPY_MAX_UINT16 65535
#define NPY_MAX_INT32 2147483647
#define NPY_MIN_INT32 (-NPY_MAX_INT32 - 1)
#define NPY_MAX_UINT32 4294967295U
#define NPY_MAX_INT64 NPY_LONGLONG_SUFFIX(9223372036854775807)
#define NPY_MIN_INT64 (-NPY_MAX_INT64 - NPY_LONGLONG_SUFFIX(1))
#define NPY_MAX_UINT64 NPY_ULONGLONG_SUFFIX(18446744073709551615)
#define NPY_MAX_INT128 NPY_LONGLONG_SUFFIX(85070591730234615865843651857942052864)
#define NPY_MIN_INT128 (-NPY_MAX_INT128 - NPY_LONGLONG_SUFFIX(1))
#define NPY_MAX_UINT128 NPY_ULONGLONG_SUFFIX(170141183460469231731687303715884105728)
#define NPY_MAX_INT256 NPY_LONGLONG_SUFFIX(57896044618658097711785492504343953926634992332820282019728792003956564819967)
#define NPY_MIN_INT256 (-NPY_MAX_INT256 - NPY_LONGLONG_SUFFIX(1))
#define NPY_MAX_UINT256 NPY_ULONGLONG_SUFFIX(115792089237316195423570985008687907853269984665640564039457584007913129639935)

	/* Need to find the number of bits for each type and
	   make definitions accordingly.

	   C states that sizeof(char) == 1 by definition

	   So, just using the sizeof keyword won't help.

	   It also looks like Python itself uses sizeof(char) quite a
	   bit, which by definition should be 1 all the time.

	   Idea: Make Use of CHAR_BIT which should tell us how many
	   BITS per CHARACTER
	*/

	/* Include platform definitions -- These are in the C89/90 standard */
#include <limits.h>
#define NPY_MAX_BYTE SCHAR_MAX
#define NPY_MIN_BYTE SCHAR_MIN
#define NPY_MAX_UBYTE UCHAR_MAX
#define NPY_MAX_SHORT SHRT_MAX
#define NPY_MIN_SHORT SHRT_MIN
#define NPY_MAX_USHORT USHRT_MAX
#define NPY_MAX_INT   INT_MAX
#ifndef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#endif
#define NPY_MIN_INT   INT_MIN
#define NPY_MAX_UINT  UINT_MAX
#define NPY_MAX_LONG  LONG_MAX
#define NPY_MIN_LONG  LONG_MIN
#define NPY_MAX_ULONG  ULONG_MAX


#define NPY_SIZEOF_LONG SIZEOF_LONG
#define NPY_SIZEOF_INT SIZEOF_INT
#define NPY_SIZEOF_SHORT SIZEOF_SHORT
#define NPY_SIZEOF_FLOAT SIZEOF_FLOAT
#define NPY_SIZEOF_DOUBLE SIZEOF_DOUBLE
#define NPY_SIZEOF_LONGDOUBLE SIZEOF_LONG_DOUBLE
#define NPY_SIZEOF_LONGLONG SIZEOF_LONG_LONG
#define NPY_BITSOF_BOOL sizeof(npy_bool)*CHAR_BIT
#define NPY_BITSOF_CHAR CHAR_BIT
#define NPY_BITSOF_SHORT (SIZEOF_SHORT*CHAR_BIT)
#define NPY_BITSOF_INT (SIZEOF_INT*CHAR_BIT)
#define NPY_BITSOF_LONG (SIZEOF_LONG*CHAR_BIT)
#define NPY_BITSOF_LONGLONG (NPY_SIZEOF_LONGLONG*CHAR_BIT)
#define NPY_BITSOF_FLOAT (SIZEOF_FLOAT*CHAR_BIT)
#define NPY_BITSOF_DOUBLE (SIZEOF_DOUBLE*CHAR_BIT)
#define NPY_BITSOF_LONGDOUBLE (NPY_SIZEOF_LONGDOUBLE*CHAR_BIT)

#if NPY_BITSOF_LONG == 8
#define PyArray_INT8 PyArray_LONG
#define PyArray_UINT8 PyArray_ULONG
	typedef long npy_int8;
	typedef unsigned long npy_uint8;
#elif NPY_BITSOF_LONG == 16
#define PyArray_INT16 PyArray_LONG
#define PyArray_UINT16 PyArray_ULONG
	typedef long npy_int16;
	typedef unsigned long npy_uint16;
#elif NPY_BITSOF_LONG == 32
#define PyArray_INT32 PyArray_LONG
#define PyArray_UINT32 PyArray_ULONG
	typedef long npy_int32;
	typedef unsigned long npy_uint32;
	typedef unsigned long npy_ucs4;
#elif NPY_BITSOF_LONG == 64
#define PyArray_INT64 PyArray_LONG
#define PyArray_UINT64 PyArray_ULONG
	typedef long npy_int64;
	typedef unsigned long npy_uint64;
#elif NPY_BITSOF_LONG == 128
#define PyArray_INT128 PyArray_LONG
#define PyArray_UINT128 PyArray_ULONG
	typedef long npy_int128;
	typedef unsigned long npy_uint128;
#endif

#if NPY_BITSOF_LONGLONG == 8
#  ifndef PyArray_INT8
#    define PyArray_INT8 PyArray_LONGLONG
#    define PyArray_UINT8 PyArray_ULONGLONG
	typedef npy_longlong npy_int8;
	typedef npy_ulonglong npy_uint8;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT8
#  define NPY_MIN_LONGLONG NPY_MIN_INT8
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT8
#elif NPY_BITSOF_LONGLONG == 16
#  ifndef PyArray_INT16
#    define PyArray_INT16 PyArray_LONGLONG
#    define PyArray_UINT16 PyArray_ULONGLONG
	typedef npy_longlong npy_int16;
	typedef npy_ulonglong npy_uint16;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT16
#  define NPY_MIN_LONGLONG NPY_MIN_INT16
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT16
#elif NPY_BITSOF_LONGLONG == 32
#  ifndef PyArray_INT32
#    define PyArray_INT32 PyArray_LONGLONG
#    define PyArray_UINT32 PyArray_ULONGLONG
	typedef npy_longlong npy_int32;
	typedef npy_ulonglong npy_uint32;
	typedef npy_ulonglong npy_ucs4;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT32
#  define NPY_MIN_LONGLONG NPY_MIN_INT32
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT32
#elif NPY_BITSOF_LONGLONG == 64
#  ifndef PyArray_INT64
#    define PyArray_INT64 PyArray_LONGLONG
#    define PyArray_UINT64 PyArray_ULONGLONG
	typedef npy_longlong npy_int64;
	typedef npy_ulonglong npy_uint64;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT64
#  define NPY_MIN_LONGLONG NPY_MIN_INT64
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT64
#elif NPY_BITSOF_LONGLONG == 128
#  ifndef PyArray_INT128
#    define PyArray_INT128 PyArray_LONGLONG
#    define PyArray_UINT128 PyArray_ULONGLONG
	typedef npy_longlong npy_int128;
	typedef npy_ulonglong npy_uint128;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT128
#  define NPY_MIN_LONGLONG NPY_MIN_INT128
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT128
#elif NPY_BITSOF_LONGLONG == 256
#  define PyArray_INT256 PyArray_LONGLONG
#  define PyArray_UINT256 PyArray_ULONGLONG
	typedef npy_longlong npy_int256;
	typedef npy_ulonglong npy_uint256;
#  define NPY_MAX_LONGLONG NPY_MAX_INT256
#  define NPY_MIN_LONGLONG NPY_MIN_INT256
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT256
#endif

#if NPY_BITSOF_INT == 8
#ifndef PyArray_INT8
#define PyArray_INT8 PyArray_INT
#define PyArray_UINT8 PyArray_UINT
	typedef int npy_int8;
	typedef unsigned int npy_uint8;
#endif
#elif NPY_BITSOF_INT == 16
#ifndef PyArray_INT16
#define PyArray_INT16 PyArray_INT
#define PyArray_UINT16 PyArray_UINT
	typedef int npy_int16;
	typedef unsigned int npy_uint16;
#endif
#elif NPY_BITSOF_INT == 32
#ifndef PyArray_INT32
#define PyArray_INT32 PyArray_INT
#define PyArray_UINT32 PyArray_UINT
	typedef int npy_int32;
	typedef unsigned int npy_uint32;
        typedef unsigned int npy_ucs4;
#endif
#elif NPY_BITSOF_INT == 64
#ifndef PyArray_INT64
#define PyArray_INT64 PyArray_INT
#define PyArray_UINT64 PyArray_UINT
	typedef int npy_int64;
	typedef unsigned int npy_uint64;
#endif
#elif NPY_BITSOF_INT == 128
#ifndef PyArray_INT128
#define PyArray_INT128 PyArray_INT
#define PyArray_UINT128 PyArray_UINT
	typedef int npy_int128;
	typedef unsigned int npy_uint128;
#endif
#endif

#if NPY_BITSOF_SHORT == 8
#ifndef PyArray_INT8
#define PyArray_INT8 PyArray_SHORT
#define PyArray_UINT8 PyArray_USHORT
	typedef short npy_int8;
	typedef unsigned short npy_uint8;
#endif
#elif NPY_BITSOF_SHORT == 16
#ifndef PyArray_INT16
#define PyArray_INT16 PyArray_SHORT
#define PyArray_UINT16 PyArray_USHORT
	typedef short npy_int16;
	typedef unsigned short npy_uint16;
#endif
#elif NPY_BITSOF_SHORT == 32
#ifndef PyArray_INT32
#define PyArray_INT32 PyArray_SHORT
#define PyArray_UINT32 PyArray_USHORT
	typedef short npy_int32;
	typedef unsigned short npy_uint32;
	typedef unsigned short npy_ucs4;
#endif
#elif NPY_BITSOF_SHORT == 64
#ifndef PyArray_INT64
#define PyArray_INT64 PyArray_SHORT
#define PyArray_UINT64 PyArray_USHORT
	typedef short npy_int64;
	typedef unsigned short npy_uint64;
#endif
#elif NPY_BITSOF_SHORT == 128
#ifndef PyArray_INT128
#define PyArray_INT128 PyArray_SHORT
#define PyArray_UINT128 PyArray_USHORT
	typedef short npy_int128;
	typedef unsigned short npy_uint128;
#endif
#endif


#if NPY_BITSOF_CHAR == 8
#ifndef PyArray_INT8
#define PyArray_INT8 PyArray_BYTE
#define PyArray_UINT8 PyArray_UBYTE
	typedef signed char npy_int8;
	typedef unsigned char npy_uint8;
#endif
#elif NPY_BITSOF_CHAR == 16
#ifndef PyArray_INT16
#define PyArray_INT16 PyArray_BYTE
#define PyArray_UINT16 PyArray_UBYTE
	typedef signed char npy_int16;
	typedef unsigned char npy_uint16;
#endif
#elif NPY_BITSOF_CHAR == 32
#ifndef PyArray_INT32
#define PyArray_INT32 PyArray_BYTE
#define PyArray_UINT32 PyArray_UBYTE
	typedef signed char npy_int32;
	typedef unsigned char npy_uint32;
	typedef unsigned char npy_ucs4;
#endif
#elif NPY_BITSOF_CHAR == 64
#ifndef PyArray_INT64
#define PyArray_INT64 PyArray_BYTE
#define PyArray_UINT64 PyArray_UBYTE
	typedef signed char npy_int64;
	typedef unsigned char npy_uint64;
#endif
#elif NPY_BITSOF_CHAR == 128
#ifndef PyArray_INT128
#define PyArray_INT128 PyArray_BYTE
#define PyArray_UINT128 PyArray_UBYTE
	typedef signed char npy_int128;
	typedef unsigned char npy_uint128;
#endif
#endif



#if NPY_BITSOF_DOUBLE == 16
#ifndef PyArray_FLOAT16
#define PyArray_FLOAT16 PyArray_DOUBLE
#define PyArray_COMPLEX32 PyArray_CDOUBLE
	typedef  double npy_float16;
	typedef npy_cdouble npy_complex32;
#endif
#elif NPY_BITSOF_DOUBLE == 32
#ifndef PyArray_FLOAT32
#define PyArray_FLOAT32 PyArray_DOUBLE
#define PyArray_COMPLEX64 PyArray_CDOUBLE
	typedef double npy_float32;
	typedef npy_cdouble npy_complex64;
#endif
#elif NPY_BITSOF_DOUBLE == 64
#ifndef PyArray_FLOAT64
#define PyArray_FLOAT64 PyArray_DOUBLE
#define PyArray_COMPLEX128 PyArray_CDOUBLE
	typedef double npy_float64;
	typedef npy_cdouble npy_complex128;
#endif
#elif NPY_BITSOF_DOUBLE == 80
#ifndef PyArray_FLOAT80
#define PyArray_FLOAT80 PyArray_DOUBLE
#define PyArray_COMPLEX160 PyArray_CDOUBLE
	typedef double npy_float80;
	typedef npy_cdouble npy_complex160;
#endif
#elif NPY_BITSOF_DOUBLE == 96
#ifndef PyArray_FLOAT96
#define PyArray_FLOAT96 PyArray_DOUBLE
#define PyArray_COMPLEX192 PyArray_CDOUBLE
	typedef double npy_float96;
	typedef npy_cdouble npy_complex192;
#endif
#elif NPY_BITSOF_DOUBLE == 128
#ifndef PyArray_FLOAT128
#define PyArray_FLOAT128 PyArray_DOUBLE
#define PyArray_COMPLEX256 PyArray_CDOUBLE
	typedef double npy_float128;
	typedef npy_cdouble npy_complex256;
#endif
#endif



#if NPY_BITSOF_FLOAT == 16
#ifndef PyArray_FLOAT16
#define PyArray_FLOAT16 PyArray_FLOAT
#define PyArray_COMPLEX32 PyArray_CFLOAT
	typedef float npy_float16;
	typedef npy_cfloat npy_complex32;
#endif
#elif NPY_BITSOF_FLOAT == 32
#ifndef PyArray_FLOAT32
#define PyArray_FLOAT32 PyArray_FLOAT
#define PyArray_COMPLEX64 PyArray_CFLOAT
	typedef float npy_float32;
	typedef npy_cfloat npy_complex64;
#endif
#elif NPY_BITSOF_FLOAT == 64
#ifndef PyArray_FLOAT64
#define PyArray_FLOAT64 PyArray_FLOAT
#define PyArray_COMPLEX128 PyArray_CFLOAT
	typedef float npy_float64;
	typedef npy_cfloat npy_complex128;
#endif
#elif NPY_BITSOF_FLOAT == 80
#ifndef PyArray_FLOAT80
#define PyArray_FLOAT80 PyArray_FLOAT
#define PyArray_COMPLEX160 PyArray_CFLOAT
	typedef float npy_float80;
	typedef npy_cfloat npy_complex160;
#endif
#elif NPY_BITSOF_FLOAT == 96
#ifndef PyArray_FLOAT96
#define PyArray_FLOAT96 PyArray_FLOAT
#define PyArray_COMPLEX192 PyArray_CFLOAT
	typedef float npy_float96;
	typedef npy_cfloat npy_complex192;
#endif
#elif NPY_BITSOF_FLOAT == 128
#ifndef PyArray_FLOAT128
#define PyArray_FLOAT128 PyArray_FLOAT
#define PyArray_COMPLEX256 PyArray_CFLOAT
	typedef float npy_float128;
	typedef npy_cfloat npy_complex256;
#endif
#endif


#if NPY_BITSOF_LONGDOUBLE == 16
#ifndef PyArray_FLOAT16
#define PyArray_FLOAT16 PyArray_LONGDOUBLE
#define PyArray_COMPLEX32 PyArray_CLONGDOUBLE
	typedef npy_longdouble npy_float16;
	typedef npy_clongdouble npy_complex32;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 32
#ifndef PyArray_FLOAT32
#define PyArray_FLOAT32 PyArray_LONGDOUBLE
#define PyArray_COMPLEX64 PyArray_CLONGDOUBLE
	typedef npy_longdouble npy_float32;
	typedef npy_clongdouble npy_complex64;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 64
#ifndef PyArray_FLOAT64
#define PyArray_FLOAT64 PyArray_LONGDOUBLE
#define PyArray_COMPLEX128 PyArray_CLONGDOUBLE
	typedef npy_longdouble npy_float64;
	typedef npy_clongdouble npy_complex128;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 80
#ifndef PyArray_FLOAT80
#define PyArray_FLOAT80 PyArray_LONGDOUBLE
#define PyArray_COMPLEX160 PyArray_CLONGDOUBLE
	typedef npy_longdouble npy_float80;
	typedef npy_clongdouble npy_complex160;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 96
#ifndef PyArray_FLOAT96
#define PyArray_FLOAT96 PyArray_LONGDOUBLE
#define PyArray_COMPLEX192 PyArray_CLONGDOUBLE
	typedef npy_longdouble npy_float96;
	typedef npy_clongdouble npy_complex192;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 128
#ifndef PyArray_FLOAT128
#define PyArray_FLOAT128 PyArray_LONGDOUBLE
#define PyArray_COMPLEX256 PyArray_CLONGDOUBLE
	typedef npy_longdouble npy_float128;
	typedef npy_clongdouble npy_complex256;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 256
#define PyArray_FLOAT256 PyArray_LONGDOUBLE
#define PyArray_COMPLEX512 PyArray_CLONGDOUBLE
	typedef npy_longdouble npy_float256;
	typedef npy_clongdouble npy_complex512;
#endif

	/* End of typedefs for numarray style bit-width names */

/* This is to typedef npy_intp to the appropriate pointer size for this platform.
 * Py_intptr_t, Py_uintptr_t are defined in pyport.h. */
typedef Py_intptr_t npy_intp;
typedef Py_uintptr_t npy_uintp;
#define NPY_SIZEOF_INTP SIZEOF_PY_INTPTR_T
#define NPY_SIZEOF_UINTP SIZEOF_PY_INTPTR_T

#if (PY_VERSION_HEX < 0x02050000)
typedef int Py_ssize_t;
#define PY_SSIZE_T_MAX INT_MAX
#define PY_SSIZE_T_MIN INT_MIN
#endif

#if SIZEOF_PY_INTPTR_T == SIZEOF_INT
	#define PyArray_INTP PyArray_INT
	#define PyArray_UINTP PyArray_UINT
        #define PyIntpArrType_Type PyIntArrType_Type
        #define PyUIntpArrType_Type PyUIntArrType_Type
	#define NPY_MAX_INTP NPY_MAX_INT
	#define NPY_MIN_INTP NPY_MIN_INT
	#define NPY_MAX_UINTP NPY_MAX_UINT
        #define NPY_INTP_FMT "d"
#elif SIZEOF_PY_INTPTR_T == SIZEOF_LONG
	#define PyArray_INTP PyArray_LONG
	#define PyArray_UINTP PyArray_ULONG
        #define PyIntpArrType_Type PyLongArrType_Type
        #define PyUIntpArrType_Type PyULongArrType_Type
	#define NPY_MAX_INTP NPY_MAX_LONG
	#define NPY_MIN_INTP MIN_LONG
	#define NPY_MAX_UINTP NPY_MAX_ULONG
        #define NPY_INTP_FMT "ld"
#elif defined(PY_LONG_LONG) && (SIZEOF_PY_INTPTR_T == SIZEOF_LONG_LONG)
	#define PyArray_INTP PyArray_LONGLONG
	#define PyArray_UINTP PyArray_ULONGLONG
        #define PyIntpArrType_Type PyLongLongArrType_Type
        #define PyUIntpArrType_Type PyULongLongArrType_Type
	#define NPY_MAX_INTP NPY_MAX_LONGLONG
	#define NPY_MIN_INTP NPY_MIN_LONGLONG
	#define NPY_MAX_UINTP NPY_MAX_ULONGLONG
        #define NPY_INTP_FMT "Ld"
#endif

#define NPY_ERR(str) fprintf(stderr, #str); fflush(stderr);
#define NPY_ERR2(str) fprintf(stderr, str); fflush(stderr);

#define NPY_STRINGIFY(x) #x
#define NPY_TOSTRING(x) NPY_STRINGIFY(x)

  /* Macros to define how array, and dimension/strides data is
     allocated.
  */

  /* Data buffer */
#define PyDataMem_NEW(size) ((char *)malloc(size))
  /* #define PyArrayMem_NEW(size) PyMem_NEW(char, size)*/
#define PyDataMem_FREE(ptr)  free(ptr)
  /* #define PyArrayMem_FREE(ptr) PyMem_Free(ptr) */
#define PyDataMem_RENEW(ptr,size) ((char *)realloc(ptr,size))

#define PyArray_USE_PYMEM 0

#if PyArray_USE_PYMEM == 1
#define npy_malloc PyObject_Malloc
#define npy_free PyObject_Free
#define npy_realloc PyObject_Realloc
#else
#define npy_malloc malloc
#define npy_free free
#define npy_realloc realloc
#endif

/* Dimensions and strides */
#define PyDimMem_NEW(size) ((npy_intp *)npy_malloc(size*sizeof(npy_intp)))
#define PyDimMem_FREE(ptr) npy_free(ptr)
#define PyDimMem_RENEW(ptr,size) ((npy_intp *)npy_realloc(ptr,size*sizeof(npy_intp)))


  /* These must deal with unaligned and swapped data if necessary */
typedef PyObject * (PyArray_GetItemFunc) (void *, void *);
typedef int (PyArray_SetItemFunc)(PyObject *, void *, void *);

typedef void (PyArray_CopySwapNFunc)(void *, npy_intp, void *, npy_intp, npy_intp, int, void *);
typedef void (PyArray_CopySwapFunc)(void *, void *, int, void *);
typedef npy_bool (PyArray_NonzeroFunc)(void *, void *);


  /* These assume aligned and notswapped data -- a buffer will be
      used before or contiguous data will be obtained
  */
typedef int (PyArray_CompareFunc)(const void *, const void *, void *);
typedef int (PyArray_ArgFunc)(void*, npy_intp, npy_intp*, void *);
typedef void (PyArray_DotFunc)(void *, npy_intp, void *, npy_intp, void *, npy_intp,
			       void *);
typedef void (PyArray_VectorUnaryFunc)(void *, void *, npy_intp, void *, void *);
typedef int (PyArray_ScanFunc)(FILE *, void *, void *, void *);
typedef int (PyArray_FromStrFunc)(char *, void *, char **, void *);

typedef int (PyArray_FillFunc)(void *, npy_intp, void *);

typedef int (PyArray_SortFunc)(void *, npy_intp, void *);
typedef int (PyArray_ArgSortFunc)(void *, npy_intp *, npy_intp, void *);

typedef int (PyArray_FillWithScalarFunc)(void *, npy_intp, void *, void *);

typedef int (PyArray_ScalarKindFunc)(void *);

typedef struct {
        npy_intp *ptr;
        int len;
} PyArray_Dims;

typedef struct {
	/* Functions to cast to all other standard types*/
	/* Can have some NULL entries */
	PyArray_VectorUnaryFunc *cast[PyArray_NTYPES];

	/* The next four functions *cannot* be NULL */

	/* Functions to get and set items with standard
	   Python types -- not array scalars */
	PyArray_GetItemFunc *getitem;
	PyArray_SetItemFunc *setitem;

	/* Copy and/or swap data.  Memory areas may not overlap */
	/*  Use memmove first if they might */
	PyArray_CopySwapNFunc *copyswapn;
        PyArray_CopySwapFunc *copyswap;

	/* Function to compare items */
	/* Can be NULL 
	 */
	PyArray_CompareFunc *compare;

	/* Function to select largest 
	   Can be NULL
	*/
	PyArray_ArgFunc *argmax;

	/* Function to compute dot product */
	/* Can be NULL */
	PyArray_DotFunc	*dotfunc;

	/* Function to scan an ASCII file and
	   place a single value plus possible separator 
	   Can be NULL 
	*/
	PyArray_ScanFunc *scanfunc;

	/* Function to read a single value from a string */
	/* and adjust the pointer; Can be NULL */
	PyArray_FromStrFunc *fromstr;

	/* Function to determine if data is zero or not */
	/* If NULL a default version is */
	/* used at Registration time. */
	PyArray_NonzeroFunc *nonzero;

	/* Used for arange. Can be NULL.*/
	PyArray_FillFunc *fill;

	/* Function to fill arrays with scalar values 
	 Can be NULL*/
	PyArray_FillWithScalarFunc *fillwithscalar;

	/* Sorting functions; Can be NULL*/
	PyArray_SortFunc *sort[PyArray_NSORTS];
	PyArray_ArgSortFunc *argsort[PyArray_NSORTS];

	/* Dictionary of additional casting functions
	   PyArray_VectorUnaryFuncs
	   which can be populated to support casting
	   to other registered types. Can be NULL*/
	PyObject *castdict;

	/* Functions useful for generalizing
	   the casting rules.  Can be NULL;
	*/
	PyArray_ScalarKindFunc *scalarkind;
	int **cancastscalarkindto;
	int *cancastto;

	/* Set to 1 if you want pickles of this type
	   to go out as lists of _getitem objects
	*/
	int listpickle;

} PyArray_ArrFuncs;


typedef struct {
	PyObject_HEAD
	PyTypeObject *typeobj;  /* the type object representing an
				   instance of this type -- should not
				   be two type_numbers with the same type
				   object. */
	char kind;              /* kind for this type */
	char type;              /* unique-character representing this type */
	char byteorder;         /* '>' (big), '<' (little), '|'
				   (not-applicable), or '=' (native). */
        char hasobject;        /* non-zero if it has object arrays in fields */
	int type_num;          /* number representing this type */
	int elsize;             /* element size for this type */
	int alignment;          /* alignment needed for this type */
	struct _arr_descr					\
	*subarray;              /* Non-NULL if this type is
				   is an array (C-contiguous)
				   of some other type
				*/
	PyObject *fields;       /* The fields dictionary for this type */
	                        /* For statically defined descr this
				   is always Py_None */

	PyArray_ArrFuncs *f;     /* a table of functions specific for each
				    basic data descriptor */
} PyArray_Descr;

typedef struct _arr_descr {
	PyArray_Descr *base;
	PyObject *shape;       /* a tuple */
} PyArray_ArrayDescr;

/*
  The main array object structure. It is recommended to use the macros
  defined below (PyArray_DATA and friends) access fields here, instead
  of the members themselves.
 */

typedef struct PyArrayObject {
	PyObject_HEAD
	char *data;             /* pointer to raw data buffer */
	int nd;                 /* number of dimensions, also called ndim */
	npy_intp *dimensions;       /* size in each dimension */
        npy_intp *strides;          /* bytes to jump to get to the
				   next element in each dimension */
	PyObject *base;         /* This object should be decref'd
				   upon deletion of array */
	                        /* For views it points to the original array */
	                        /* For creation from buffer object it points
				   to an object that shold be decref'd on
				   deletion */
	                        /* For UPDATEIFCOPY flag this is an array
				   to-be-updated upon deletion of this one */
	PyArray_Descr *descr;   /* Pointer to type structure */
	int flags;              /* Flags describing array -- see below*/
	PyObject *weakreflist;  /* For weakreferences */
} PyArrayObject;

#define NPY_AO PyArrayObject

#define fortran fortran_        /* For some compilers */

/* Mirrors buffer object to ptr */

typedef struct {
        PyObject_HEAD
        PyObject *base;
        void *ptr;
        npy_intp len;
        int flags;
} PyArray_Chunk;

typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);

/* Means c-style contiguous (last index varies the fastest). The
   data elements right after each other. */
#define NPY_CONTIGUOUS    0x0001
/* set if array is a contiguous Fortran array: the first index
   varies the fastest in memory (strides array is reverse of
   C-contiguous array)*/
#define NPY_FORTRAN       0x0002

/*
  Note: all 0-d arrays are CONTIGUOUS and FORTRAN contiguous. If a
   1-d array is CONTIGUOUS it is also FORTRAN contiguous
*/

/* If set, the array owns the data: it will be free'd when the array
   is deleted. */
#define NPY_OWNDATA       0x0004

/* An array never has the next four set; they're only used as parameter
   flags to the the various FromAny functions */

/* Cause a cast to occur regardless of whether or not it is safe. */
#define NPY_FORCECAST     0x0010

/* Always copy the array. Returned arrays are always CONTIGUOUS, ALIGNED,
   and WRITEABLE. */
#define NPY_ENSURECOPY    0x0020

/* Make sure the returned array is an ndarray or a bigndarray */
#define NPY_ENSUREARRAY   0x0040

/* Make sure that the strides are in units of the element size
   Needed for some operations with record-arrays.
*/
#define NPY_ELEMENTSTRIDES 0x0080

/* Array data is aligned on the appropiate memory address for the
   type stored according to how the compiler would align things
   (e.g., an array of integers (4 bytes each) starts on
   a memory address that's a multiple of 4) */
#define NPY_ALIGNED       0x0100
/* Array data has the native endianness */
#define NPY_NOTSWAPPED    0x0200
/* Array data is writeable */
#define NPY_WRITEABLE     0x0400
/* If this flag is set, then base contains a pointer to an array of
   the same size that should be updated with the current contents of
   this array when this array is deallocated
*/
#define NPY_UPDATEIFCOPY  0x1000

/* This flag is for the array interface */
#define NPY_ARR_HAS_DESCR  0x0800


#define NPY_BEHAVED NPY_ALIGNED | NPY_WRITEABLE
#define NPY_BEHAVED_NS NPY_ALIGNED | NPY_WRITEABLE | NPY_NOTSWAPPED
#define NPY_CARRAY NPY_CONTIGUOUS | NPY_BEHAVED
#define NPY_CARRAY_RO NPY_CONTIGUOUS | NPY_ALIGNED
#define NPY_FARRAY NPY_FORTRAN | NPY_BEHAVED
#define NPY_FARRAY_RO NPY_FORTRAN | NPY_ALIGNED
#define NPY_DEFAULT NPY_CARRAY
#define NPY_IN_ARRAY NPY_CARRAY_RO
#define NPY_OUT_ARRAY NPY_CARRAY 
#define NPY_INOUT_ARRAY NPY_CARRAY | NPY_UPDATEIFCOPY
#define NPY_IN_FARRAY NPY_FARRAY_RO
#define NPY_OUT_FARRAY NPY_FARRAY
#define NPY_INOUT_FARRAY NPY_FARRAY | NPY_UPDATEIFCOPY

#define NPY_UPDATE_ALL NPY_CONTIGUOUS | NPY_FORTRAN | NPY_ALIGNED


/* Size of internal buffers used for alignment */
/* Make BUFSIZE a multiple of sizeof(cdouble) -- ususally 16 */
/* So that ufunc buffers are aligned */
#define PyArray_MIN_BUFSIZE sizeof(cdouble)
#define PyArray_MAX_BUFSIZE sizeof(cdouble)*1000000
#define PyArray_BUFSIZE 10000


/*
 * C API:  consists of Macros and functions.  The MACROS are defined here.
 */


#define PyArray_CHKFLAGS(m, FLAGS) \
	((((PyArrayObject *)(m))->flags & (FLAGS)) == (FLAGS))
#define PyArray_ISCONTIGUOUS(m) PyArray_CHKFLAGS(m, NPY_CONTIGUOUS)
#define PyArray_ISWRITEABLE(m) PyArray_CHKFLAGS(m, NPY_WRITEABLE)
#define PyArray_ISALIGNED(m) PyArray_CHKFLAGS(m, NPY_ALIGNED)

#define NPY_MAX(a,b) (((a)>(b))?(a):(b))
#define NPY_MIN(a,b) (((a)<(b))?(a):(b))

#if defined(ALLOW_THREADS)
#define NPY_BEGIN_THREADS_DEF PyThreadState *_save;
#define NPY_BEGIN_THREADS _save = PyEval_SaveThread();
#define NPY_END_THREADS   PyEval_RestoreThread(_save);
#define NPY_ALLOW_C_API_DEF  PyGILState_STATE __save__;
#define NPY_ALLOW_C_API      __save__ = PyGILState_Ensure();
#define NPY_DISABLE_C_API    PyGILState_Release(__save__);
#else
#define NPY_BEGIN_THREADS_DEF
#define NPY_BEGIN_THREADS
#define NPY_END_THREADS
#define NPY_ALLOW_C_API_DEF
#define	NPY_ALLOW_C_API
#define	NPY_DISABLE_C_API
#endif

typedef struct {
        PyObject_HEAD
	int               nd_m1;            /* number of dimensions - 1 */
        npy_intp	  index, size;
	npy_intp          coordinates[NPY_MAXDIMS];/* N-dimensional loop */
        npy_intp          dims_m1[NPY_MAXDIMS];    /* ao->dimensions - 1 */
	npy_intp          strides[NPY_MAXDIMS];    /* ao->strides or fake */
	npy_intp          backstrides[NPY_MAXDIMS];/* how far to jump back */
	npy_intp          factors[NPY_MAXDIMS];     /* shape factors */
	PyArrayObject     *ao;
	char              *dataptr;        /* pointer to current item*/
        npy_bool          contiguous;
} PyArrayIterObject;


/* Iterator API */
#define PyArrayIter_Check(op) PyObject_TypeCheck(op, &PyArrayIter_Type)

#define PyArray_ITER_RESET(it) {					\
	it->index = 0;						        \
	it->dataptr = it->ao->data;					\
	memset(it->coordinates, 0, (it->nd_m1+1)*sizeof(npy_intp));		\
}

#define _PyArray_ITER_NEXT1(it) {		\
		it->dataptr += it->strides[0];	\
		it->coordinates[0]++;		\
	}

#define _PyArray_ITER_NEXT2(it) {					\
		if (it->coordinates[1] < it->dims_m1[1]) {		\
			it->coordinates[1]++;				\
			it->dataptr += it->strides[1];			\
		}							\
		else {							\
			it->coordinates[1] = 0;				\
			it->coordinates[0]++;				\
			it->dataptr += it->strides[0] -			\
				it->backstrides[1];			\
		}							\
	}

#define PyArray_ITER_NEXT(it) {						\
	it->index++;						        \
        if (it->nd_m1 == 0) {						\
		_PyArray_ITER_NEXT1(it);				\
	}								\
	else if (it->contiguous)  it->dataptr += it->ao->descr->elsize; \
	else if (it->nd_m1 == 1) {					\
		_PyArray_ITER_NEXT2(it);				\
	}								\
	else {								\
		int _i_;						\
		for (_i_ = it->nd_m1; _i_ >= 0; _i_--) {		\
			if (it->coordinates[_i_] <			\
			    it->dims_m1[_i_]) {				\
				it->coordinates[_i_]++;			\
				it->dataptr += it->strides[_i_];	\
				break;					\
			}						\
			else {						\
				it->coordinates[_i_] = 0;		\
				it->dataptr -= it->backstrides[_i_];	\
			}						\
		}							\
	}								\
}

#define PyArray_ITER_GOTO(it, destination) {				\
		int _i_;						\
		it->index = 0;						\
		it->dataptr = it->ao->data;				\
		for (_i_ = it->nd_m1; _i_>=0; _i_--) {			\
                        if (destination[_i_] < 0) {                     \
                                destination[_i_] += it->dims_m1[_i_]+1; \
                        }                                               \
			it->dataptr += destination[_i_] *		\
				it->strides[_i_];			\
			it->coordinates[_i_] = destination[_i_];	\
			it->index += destination[_i_] *			\
				( _i_==it->nd_m1 ? 1 :			\
				  it->dims_m1[_i_+1]+1) ;		        \
		}							\
	}

#define PyArray_ITER_GOTO1D(it, ind) {                                  \
		int _i_;						\
		npy_intp _lind_ = (npy_intp) (ind);				\
                if (_lind_ < 0) _lind_ += it->size;                     \
		it->index = _lind_;					\
                if (it->nd_m1 == 0) {                                   \
                        it->dataptr = it->ao->data + _lind_ *           \
                                it->strides[0];                         \
                }                                                       \
                else if (it->contiguous)                                \
			it->dataptr = it->ao->data + _lind_ *		\
				it->ao->descr->elsize;			\
		else {							\
			it->dataptr = it->ao->data;			\
			for (_i_ = 0; _i_<=it->nd_m1; _i_++) {		\
				it->dataptr += (_lind_ / it->factors[_i_]) \
					* it->strides[_i_];		\
				_lind_ %= it->factors[_i_];		\
			}						\
		}							\
}

#define PyArray_ITER_DATA(it) ((PyArrayIterObject *)it)->dataptr


/*
   Any object passed to PyArray_Broadcast must be binary compatible with
   this structure.
*/

typedef struct {
	PyObject_HEAD
	int                  numiter;                 /* number of iters */
	npy_intp             size;                    /* broadcasted size */
	npy_intp             index;                   /* current index */
	int                  nd;                      /* number of dims */
	npy_intp             dimensions[NPY_MAXDIMS]; /* dimensions */
	PyArrayIterObject    *iters[NPY_MAXDIMS];     /* iterators */
} PyArrayMultiIterObject;

#define PyArray_MultiIter_RESET(multi) {			  \
		int _mi_;					  \
		PyArrayMultiIterObject *_mul_ = (multi);	  \
		_mul_->index = 0;				  \
		for (_mi_ = 0; _mi_ < _mul_->numiter; _mi_++) {	  \
			PyArray_ITER_RESET(_mul_->iters[_mi_]);	  \
		}						  \
	}

#define PyArray_MultiIter_NEXT(multi) {				 \
		int _mi_;					 \
		PyArrayMultiIterObject *_mul_ = (multi);	  \
		_mul_->index += 1;				 \
		for (_mi_=0; _mi_<_mul_->numiter; _mi_++) {	 \
			PyArray_ITER_NEXT(_mul_->iters[_mi_]);	 \
		}						 \
	}

#define PyArray_MultiIter_GOTO(multi, dest) {				\
		int _mi_;						\
		PyArrayMultiIterObject *_mul_ = (multi);		\
		for (_mi_=0; _mi_<_mul_->numiter; _mi_++) {		\
			PyArray_ITER_GOTO(_mul_->iters[_mi_], dest);	\
		}							\
		_mul_->index = _mul_->iters[0]->index;			\
	}

#define PyArray_MultiIter_GOTO1D(multi, ind) {				\
		int _mi_;						\
		PyArrayMultiIterObject *_mul_ = (multi);		\
		for (_mi_=0; _mi_<_mul_->numiter; _mi_++) {		\
			PyArray_ITER_GOTO1D(_mul_->iters[_mi_], ind);	\
		}							\
		_mul_->index = _mul_->iters[0]->index;			\
	}

#define PyArray_MultiIter_DATA(multi, i) \
	((PyArrayMultiIterObject *)multi)->iters[i]->dataptr

#define PyArray_MultiIter_SIZE(multi) \
	((PyArrayMultiIterObject *)multi)->size;


/* Store the information needed for fancy-indexing over an array */

typedef struct {
	PyObject_HEAD
	/* Multi-iterator portion --- needs to be present in this order to
	   work with PyArray_Broadcast */

	int                   numiter;                 /* number of index-array
							  iterators */
	npy_intp              size;                    /* size of broadcasted
							  result */
	npy_intp              index;                   /* current index */
	int                   nd;                      /* number of dims */
	npy_intp              dimensions[NPY_MAXDIMS]; /* dimensions */
	PyArrayIterObject     *iters[NPY_MAXDIMS];     /* index object
							  iterators */
	PyArrayIterObject     *ait;                    /* flat Iterator for
							  underlying array */

	/* flat iterator for subspace (when numiter < nd) */
	PyArrayIterObject     *subspace;

	/* if subspace iteration, then this is the array of
	   axes in the underlying array represented by the
	   index objects */
	int                   iteraxes[NPY_MAXDIMS];
	/* if subspace iteration, the these are the coordinates
	   to the start of the subspace.
	*/
	npy_intp              bscoord[NPY_MAXDIMS];

	PyObject              *indexobj;               /* creating obj */
	int                   view;
	int                   consec;
	char                  *dataptr;

} PyArrayMapIterObject;

/* The default array type
 */
#define PyArray_DEFAULT PyArray_DOUBLE
/* All sorts of useful ways to look into a PyArrayObject.
   These are the recommended over casting to PyArrayObject and accessing
   the members directly.
 */

#define PyArray_NDIM(obj) (((PyArrayObject *)(obj))->nd)
#define PyArray_ISONESEGMENT(m) (PyArray_NDIM(m) == 0 || PyArray_CHKFLAGS(m, NPY_CONTIGUOUS) || \
				 PyArray_CHKFLAGS(m, NPY_FORTRAN))
#define PyArray_ISFORTRAN(m) (PyArray_CHKFLAGS(m, NPY_FORTRAN) && (PyArray_NDIM(m) > 1))
#define FORTRAN_IF(m) ((PyArray_CHKFLAGS(m, NPY_FORTRAN) ? NPY_FORTRAN : 0))
#define PyArray_DATA(obj) ((void *)(((PyArrayObject *)(obj))->data))
#define PyArray_BYTES(obj) (((PyArrayObject *)(obj))->data)
#define PyArray_DIMS(obj) (((PyArrayObject *)(obj))->dimensions)
#define PyArray_STRIDES(obj) (((PyArrayObject *)(obj))->strides)
#define PyArray_DIM(obj,n) (PyArray_DIMS(obj)[n])
#define PyArray_STRIDE(obj,n) (PyArray_STRIDES(obj)[n])
#define PyArray_BASE(obj) (((PyArrayObject *)(obj))->base)
#define PyArray_DESCR(obj) (((PyArrayObject *)(obj))->descr)
#define PyArray_FLAGS(obj) (((PyArrayObject *)(obj))->flags)
#define PyArray_ITEMSIZE(obj) (((PyArrayObject *)(obj))->descr->elsize)
#define PyArray_TYPE(obj) (((PyArrayObject *)(obj))->descr->type_num)
#define PyArray_GETITEM(obj,itemptr)			\
	((PyArrayObject *)(obj))->descr->f->getitem((char *)itemptr,	\
						 (PyArrayObject *)obj);
#define PyArray_SETITEM(obj,itemptr,v)					\
	(obj)->descr->f->setitem((PyObject *)v,(char *)(itemptr),		\
			      (PyArrayObject *)(obj));


#define PyTypeNum_ISBOOL(type) (type == PyArray_BOOL)
#define PyTypeNum_ISUNSIGNED(type) ((type == PyArray_UBYTE) || \
				 (type == PyArray_USHORT) || \
				 (type == PyArray_UINT) ||	\
				 (type == PyArray_ULONG) || \
				 (type == PyArray_ULONGLONG))

#define PyTypeNum_ISSIGNED(type) ((type == PyArray_BYTE) ||	\
			       (type == PyArray_SHORT) ||	\
			       (type == PyArray_INT) ||	\
			       (type == PyArray_LONG) ||	\
			       (type == PyArray_LONGLONG))

#define PyTypeNum_ISINTEGER(type) ((type >= PyArray_BYTE) &&	\
				(type <= PyArray_ULONGLONG))

#define PyTypeNum_ISFLOAT(type) ((type >= PyArray_FLOAT) &&  \
			      (type <= PyArray_LONGDOUBLE))

#define PyTypeNum_ISNUMBER(type) (type <= PyArray_CLONGDOUBLE)

#define PyTypeNum_ISSTRING(type) ((type == PyArray_STRING) || \
			       (type == PyArray_UNICODE))

#define PyTypeNum_ISCOMPLEX(type) ((type >= PyArray_CFLOAT) && \
				(type <= PyArray_CLONGDOUBLE))

#define PyTypeNum_ISPYTHON(type) ((type == PyArray_LONG) || \
				  (type == PyArray_DOUBLE) ||	\
				  (type == PyArray_CDOUBLE) ||	\
		                  (type == PyArray_BOOL) || \
				  (type == PyArray_OBJECT ))

#define PyTypeNum_ISFLEXIBLE(type) ((type>=PyArray_STRING) && \
				    (type<=PyArray_VOID))

#define PyTypeNum_ISUSERDEF(type) ((type >= PyArray_USERDEF) && \
				   (type < PyArray_USERDEF+\
				    PyArray_NUMUSERTYPES))

#define PyTypeNum_ISEXTENDED(type) (PyTypeNum_ISFLEXIBLE(type) ||  \
                                    PyTypeNum_ISUSERDEF(type))

#define PyTypeNum_ISOBJECT(type) ((type) == PyArray_OBJECT)

#define PyDescr_ISBOOL(obj) PyTypeNum_ISBOOL(_PyADt(obj))
#define PyDescr_ISUNSIGNED(obj) PyTypeNum_ISUNSIGNED(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISSIGNED(obj) PyTypeNum_ISSIGNED(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISINTEGER(obj) PyTypeNum_ISINTEGER(((PyArray_Descr*)obj)->type_num )
#define PyDescr_ISFLOAT(obj) PyTypeNum_ISFLOAT(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISNUMBER(obj) PyTypeNum_ISNUMBER(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISSTRING(obj) PyTypeNum_ISSTRING(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISCOMPLEX(obj) PyTypeNum_ISCOMPLEX(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISPYTHON(obj) PyTypeNum_ISPYTHON(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISFLEXIBLE(obj) PyTypeNum_ISFLEXIBLE(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISUSERDEF(obj) PyTypeNum_ISUSERDEF(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISEXTENDED(obj) PyTypeNum_ISEXTENDED(((PyArray_Descr*)obj)->type_num)
#define PyDescr_ISOBJECT(obj) PyTypeNum_ISOBJECT(((PyArray_Descr*)obj)->type_num)
#define PyDescr_HASFIELDS(obj) (((PyArray_Descr *)obj)->fields && \
                                ((PyArray_Descr *)obj)->fields != Py_None)

#define PyArray_ISBOOL(obj) PyTypeNum_ISBOOL(PyArray_TYPE(obj))
#define PyArray_ISUNSIGNED(obj) PyTypeNum_ISUNSIGNED(PyArray_TYPE(obj))
#define PyArray_ISSIGNED(obj) PyTypeNum_ISSIGNED(PyArray_TYPE(obj))
#define PyArray_ISINTEGER(obj) PyTypeNum_ISINTEGER(PyArray_TYPE(obj))
#define PyArray_ISFLOAT(obj) PyTypeNum_ISFLOAT(PyArray_TYPE(obj))
#define PyArray_ISNUMBER(obj) PyTypeNum_ISNUMBER(PyArray_TYPE(obj))
#define PyArray_ISSTRING(obj) PyTypeNum_ISSTRING(PyArray_TYPE(obj))
#define PyArray_ISCOMPLEX(obj) PyTypeNum_ISCOMPLEX(PyArray_TYPE(obj))
#define PyArray_ISPYTHON(obj) PyTypeNum_ISPYTHON(PyArray_TYPE(obj))
#define PyArray_ISFLEXIBLE(obj) PyTypeNum_ISFLEXIBLE(PyArray_TYPE(obj))
#define PyArray_ISUSERDEF(obj) PyTypeNum_ISUSERDEF(PyArray_TYPE(obj))
#define PyArray_ISEXTENDED(obj) PyTypeNum_ISEXTENDED(PyArray_TYPE(obj))
#define PyArray_ISOBJECT(obj) PyTypeNum_ISOBJECT(PyArray_TYPE(obj))
#define PyArray_HASFIELDS(obj) PyDescr_HASFIELDS(PyArray_DESCR(obj))

#define PyArray_LITTLE '<'
#define PyArray_BIG '>'
#define PyArray_NATIVE '='
#define PyArray_SWAP 's'
#define PyArray_IGNORE '|'

#ifdef WORDS_BIGENDIAN
#define PyArray_NATBYTE PyArray_BIG
#define PyArray_OPPBYTE PyArray_LITTLE
#else
#define PyArray_NATBYTE PyArray_LITTLE
#define PyArray_OPPBYTE PyArray_BIG
#endif

#define PyArray_ISNBO(arg) ((arg) != PyArray_OPPBYTE)
#define PyArray_IsNativeByteOrder PyArray_ISNBO
#define PyArray_ISNOTSWAPPED(m) PyArray_ISNBO(PyArray_DESCR(m)->byteorder)
#define PyArray_ISBYTESWAPPED(m) (!PyArray_ISNOTSWAPPED(m))

#define PyArray_FLAGSWAP(m, flags) (PyArray_CHKFLAGS(m, flags) &&	\
				    PyArray_ISNOTSWAPPED(m))
#define PyArray_ISCARRAY(m) PyArray_FLAGSWAP(m, NPY_CARRAY)
#define PyArray_ISCARRAY_RO(m) PyArray_FLAGSWAP(m, NPY_CARRAY_RO)
#define PyArray_ISFARRAY(m) PyArray_FLAGSWAP(m, NPY_FARRAY)
#define PyArray_ISFARRAY_RO(m) PyArray_FLAGSWAP(m, NPY_FARRAY_RO)
#define PyArray_ISBEHAVED(m) PyArray_FLAGSWAP(m, NPY_BEHAVED)
#define PyArray_ISBEHAVED_RO(m) PyArray_FLAGSWAP(m, NPY_ALIGNED)



/* This is the form of the struct that's returned pointed by the
   PyCObject attribute of an array __array_struct__. See
   http://numeric.scipy.org/array_interface.html for the full
   documentation. */
typedef struct {
    int two;              /* contains the integer 2 as a sanity check */
    int nd;               /* number of dimensions */
    char typekind;        /* kind in array --- character code of typestr */
    int itemsize;         /* size of each element */
    int flags;            /* how should be data interpreted. Valid
                             flags are CONTIGUOUS (1), FORTRAN (2),
                             ALIGNED (0x100), NOTSWAPPED (0x200), and
                             WRITEABLE (0x400). 
			     ARR_HAS_DESCR (0x800) states that arrdescr
                                field is present in structure */
    npy_intp *shape;          /* A length-nd array of shape information */
    npy_intp *strides;        /* A length-nd array of stride information */
    void *data;           /* A pointer to the first element of the array */
    PyObject *descr;      /* A list of fields or NULL (ignored if flags
                                does not have ARR_HAS_DESCR flag set) */
} PyArrayInterface;

/* Includes the "function" C-API -- these are all stored in a
   list of pointers --- one for each file
   The two lists are concatenated into one in multiarray.

   They are available as import_array()
*/


#include "__multiarray_api.h"


/* C-API that requries previous API to be defined */

#define PyArray_DescrCheck(op) ((op)->ob_type == &PyArrayDescr_Type)

#define PyArray_Check(op) ((op)->ob_type == &PyArray_Type ||		\
			   PyObject_TypeCheck((op), &PyArray_Type))
#define PyArray_CheckExact(op) ((op)->ob_type == &PyArray_Type)

#define PyArray_IsZeroDim(op) (PyArray_Check(op) && (PyArray_NDIM(op) == 0))
#define PyArray_IsScalar(obj, cls)				\
	(PyObject_TypeCheck((obj), &Py##cls##ArrType_Type))
#define PyArray_CheckScalar(m) (PyArray_IsScalar(m, Generic) || \
                                PyArray_IsZeroDim(m))
#define PyArray_IsPythonNumber(obj) \
	(PyInt_Check(obj) || PyFloat_Check(obj) || PyComplex_Check(obj) || \
	 PyLong_Check(obj) || PyBool_Check(obj))
#define PyArray_IsPythonScalar(obj) \
	(PyArray_IsPythonNumber(obj) || PyString_Check(obj) ||  \
         PyUnicode_Check(obj))
#define PyArray_IsAnyScalar(obj)					\
	(PyArray_IsScalar(obj, Generic) || PyArray_IsPythonScalar(obj))
#define PyArray_CheckAnyScalar(obj) (PyArray_IsPythonScalar(obj) || \
				     PyArray_CheckScalar(obj))

#define PyArray_GETCONTIGUOUS(m) (PyArray_ISCONTIGUOUS(m) ? Py_INCREF(m), m : \
                                  (PyArrayObject *)(PyArray_Copy(m)))

#define PyArray_SAMESHAPE(a1,a2) ((PyArray_NDIM(a1) == PyArray_NDIM(a2)) && \
				  PyArray_CompareLists(PyArray_DIMS(a1), \
						       PyArray_DIMS(a2), \
						       PyArray_NDIM(a1)))
#define PyArray_SIZE(m) PyArray_MultiplyList(PyArray_DIMS(m), PyArray_NDIM(m))
#define PyArray_NBYTES(m) (PyArray_ITEMSIZE(m) * PyArray_SIZE(m))
#define PyArray_FROM_O(m) PyArray_FromAny(m, NULL, 0, 0, 0, NULL)
#define PyArray_FROM_OF(m,flags) PyArray_CheckFromAny(m, NULL, 0, 0, flags, NULL)
#define PyArray_FROM_OT(m,type) PyArray_FromAny(m, PyArray_DescrFromType(type), \
                                                      0, 0, 0, NULL);
#define PyArray_FROM_OTF(m, type, flags)                                \
	PyArray_FromAny(m, PyArray_DescrFromType(type), 0, 0,           \
                        (((flags) & NPY_ENSURECOPY) ?                       \
                         ((flags) | NPY_DEFAULT) : (flags)), NULL)
#define PyArray_FROMANY(m, type, min, max, flags)                       \
	PyArray_FromAny(m, PyArray_DescrFromType(type), min, max,       \
                        (((flags) & NPY_ENSURECOPY) ?                       \
                         (flags) | NPY_DEFAULT : (flags)), NULL)
#define PyArray_ZEROS(m, dims, type, fortran) \
	PyArray_Zeros(m, dims, PyArray_DescrFromType(type), fortran)
#define PyArray_EMPTY(m, dims, type, fortran) \
	PyArray_Empty(m, dims, PyArray_DescrFromType(type), fortran)

#define PyArray_FILLWBYTE(obj, val) memset(PyArray_DATA(obj), (val), PyArray_NBYTES(obj))

#define NPY_REFCOUNT(obj) (((PyObject *)(obj))->ob_refcnt)
#define NPY_MAX_ELSIZE 2*SIZEOF_LONGDOUBLE

#define PyArray_ContiguousFromAny(op, type, min_depth, max_depth)   \
        PyArray_FromAny(op, PyArray_DescrFromType(type), min_depth, \
                              max_depth, NPY_DEFAULT, NULL)

#define PyArray_EquivArrTypes(a1, a2)					\
	PyArray_EquivTypes(PyArray_DESCR(a1), PyArray_DESCR(a2))

#define PyArray_EquivByteorders(b1, b2) \
	(((b1) == (b2)) || (PyArray_ISNBO(b1) == PyArray_ISNBO(b2)))

#define PyArray_SimpleNew(nd, dims, typenum) \
	PyArray_New(&PyArray_Type, nd, dims, typenum, NULL, NULL, 0, 0, NULL)
#define PyArray_SimpleNewFromData(nd, dims, typenum, data) \
        PyArray_New(&PyArray_Type, nd, dims, typenum, NULL, data, 0, NPY_CARRAY, NULL)
#define PyArray_SimpleNewFromDescr(nd, dims, descr) \
	PyArray_NewFromDescr(&PyArray_Type, descr, nd, dims, NULL, NULL, 0, NULL)

#define PyArray_ToScalar(data, arr) \
	PyArray_Scalar(data, PyArray_DESCR(arr), (PyObject *)arr)

/* These might be faster without the dereferencing of obj
   going on inside -- of course an optimizing compiler should
   inline the constants inside a for loop making it a moot point
*/

#define PyArray_GETPTR1(obj, i) (void *)(PyArray_BYTES(obj) +		\
					 i*PyArray_STRIDES(obj)[0])

#define PyArray_GETPTR2(obj, i, j) (void *)(PyArray_BYTES(obj) +	\
					    i*PyArray_STRIDES(obj)[0] +	\
					    j*PyArray_STRIDES(obj)[1])

#define PyArray_GETPTR3(obj, i, j, k) (void *)(PyArray_BYTES(obj) +	\
					       i*PyArray_STRIDES(obj)[0] + \
					       j*PyArray_STRIDES(obj)[1] + \
					       k*PyArray_STRIDES(obj)[2]) \

#define PyArray_GETPTR4(obj, i, j, k, l) (void *)(PyArray_BYTES(obj) +	\
						  i*PyArray_STRIDES(obj)[0] + \
						  j*PyArray_STRIDES(obj)[1] + \
						  k*PyArray_STRIDES(obj)[2] + \
						  l*PyArray_STRIDES(obj)[3])

#define PyArray_XDECREF_ERR(obj) \
	if (obj && (PyArray_FLAGS(obj) & NPY_UPDATEIFCOPY)) {      \
		PyArray_FLAGS(PyArray_BASE(obj)) |= NPY_WRITEABLE; \
		PyArray_FLAGS(obj) &= ~NPY_UPDATEIFCOPY; \
	}\
	Py_XDECREF(obj)

#define PyArray_DESCR_REPLACE(descr) do {	\
		PyArray_Descr *_new_;			\
		_new_ = PyArray_DescrNew(descr);	\
		Py_XDECREF(descr);			\
		descr = _new_;				\
	} while(0)

/* Copy should always return contiguous array */
#define PyArray_Copy(obj) PyArray_NewCopy(obj, PyArray_CORDER)

#define PyArray_FromObject(op, type, min_depth, max_depth)		\
	PyArray_FromAny(op, PyArray_DescrFromType(type), min_depth,	\
                              max_depth, NPY_BEHAVED | NPY_ENSUREARRAY, NULL)

#define PyArray_ContiguousFromObject(op, type, min_depth, max_depth)	\
        PyArray_FromAny(op, PyArray_DescrFromType(type), min_depth,	\
                              max_depth, NPY_DEFAULT | NPY_ENSUREARRAY, NULL)

#define PyArray_CopyFromObject(op, type, min_depth, max_depth)		\
        PyArray_FromAny(op, PyArray_DescrFromType(type), min_depth,     \
                        max_depth, NPY_ENSURECOPY | NPY_DEFAULT | NPY_ENSUREARRAY, NULL)

#define PyArray_Cast(mp, type_num) \
	PyArray_CastToType(mp, PyArray_DescrFromType(type_num), 0)

/* Compatibility with old Numeric stuff -- don't use in new code */

#define PyArray_FromDimsAndData(nd, d, type, data) \
	PyArray_FromDimsAndDataAndDescr(nd, d, PyArray_DescrFromType(type), \
					data)

#ifdef __cplusplus
}
#endif

#endif /* !Py_ARRAYOBJECT_H */
